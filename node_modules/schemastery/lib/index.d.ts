import { Dict } from 'cosmokit';
declare const kSchema: unique symbol;
declare namespace Schema {
    export type From<X> = X extends string | number | boolean ? Schema<X> : X extends Schema ? X : X extends typeof String ? Schema<string> : X extends typeof Number ? Schema<number> : X extends typeof Boolean ? Schema<boolean> : X extends typeof Function ? Schema<Function, (...args: any[]) => any> : X extends Constructor<infer S> ? Schema<S> : never;
    type _TypeS<X> = X extends Schema<infer S, unknown> ? S : never;
    type Inverse<X> = X extends Schema<any, infer Y> ? (arg: Y) => void : never;
    export type TypeS<X> = _TypeS<From<X>>;
    export type TypeT<X> = ReturnType<From<X>>;
    export type Resolve = (data: any, schema: Schema, strict?: boolean) => [any, any?];
    export type IntersectS<X> = From<X> extends Schema<infer S, unknown> ? S : never;
    export type IntersectT<X> = Inverse<From<X>> extends ((arg: infer T) => void) ? T : never;
    export interface Base<T = any> {
        uid: number;
        meta: Meta<T>;
        type: string;
        sKey?: Schema;
        inner?: Schema;
        list?: Schema[];
        dict?: Dict<Schema>;
        bits?: Dict<number>;
        callback?: Function;
        value?: T;
        refs?: Dict<Schema>;
        toString(inline?: boolean): string;
    }
    export interface Meta<T = any> {
        default?: T extends {} ? Partial<T> : T;
        required?: boolean;
        hidden?: boolean;
        role?: string;
        link?: string;
        description?: string;
        comment?: string;
        pattern?: {
            source: string;
            flags?: string;
        };
        max?: number;
        min?: number;
        step?: number;
    }
    type TupleS<X extends readonly any[]> = X extends readonly [infer L, ...infer R] ? [TypeS<L>?, ...TupleS<R>] : any[];
    type TupleT<X extends readonly any[]> = X extends readonly [infer L, ...infer R] ? [TypeT<L>?, ...TupleT<R>] : any[];
    type ObjectS<X extends Dict> = {
        [K in keyof X]?: TypeS<X[K]>;
    } & Dict;
    type ObjectT<X extends Dict> = {
        [K in keyof X]: TypeT<X[K]>;
    } & Dict;
    type Constructor<T = any> = new (...args: any[]) => T;
    export interface Static {
        <T = any>(options: Partial<Base<T>>): Schema<T>;
        new <T = any>(options: Partial<Base<T>>): Schema<T>;
        prototype: Schema;
        resolve: Resolve;
        from<X = any>(source?: X): From<X>;
        extend(type: string, resolve: Resolve): void;
        any(): Schema<any>;
        never(): Schema<never>;
        const<T>(value: T): Schema<T>;
        string(): Schema<string>;
        number(): Schema<number>;
        natural(): Schema<number>;
        percent(): Schema<number>;
        boolean(): Schema<boolean>;
        date(): Schema<string | Date, Date>;
        bitset<K extends string>(bits: Partial<Record<K, number>>): Schema<number | readonly K[], number>;
        function(): Schema<Function, (...args: any[]) => any>;
        is<T>(constructor: Constructor<T>): Schema<T>;
        array<X>(inner: X): Schema<TypeS<X>[], TypeT<X>[]>;
        dict<X, Y extends Schema<any, string> = Schema<string>>(inner: X, sKey?: Y): Schema<Dict<TypeS<X>, TypeS<Y>>, Dict<TypeT<X>, TypeT<Y>>>;
        tuple<X extends readonly any[]>(list: X): Schema<TupleS<X>, TupleT<X>>;
        object<X extends Dict>(dict: X): Schema<ObjectS<X>, ObjectT<X>>;
        union<X>(list: readonly X[]): Schema<TypeS<X>, TypeT<X>>;
        intersect<X>(list: readonly X[]): Schema<IntersectS<X>, IntersectT<X>>;
        transform<X, T>(inner: X, callback: (value: TypeS<X>) => T): Schema<TypeS<X>, T>;
    }
    export {};
}
declare const Schema: Schema.Static;
interface Schema<S = any, T = S> extends Schema.Base<T> {
    (data?: S | null): T;
    new (data?: S | null): T;
    [kSchema]: true;
    toJSON(): Schema.Base<T>;
    required(value?: boolean): Schema<S, T>;
    hidden(value?: boolean): Schema<S, T>;
    role(text: string): Schema<S, T>;
    link(link: string): Schema<S, T>;
    default(value: T): Schema<S, T>;
    comment(text: string): Schema<S, T>;
    description(text: string): Schema<S, T>;
    pattern(regexp: RegExp): Schema<S, T>;
    max(value: number): Schema<S, T>;
    min(value: number): Schema<S, T>;
    step(value: number): Schema<S, T>;
    set(key: string, value: Schema): Schema<S, T>;
    push(value: Schema): Schema<S, T>;
    simplify(value?: any): any;
}
export = Schema;
