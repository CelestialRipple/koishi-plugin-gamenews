{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["import { clone, deepEqual, Dict, isNullable, isPlainObject, pick, valueMap } from 'cosmokit'\n\nconst kSchema = Symbol.for('schemastery')\n\nnamespace Schema {\n  export type From<X> =\n    | X extends string | number | boolean ? Schema<X>\n    : X extends Schema ? X\n    : X extends typeof String ? Schema<string>\n    : X extends typeof Number ? Schema<number>\n    : X extends typeof Boolean ? Schema<boolean>\n    : X extends typeof Function ? Schema<Function, (...args: any[]) => any>\n    : X extends Constructor<infer S> ? Schema<S>\n    : never\n\n  type _TypeS<X> = X extends Schema<infer S, unknown> ? S : never\n  type Inverse<X> = X extends Schema<any, infer Y> ? (arg: Y) => void : never\n\n  export type TypeS<X> = _TypeS<From<X>>\n  export type TypeT<X> = ReturnType<From<X>>\n  export type Resolve = (data: any, schema: Schema, strict?: boolean) => [any, any?]\n\n  export type IntersectS<X> = From<X> extends Schema<infer S, unknown> ? S : never\n  export type IntersectT<X> = Inverse<From<X>> extends ((arg: infer T) => void) ? T : never\n\n  export interface Base<T = any> {\n    uid: number\n    meta: Meta<T>\n    type: string\n    sKey?: Schema\n    inner?: Schema\n    list?: Schema[]\n    dict?: Dict<Schema>\n    bits?: Dict<number>\n    callback?: Function\n    value?: T\n    refs?: Dict<Schema>\n    toString(inline?: boolean): string\n  }\n\n  export interface Meta<T = any> {\n    default?: T extends {} ? Partial<T> : T\n    required?: boolean\n    hidden?: boolean\n    role?: string\n    link?: string\n    description?: string\n    comment?: string\n    pattern?: { source: string, flags?: string }\n    max?: number\n    min?: number\n    step?: number\n  }\n\n  type TupleS<X extends readonly any[]> = X extends readonly [infer L, ...infer R] ? [TypeS<L>?, ...TupleS<R>] : any[]\n  type TupleT<X extends readonly any[]> = X extends readonly [infer L, ...infer R] ? [TypeT<L>?, ...TupleT<R>] : any[]\n  type ObjectS<X extends Dict> = { [K in keyof X]?: TypeS<X[K]> } & Dict\n  type ObjectT<X extends Dict> = { [K in keyof X]: TypeT<X[K]> } & Dict\n  type Constructor<T = any> = new (...args: any[]) => T\n\n  export interface Static {\n    <T = any>(options: Partial<Base<T>>): Schema<T>\n    new <T = any>(options: Partial<Base<T>>): Schema<T>\n    prototype: Schema\n    resolve: Resolve\n    from<X = any>(source?: X): From<X>\n    extend(type: string, resolve: Resolve): void\n    any(): Schema<any>\n    never(): Schema<never>\n    const<T>(value: T): Schema<T>\n    string(): Schema<string>\n    number(): Schema<number>\n    natural(): Schema<number>\n    percent(): Schema<number>\n    boolean(): Schema<boolean>\n    date(): Schema<string | Date, Date>\n    bitset<K extends string>(bits: Partial<Record<K, number>>): Schema<number | readonly K[], number>\n    function(): Schema<Function, (...args: any[]) => any>\n    is<T>(constructor: Constructor<T>): Schema<T>\n    array<X>(inner: X): Schema<TypeS<X>[], TypeT<X>[]>\n    dict<X, Y extends Schema<any, string> = Schema<string>>(inner: X, sKey?: Y): Schema<Dict<TypeS<X>, TypeS<Y>>, Dict<TypeT<X>, TypeT<Y>>>\n    tuple<X extends readonly any[]>(list: X): Schema<TupleS<X>, TupleT<X>>\n    object<X extends Dict>(dict: X): Schema<ObjectS<X>, ObjectT<X>>\n    union<X>(list: readonly X[]): Schema<TypeS<X>, TypeT<X>>\n    intersect<X>(list: readonly X[]): Schema<IntersectS<X>, IntersectT<X>>\n    transform<X, T>(inner: X, callback: (value: TypeS<X>) => T): Schema<TypeS<X>, T>\n  }\n}\n\nconst Schema = function (options: Schema.Base) {\n  const schema = function (data: any) {\n    return Schema.resolve(data, schema)[0]\n  } as Schema\n\n  if (options.refs) {\n    const refs = valueMap(options.refs, options => new Schema(options))\n    const getRef = (uid: any) => refs[uid]!\n    for (const key in refs) {\n      const options = refs[key]!\n      options.sKey = getRef(options.sKey)\n      options.inner = getRef(options.inner)\n      options.list = options.list && options.list.map(getRef)\n      options.dict = options.dict && valueMap(options.dict, getRef)\n    }\n    return refs[options.uid!]\n  }\n\n  Object.assign(schema, options)\n  Object.defineProperty(schema, 'uid', { value: index++ })\n  Object.setPrototypeOf(schema, Schema.prototype)\n  schema.meta ||= {}\n  return schema\n} as Schema.Static\n\ninterface Schema<S = any, T = S> extends Schema.Base<T> {\n  (data?: S | null): T\n  new (data?: S | null): T\n  [kSchema]: true\n  toJSON(): Schema.Base<T>\n  required(value?: boolean): Schema<S, T>\n  hidden(value?: boolean): Schema<S, T>\n  role(text: string): Schema<S, T>\n  link(link: string): Schema<S, T>\n  default(value: T): Schema<S, T>\n  comment(text: string): Schema<S, T>\n  description(text: string): Schema<S, T>\n  pattern(regexp: RegExp): Schema<S, T>\n  max(value: number): Schema<S, T>\n  min(value: number): Schema<S, T>\n  step(value: number): Schema<S, T>\n  set(key: string, value: Schema): Schema<S, T>\n  push(value: Schema): Schema<S, T>\n  simplify(value?: any): any\n}\n\nlet index = 0\n\nSchema.prototype = Object.create(Function.prototype)\n\nSchema.prototype[kSchema] = true\n\nlet refs: Record<number, Schema> | undefined\n\nSchema.prototype.toJSON = function toJSON() {\n  if (refs) {\n    refs[this.uid] ??= JSON.parse(JSON.stringify({ ...this }))\n    return this.uid as any\n  }\n\n  refs = { [this.uid]: { ...this } as Schema }\n  refs[this.uid] = JSON.parse(JSON.stringify({ ...this }))\n  const result = { uid: this.uid, refs }\n  refs = undefined\n  return result\n}\n\nSchema.prototype.set = function set(key, value) {\n  this.dict![key] = value\n  return this\n}\n\nSchema.prototype.push = function push(value) {\n  this.list!.push(value)\n  return this\n}\n\nfor (const key of ['required', 'hidden']) {\n  Object.assign(Schema.prototype, {\n    [key](this: Schema, value = true) {\n      const schema = Schema(this)\n      schema.meta = { ...schema.meta, [key]: value }\n      return schema\n    },\n  })\n}\n\nSchema.prototype.pattern = function pattern(regexp) {\n  const schema = Schema(this)\n  const pattern = pick(regexp, ['source', 'flags'])\n  schema.meta = { ...schema.meta, pattern }\n  return schema\n}\n\nSchema.prototype.simplify = function simplify(this: Schema, value) {\n  if (deepEqual(value, this.meta.default)) return\n  if (this.type === 'object' || this.type === 'dict') {\n    const result: Dict = {}\n    for (const key in value) {\n      const schema = this.type === 'object' ? this.dict![key] : this.inner\n      const item = schema?.simplify(value[key])\n      if (!isNullable(item)) result[key] = item\n    }\n    return result\n  } else if (this.type === 'array' || this.type === 'tuple') {\n    const result: any[] = []\n    for (const key of value) {\n      const schema = this.type === 'array' ? this.inner : this.list![key]\n      const item = schema ? schema.simplify(value[key]) : value[key]\n      result.push(item)\n    }\n    return result\n  } else if (this.type === 'intersect') {\n    const result: Dict = {}\n    for (const item of this.list!) {\n      Object.assign(result, item.simplify(value))\n    }\n    return result\n  } else if (this.type === 'union') {\n    for (const schema of this.list!) {\n      try {\n        Schema.resolve(value, schema)\n        return schema.simplify(value)\n      } catch {}\n    }\n  }\n  return value\n}\n\nfor (const key of ['default', 'role', 'link', 'comment', 'description', 'max', 'min', 'step']) {\n  Object.assign(Schema.prototype, {\n    [key](this: Schema, value: any) {\n      const schema = Schema(this)\n      schema.meta = { ...schema.meta, [key]: value }\n      return schema\n    },\n  })\n}\n\nconst resolvers: Dict<Schema.Resolve> = {}\n\nSchema.extend = function extend(type: string, resolve) {\n  resolvers[type] = resolve\n}\n\nSchema.resolve = function resolve(data, schema, strict) {\n  if (!schema) return [data]\n\n  if (isNullable(data)) {\n    if (schema.meta.required) throw new TypeError(`missing required value`)\n    const fallback = schema.meta.default\n    if (isNullable(fallback)) return [data]\n    data = clone(fallback)\n  }\n\n  const callback = resolvers[schema.type]\n  if (callback) return callback(data, schema, strict)\n  throw new TypeError(`unsupported type \"${schema.type}\"`)\n}\n\nSchema.from = function from(source: any) {\n  if (isNullable(source)) {\n    return Schema.any()\n  } else if (['string', 'number', 'boolean'].includes(typeof source)) {\n    return Schema.const(source).required()\n  } else if (source[kSchema]) {\n    return source\n  } else if (typeof source === 'function') {\n    switch (source) {\n      case String: return Schema.string().required()\n      case Number: return Schema.number().required()\n      case Boolean: return Schema.boolean().required()\n      case Function: return Schema.function().required()\n      default: return Schema.is(source).required()\n    }\n  } else {\n    throw new TypeError(`cannot infer schema from ${source}`)\n  }\n}\n\nSchema.natural = function natural() {\n  return Schema.number().step(1).min(0)\n}\n\nSchema.percent = function percent() {\n  return Schema.number().step(0.01).min(0).max(1).role('slider')\n}\n\nSchema.date = () => Schema.union([\n  Schema.is(Date),\n  Schema.transform(Schema.string().role('datetime'), (value) => {\n    const date = new Date(value)\n    if (isNaN(+date)) throw new TypeError(`invalid date \"${value}\"`)\n    return date\n  }),\n])\n\nSchema.extend('any', (data) => {\n  return [data]\n})\n\nSchema.extend('never', (data) => {\n  throw new TypeError(`expected nullable but got ${data}`)\n})\n\nSchema.extend('const', (data, { value }) => {\n  if (data === value) return [value]\n  throw new TypeError(`expected ${value} but got ${data}`)\n})\n\nfunction checkWithinRange(data: number, meta: Schema.Meta<any>, description: string) {\n  const { max = Infinity, min = -Infinity } = meta\n  if (data > max) throw new TypeError(`expected ${description} <= ${max} but got ${data}`)\n  if (data < min) throw new TypeError(`expected ${description} >= ${min} but got ${data}`)\n}\n\nSchema.extend('string', (data, { meta }) => {\n  if (typeof data !== 'string') throw new TypeError(`expected string but got ${data}`)\n  if (meta.pattern) {\n    const regexp = new RegExp(meta.pattern.source, meta.pattern.flags)\n    if (!regexp.test(data)) throw new TypeError(`expect string to match regexp ${regexp}`)\n  }\n  checkWithinRange(data.length, meta, 'string length')\n  return [data]\n})\n\nSchema.extend('number', (data, { meta }) => {\n  if (typeof data !== 'number') throw new TypeError(`expected number but got ${data}`)\n  checkWithinRange(data, meta, 'number')\n  const { step } = meta\n  if (step) {\n    const quotient = Math.abs(data - (meta.min ?? 0)) % step\n    if (quotient >= Number.EPSILON && quotient < step - Number.EPSILON) {\n      throw new TypeError(`expected number multiple of ${step} but got ${data}`)\n    }\n  }\n  return [data]\n})\n\nSchema.extend('boolean', (data) => {\n  if (typeof data === 'boolean') return [data]\n  throw new TypeError(`expected boolean but got ${data}`)\n})\n\nSchema.extend('bitset', (data, { bits }) => {\n  if (typeof data === 'number') return [data]\n  if (!Array.isArray(data)) throw new TypeError(`expected array but got ${data}`)\n  let result = 0\n  for (const value of data) {\n    if (typeof value !== 'string') throw new TypeError(`expected string but got ${value}`)\n    if (!(value in bits!)) throw new TypeError(`unknown value ${value}`)\n    result |= bits![value]!\n  }\n  return [result, result]\n})\n\nSchema.extend('function', (data) => {\n  if (typeof data === 'function') return [data]\n  throw new TypeError(`expected function but got ${data}`)\n})\n\nSchema.extend('is', (data, { callback }) => {\n  if (data instanceof callback!) return [data]\n  throw new TypeError(`expected ${callback!.name} but got ${data}`)\n})\n\nfunction property(data: any, key: keyof any, schema: Schema) {\n  const [value, adapted] = Schema.resolve(data[key], schema)\n  if (!isNullable(adapted)) data[key] = adapted\n  return value\n}\n\nSchema.extend('array', (data, { inner, meta }) => {\n  if (!Array.isArray(data)) throw new TypeError(`expected array but got ${data}`)\n  checkWithinRange(data.length, meta, 'array length')\n  return [data.map((_, index) => property(data, index, inner!))]\n})\n\nSchema.extend('dict', (data, { inner, sKey }, strict) => {\n  if (!isPlainObject(data)) throw new TypeError(`expected object but got ${data}`)\n  const result: any = {}\n  for (const key in data) {\n    let rKey: string\n    try {\n      rKey = Schema.resolve(key, sKey!)[0]\n    } catch (error) {\n      if (strict) continue\n      throw error\n    }\n    result[rKey] = property(data, key, inner!)\n    data[rKey] = data[key]\n    if (key !== rKey) delete data[key]\n  }\n  return [result]\n})\n\nSchema.extend('tuple', (data, { list }, strict) => {\n  if (!Array.isArray(data)) throw new TypeError(`expected array but got ${data}`)\n  const result = list!.map((inner, index) => property(data, index, inner))\n  if (strict) return [result]\n  result.push(...data.slice(list!.length))\n  return [result]\n})\n\nfunction merge(result: any, data: any) {\n  for (const key in data) {\n    if (key in result) continue\n    result[key] = data[key]\n  }\n}\n\nSchema.extend('object', (data, { dict }, strict) => {\n  if (!isPlainObject(data)) throw new TypeError(`expected object but got ${data}`)\n  const result: any = {}\n  for (const key in dict) {\n    const value = property(data, key, dict![key]!)\n    if (!isNullable(value) || key in data) {\n      result[key] = value\n    }\n  }\n  if (!strict) merge(result, data)\n  return [result]\n})\n\nSchema.extend('union', (data, { list, toString }) => {\n  const messages: string[] = []\n  for (const inner of list!) {\n    try {\n      return Schema.resolve(data, inner)\n    } catch (error) {\n      // messages.push(error.message)\n    }\n  }\n  throw new TypeError(`expected ${toString()} but got ${JSON.stringify(data)}`)\n})\n\nSchema.extend('intersect', (data, { list, toString }, strict) => {\n  let result\n  for (const inner of list!) {\n    const value = Schema.resolve(data, inner, true)[0]\n    if (isNullable(value)) continue\n    if (isNullable(result)) {\n      result = value\n    } else if (typeof result !== typeof value) {\n      throw new TypeError(`expected ${toString()} but got ${JSON.stringify(data)}`)\n    } else if (typeof value === 'object') {\n      result = { ...result as any, ...value }\n    } else if (result !== value) {\n      throw new TypeError(`expected ${toString()} but got ${JSON.stringify(data)}`)\n    }\n  }\n  if (!strict && isPlainObject(data)) merge(result, data)\n  return [result]\n})\n\nSchema.extend('transform', (data, { inner, callback }) => {\n  const [result, adapted = data] = Schema.resolve(data, inner!, true)\n  if (isPlainObject(data)) {\n    const temp: any = {}\n    for (const key in result) {\n      if (!(key in data)) continue\n      temp[key] = data[key]\n      delete data[key]\n    }\n    Object.assign(data, callback!(temp))\n    return [callback!(result)]\n  } else {\n    return [callback!(result), callback!(adapted)]\n  }\n})\n\ntype Formatter = (schema: Schema, inline?: boolean) => string\n\nfunction defineMethod(name: string, keys: (keyof Schema.Base)[], format: Formatter) {\n  Object.assign(Schema, {\n    [name](...args: any[]) {\n      const schema = new Schema({ type: name } as Schema.Base)\n      schema.toString = format.bind(null, schema)\n      keys.forEach((key, index) => {\n        switch (key) {\n          case 'sKey': schema.sKey = args[index] ?? Schema.string(); break\n          case 'inner': schema.inner = Schema.from(args[index]); break\n          case 'list': schema.list = args[index].map(Schema.from); break\n          case 'dict': schema.dict = valueMap(args[index], Schema.from); break\n          case 'bits': {\n            schema.bits = {}\n            for (const key in args[index]) {\n              if (typeof args[index][key] !== 'number') continue\n              schema.bits[key] = args[index][key]\n            }\n            break\n          }\n          default: schema[key] = args[index] as never\n        }\n      })\n      if (name === 'object' || name === 'dict') {\n        schema.meta.default = {}\n      } else if (name === 'array' || name === 'tuple') {\n        schema.meta.default = []\n      } else if (name === 'bitset') {\n        schema.meta.default = 0\n      }\n      return schema\n    },\n  })\n}\n\ndefineMethod('is', ['callback'], ({ callback }) => callback!.name)\ndefineMethod('any', [], () => 'any')\ndefineMethod('never', [], () => 'never')\ndefineMethod('const', ['value'], ({ value }) => typeof value === 'string' ? JSON.stringify(value) : value)\ndefineMethod('string', [], () => 'string')\ndefineMethod('number', [], () => 'number')\ndefineMethod('boolean', [], () => 'boolean')\ndefineMethod('bitset', ['bits'], () => 'bitset')\ndefineMethod('function', [], () => 'function')\ndefineMethod('array', ['inner'], ({ inner }) => `${inner!.toString(true)}[]`)\ndefineMethod('dict', ['inner', 'sKey'], ({ inner, sKey }) => `{ [key: ${sKey!.toString()}]: ${inner!.toString()} }`)\ndefineMethod('tuple', ['list'], ({ list }) => `[${list!.map((inner) => inner.toString()).join(', ')}]`)\n\ndefineMethod('object', ['dict'], ({ dict }) => {\n  if (Object.keys(dict!).length === 0) return '{}'\n  return `{ ${Object.entries(dict!).map(([key, inner]) => {\n    return `${key}${inner!.meta.required ? '' : '?'}: ${inner!.toString()}`\n  }).join(', ')} }`\n})\n\ndefineMethod('union', ['list'], ({ list }, inline) => {\n  const result = list!.map(({ toString: format }) => format()).join(' | ')\n  return inline ? `(${result})` : result\n})\n\ndefineMethod('intersect', ['list'], ({ list }) => {\n  return `${list!.map((inner) => inner.toString(true)).join(' & ')}`\n})\n\ndefineMethod('transform', ['inner', 'callback'], ({ inner }, isInner) => inner!.toString(isInner))\n\nexport = Schema\n"],
  "mappings": "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",
  "names": ["refs", "options", "pattern", "index", "key"]
}
