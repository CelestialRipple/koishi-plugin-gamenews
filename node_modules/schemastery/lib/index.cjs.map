{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["import { clone, deepEqual, Dict, isNullable, isPlainObject, pick, valueMap } from 'cosmokit'\n\nconst kSchema = Symbol.for('schemastery')\n\nnamespace Schema {\n  export type From<X> =\n    | X extends string | number | boolean ? Schema<X>\n    : X extends Schema ? X\n    : X extends typeof String ? Schema<string>\n    : X extends typeof Number ? Schema<number>\n    : X extends typeof Boolean ? Schema<boolean>\n    : X extends typeof Function ? Schema<Function, (...args: any[]) => any>\n    : X extends Constructor<infer S> ? Schema<S>\n    : never\n\n  type _TypeS<X> = X extends Schema<infer S, unknown> ? S : never\n  type Inverse<X> = X extends Schema<any, infer Y> ? (arg: Y) => void : never\n\n  export type TypeS<X> = _TypeS<From<X>>\n  export type TypeT<X> = ReturnType<From<X>>\n  export type Resolve = (data: any, schema: Schema, strict?: boolean) => [any, any?]\n\n  export type IntersectS<X> = From<X> extends Schema<infer S, unknown> ? S : never\n  export type IntersectT<X> = Inverse<From<X>> extends ((arg: infer T) => void) ? T : never\n\n  export interface Base<T = any> {\n    uid: number\n    meta: Meta<T>\n    type: string\n    sKey?: Schema\n    inner?: Schema\n    list?: Schema[]\n    dict?: Dict<Schema>\n    bits?: Dict<number>\n    callback?: Function\n    value?: T\n    refs?: Dict<Schema>\n    toString(inline?: boolean): string\n  }\n\n  export interface Meta<T = any> {\n    default?: T extends {} ? Partial<T> : T\n    required?: boolean\n    hidden?: boolean\n    role?: string\n    link?: string\n    description?: string\n    comment?: string\n    pattern?: { source: string, flags?: string }\n    max?: number\n    min?: number\n    step?: number\n  }\n\n  type TupleS<X extends readonly any[]> = X extends readonly [infer L, ...infer R] ? [TypeS<L>?, ...TupleS<R>] : any[]\n  type TupleT<X extends readonly any[]> = X extends readonly [infer L, ...infer R] ? [TypeT<L>?, ...TupleT<R>] : any[]\n  type ObjectS<X extends Dict> = { [K in keyof X]?: TypeS<X[K]> } & Dict\n  type ObjectT<X extends Dict> = { [K in keyof X]: TypeT<X[K]> } & Dict\n  type Constructor<T = any> = new (...args: any[]) => T\n\n  export interface Static {\n    <T = any>(options: Partial<Base<T>>): Schema<T>\n    new <T = any>(options: Partial<Base<T>>): Schema<T>\n    prototype: Schema\n    resolve: Resolve\n    from<X = any>(source?: X): From<X>\n    extend(type: string, resolve: Resolve): void\n    any(): Schema<any>\n    never(): Schema<never>\n    const<T>(value: T): Schema<T>\n    string(): Schema<string>\n    number(): Schema<number>\n    natural(): Schema<number>\n    percent(): Schema<number>\n    boolean(): Schema<boolean>\n    date(): Schema<string | Date, Date>\n    bitset<K extends string>(bits: Partial<Record<K, number>>): Schema<number | readonly K[], number>\n    function(): Schema<Function, (...args: any[]) => any>\n    is<T>(constructor: Constructor<T>): Schema<T>\n    array<X>(inner: X): Schema<TypeS<X>[], TypeT<X>[]>\n    dict<X, Y extends Schema<any, string> = Schema<string>>(inner: X, sKey?: Y): Schema<Dict<TypeS<X>, TypeS<Y>>, Dict<TypeT<X>, TypeT<Y>>>\n    tuple<X extends readonly any[]>(list: X): Schema<TupleS<X>, TupleT<X>>\n    object<X extends Dict>(dict: X): Schema<ObjectS<X>, ObjectT<X>>\n    union<X>(list: readonly X[]): Schema<TypeS<X>, TypeT<X>>\n    intersect<X>(list: readonly X[]): Schema<IntersectS<X>, IntersectT<X>>\n    transform<X, T>(inner: X, callback: (value: TypeS<X>) => T): Schema<TypeS<X>, T>\n  }\n}\n\nconst Schema = function (options: Schema.Base) {\n  const schema = function (data: any) {\n    return Schema.resolve(data, schema)[0]\n  } as Schema\n\n  if (options.refs) {\n    const refs = valueMap(options.refs, options => new Schema(options))\n    const getRef = (uid: any) => refs[uid]!\n    for (const key in refs) {\n      const options = refs[key]!\n      options.sKey = getRef(options.sKey)\n      options.inner = getRef(options.inner)\n      options.list = options.list && options.list.map(getRef)\n      options.dict = options.dict && valueMap(options.dict, getRef)\n    }\n    return refs[options.uid!]\n  }\n\n  Object.assign(schema, options)\n  Object.defineProperty(schema, 'uid', { value: index++ })\n  Object.setPrototypeOf(schema, Schema.prototype)\n  schema.meta ||= {}\n  return schema\n} as Schema.Static\n\ninterface Schema<S = any, T = S> extends Schema.Base<T> {\n  (data?: S | null): T\n  new (data?: S | null): T\n  [kSchema]: true\n  toJSON(): Schema.Base<T>\n  required(value?: boolean): Schema<S, T>\n  hidden(value?: boolean): Schema<S, T>\n  role(text: string): Schema<S, T>\n  link(link: string): Schema<S, T>\n  default(value: T): Schema<S, T>\n  comment(text: string): Schema<S, T>\n  description(text: string): Schema<S, T>\n  pattern(regexp: RegExp): Schema<S, T>\n  max(value: number): Schema<S, T>\n  min(value: number): Schema<S, T>\n  step(value: number): Schema<S, T>\n  set(key: string, value: Schema): Schema<S, T>\n  push(value: Schema): Schema<S, T>\n  simplify(value?: any): any\n}\n\nlet index = 0\n\nSchema.prototype = Object.create(Function.prototype)\n\nSchema.prototype[kSchema] = true\n\nlet refs: Record<number, Schema> | undefined\n\nSchema.prototype.toJSON = function toJSON() {\n  if (refs) {\n    refs[this.uid] ??= JSON.parse(JSON.stringify({ ...this }))\n    return this.uid as any\n  }\n\n  refs = { [this.uid]: { ...this } as Schema }\n  refs[this.uid] = JSON.parse(JSON.stringify({ ...this }))\n  const result = { uid: this.uid, refs }\n  refs = undefined\n  return result\n}\n\nSchema.prototype.set = function set(key, value) {\n  this.dict![key] = value\n  return this\n}\n\nSchema.prototype.push = function push(value) {\n  this.list!.push(value)\n  return this\n}\n\nfor (const key of ['required', 'hidden']) {\n  Object.assign(Schema.prototype, {\n    [key](this: Schema, value = true) {\n      const schema = Schema(this)\n      schema.meta = { ...schema.meta, [key]: value }\n      return schema\n    },\n  })\n}\n\nSchema.prototype.pattern = function pattern(regexp) {\n  const schema = Schema(this)\n  const pattern = pick(regexp, ['source', 'flags'])\n  schema.meta = { ...schema.meta, pattern }\n  return schema\n}\n\nSchema.prototype.simplify = function simplify(this: Schema, value) {\n  if (deepEqual(value, this.meta.default)) return\n  if (this.type === 'object' || this.type === 'dict') {\n    const result: Dict = {}\n    for (const key in value) {\n      const schema = this.type === 'object' ? this.dict![key] : this.inner\n      const item = schema?.simplify(value[key])\n      if (!isNullable(item)) result[key] = item\n    }\n    return result\n  } else if (this.type === 'array' || this.type === 'tuple') {\n    const result: any[] = []\n    for (const key of value) {\n      const schema = this.type === 'array' ? this.inner : this.list![key]\n      const item = schema ? schema.simplify(value[key]) : value[key]\n      result.push(item)\n    }\n    return result\n  } else if (this.type === 'intersect') {\n    const result: Dict = {}\n    for (const item of this.list!) {\n      Object.assign(result, item.simplify(value))\n    }\n    return result\n  } else if (this.type === 'union') {\n    for (const schema of this.list!) {\n      try {\n        Schema.resolve(value, schema)\n        return schema.simplify(value)\n      } catch {}\n    }\n  }\n  return value\n}\n\nfor (const key of ['default', 'role', 'link', 'comment', 'description', 'max', 'min', 'step']) {\n  Object.assign(Schema.prototype, {\n    [key](this: Schema, value: any) {\n      const schema = Schema(this)\n      schema.meta = { ...schema.meta, [key]: value }\n      return schema\n    },\n  })\n}\n\nconst resolvers: Dict<Schema.Resolve> = {}\n\nSchema.extend = function extend(type: string, resolve) {\n  resolvers[type] = resolve\n}\n\nSchema.resolve = function resolve(data, schema, strict) {\n  if (!schema) return [data]\n\n  if (isNullable(data)) {\n    if (schema.meta.required) throw new TypeError(`missing required value`)\n    const fallback = schema.meta.default\n    if (isNullable(fallback)) return [data]\n    data = clone(fallback)\n  }\n\n  const callback = resolvers[schema.type]\n  if (callback) return callback(data, schema, strict)\n  throw new TypeError(`unsupported type \"${schema.type}\"`)\n}\n\nSchema.from = function from(source: any) {\n  if (isNullable(source)) {\n    return Schema.any()\n  } else if (['string', 'number', 'boolean'].includes(typeof source)) {\n    return Schema.const(source).required()\n  } else if (source[kSchema]) {\n    return source\n  } else if (typeof source === 'function') {\n    switch (source) {\n      case String: return Schema.string().required()\n      case Number: return Schema.number().required()\n      case Boolean: return Schema.boolean().required()\n      case Function: return Schema.function().required()\n      default: return Schema.is(source).required()\n    }\n  } else {\n    throw new TypeError(`cannot infer schema from ${source}`)\n  }\n}\n\nSchema.natural = function natural() {\n  return Schema.number().step(1).min(0)\n}\n\nSchema.percent = function percent() {\n  return Schema.number().step(0.01).min(0).max(1).role('slider')\n}\n\nSchema.date = () => Schema.union([\n  Schema.is(Date),\n  Schema.transform(Schema.string().role('datetime'), (value) => {\n    const date = new Date(value)\n    if (isNaN(+date)) throw new TypeError(`invalid date \"${value}\"`)\n    return date\n  }),\n])\n\nSchema.extend('any', (data) => {\n  return [data]\n})\n\nSchema.extend('never', (data) => {\n  throw new TypeError(`expected nullable but got ${data}`)\n})\n\nSchema.extend('const', (data, { value }) => {\n  if (data === value) return [value]\n  throw new TypeError(`expected ${value} but got ${data}`)\n})\n\nfunction checkWithinRange(data: number, meta: Schema.Meta<any>, description: string) {\n  const { max = Infinity, min = -Infinity } = meta\n  if (data > max) throw new TypeError(`expected ${description} <= ${max} but got ${data}`)\n  if (data < min) throw new TypeError(`expected ${description} >= ${min} but got ${data}`)\n}\n\nSchema.extend('string', (data, { meta }) => {\n  if (typeof data !== 'string') throw new TypeError(`expected string but got ${data}`)\n  if (meta.pattern) {\n    const regexp = new RegExp(meta.pattern.source, meta.pattern.flags)\n    if (!regexp.test(data)) throw new TypeError(`expect string to match regexp ${regexp}`)\n  }\n  checkWithinRange(data.length, meta, 'string length')\n  return [data]\n})\n\nSchema.extend('number', (data, { meta }) => {\n  if (typeof data !== 'number') throw new TypeError(`expected number but got ${data}`)\n  checkWithinRange(data, meta, 'number')\n  const { step } = meta\n  if (step) {\n    const quotient = Math.abs(data - (meta.min ?? 0)) % step\n    if (quotient >= Number.EPSILON && quotient < step - Number.EPSILON) {\n      throw new TypeError(`expected number multiple of ${step} but got ${data}`)\n    }\n  }\n  return [data]\n})\n\nSchema.extend('boolean', (data) => {\n  if (typeof data === 'boolean') return [data]\n  throw new TypeError(`expected boolean but got ${data}`)\n})\n\nSchema.extend('bitset', (data, { bits }) => {\n  if (typeof data === 'number') return [data]\n  if (!Array.isArray(data)) throw new TypeError(`expected array but got ${data}`)\n  let result = 0\n  for (const value of data) {\n    if (typeof value !== 'string') throw new TypeError(`expected string but got ${value}`)\n    if (!(value in bits!)) throw new TypeError(`unknown value ${value}`)\n    result |= bits![value]!\n  }\n  return [result, result]\n})\n\nSchema.extend('function', (data) => {\n  if (typeof data === 'function') return [data]\n  throw new TypeError(`expected function but got ${data}`)\n})\n\nSchema.extend('is', (data, { callback }) => {\n  if (data instanceof callback!) return [data]\n  throw new TypeError(`expected ${callback!.name} but got ${data}`)\n})\n\nfunction property(data: any, key: keyof any, schema: Schema) {\n  const [value, adapted] = Schema.resolve(data[key], schema)\n  if (!isNullable(adapted)) data[key] = adapted\n  return value\n}\n\nSchema.extend('array', (data, { inner, meta }) => {\n  if (!Array.isArray(data)) throw new TypeError(`expected array but got ${data}`)\n  checkWithinRange(data.length, meta, 'array length')\n  return [data.map((_, index) => property(data, index, inner!))]\n})\n\nSchema.extend('dict', (data, { inner, sKey }, strict) => {\n  if (!isPlainObject(data)) throw new TypeError(`expected object but got ${data}`)\n  const result: any = {}\n  for (const key in data) {\n    let rKey: string\n    try {\n      rKey = Schema.resolve(key, sKey!)[0]\n    } catch (error) {\n      if (strict) continue\n      throw error\n    }\n    result[rKey] = property(data, key, inner!)\n    data[rKey] = data[key]\n    if (key !== rKey) delete data[key]\n  }\n  return [result]\n})\n\nSchema.extend('tuple', (data, { list }, strict) => {\n  if (!Array.isArray(data)) throw new TypeError(`expected array but got ${data}`)\n  const result = list!.map((inner, index) => property(data, index, inner))\n  if (strict) return [result]\n  result.push(...data.slice(list!.length))\n  return [result]\n})\n\nfunction merge(result: any, data: any) {\n  for (const key in data) {\n    if (key in result) continue\n    result[key] = data[key]\n  }\n}\n\nSchema.extend('object', (data, { dict }, strict) => {\n  if (!isPlainObject(data)) throw new TypeError(`expected object but got ${data}`)\n  const result: any = {}\n  for (const key in dict) {\n    const value = property(data, key, dict![key]!)\n    if (!isNullable(value) || key in data) {\n      result[key] = value\n    }\n  }\n  if (!strict) merge(result, data)\n  return [result]\n})\n\nSchema.extend('union', (data, { list, toString }) => {\n  const messages: string[] = []\n  for (const inner of list!) {\n    try {\n      return Schema.resolve(data, inner)\n    } catch (error) {\n      // messages.push(error.message)\n    }\n  }\n  throw new TypeError(`expected ${toString()} but got ${JSON.stringify(data)}`)\n})\n\nSchema.extend('intersect', (data, { list, toString }, strict) => {\n  let result\n  for (const inner of list!) {\n    const value = Schema.resolve(data, inner, true)[0]\n    if (isNullable(value)) continue\n    if (isNullable(result)) {\n      result = value\n    } else if (typeof result !== typeof value) {\n      throw new TypeError(`expected ${toString()} but got ${JSON.stringify(data)}`)\n    } else if (typeof value === 'object') {\n      result = { ...result as any, ...value }\n    } else if (result !== value) {\n      throw new TypeError(`expected ${toString()} but got ${JSON.stringify(data)}`)\n    }\n  }\n  if (!strict && isPlainObject(data)) merge(result, data)\n  return [result]\n})\n\nSchema.extend('transform', (data, { inner, callback }) => {\n  const [result, adapted = data] = Schema.resolve(data, inner!, true)\n  if (isPlainObject(data)) {\n    const temp: any = {}\n    for (const key in result) {\n      if (!(key in data)) continue\n      temp[key] = data[key]\n      delete data[key]\n    }\n    Object.assign(data, callback!(temp))\n    return [callback!(result)]\n  } else {\n    return [callback!(result), callback!(adapted)]\n  }\n})\n\ntype Formatter = (schema: Schema, inline?: boolean) => string\n\nfunction defineMethod(name: string, keys: (keyof Schema.Base)[], format: Formatter) {\n  Object.assign(Schema, {\n    [name](...args: any[]) {\n      const schema = new Schema({ type: name } as Schema.Base)\n      schema.toString = format.bind(null, schema)\n      keys.forEach((key, index) => {\n        switch (key) {\n          case 'sKey': schema.sKey = args[index] ?? Schema.string(); break\n          case 'inner': schema.inner = Schema.from(args[index]); break\n          case 'list': schema.list = args[index].map(Schema.from); break\n          case 'dict': schema.dict = valueMap(args[index], Schema.from); break\n          case 'bits': {\n            schema.bits = {}\n            for (const key in args[index]) {\n              if (typeof args[index][key] !== 'number') continue\n              schema.bits[key] = args[index][key]\n            }\n            break\n          }\n          default: schema[key] = args[index] as never\n        }\n      })\n      if (name === 'object' || name === 'dict') {\n        schema.meta.default = {}\n      } else if (name === 'array' || name === 'tuple') {\n        schema.meta.default = []\n      } else if (name === 'bitset') {\n        schema.meta.default = 0\n      }\n      return schema\n    },\n  })\n}\n\ndefineMethod('is', ['callback'], ({ callback }) => callback!.name)\ndefineMethod('any', [], () => 'any')\ndefineMethod('never', [], () => 'never')\ndefineMethod('const', ['value'], ({ value }) => typeof value === 'string' ? JSON.stringify(value) : value)\ndefineMethod('string', [], () => 'string')\ndefineMethod('number', [], () => 'number')\ndefineMethod('boolean', [], () => 'boolean')\ndefineMethod('bitset', ['bits'], () => 'bitset')\ndefineMethod('function', [], () => 'function')\ndefineMethod('array', ['inner'], ({ inner }) => `${inner!.toString(true)}[]`)\ndefineMethod('dict', ['inner', 'sKey'], ({ inner, sKey }) => `{ [key: ${sKey!.toString()}]: ${inner!.toString()} }`)\ndefineMethod('tuple', ['list'], ({ list }) => `[${list!.map((inner) => inner.toString()).join(', ')}]`)\n\ndefineMethod('object', ['dict'], ({ dict }) => {\n  if (Object.keys(dict!).length === 0) return '{}'\n  return `{ ${Object.entries(dict!).map(([key, inner]) => {\n    return `${key}${inner!.meta.required ? '' : '?'}: ${inner!.toString()}`\n  }).join(', ')} }`\n})\n\ndefineMethod('union', ['list'], ({ list }, inline) => {\n  const result = list!.map(({ toString: format }) => format()).join(' | ')\n  return inline ? `(${result})` : result\n})\n\ndefineMethod('intersect', ['list'], ({ list }) => {\n  return `${list!.map((inner) => inner.toString(true)).join(' & ')}`\n})\n\ndefineMethod('transform', ['inner', 'callback'], ({ inner }, isInner) => inner!.toString(isInner))\n\nexport = Schema\n"],
  "mappings": "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",
  "names": ["refs", "options", "pattern", "resolve", "index", "key"]
}
