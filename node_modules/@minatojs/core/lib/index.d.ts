import { Intersect, Extract, Dict, MaybeArray } from 'cosmokit';
export type Values<S> = S[keyof S];
export type Keys<O, T = any> = Values<{
    [K in keyof O]: O[K] extends T ? K : never;
}> & string;
export type Atomic = number | string | boolean | bigint | symbol | Date;
export type Indexable = string | number;
export type Comparable = string | number | boolean | Date;
type FlatWrap<S, T, P extends string> = {
    [K in P]?: S;
} | (S extends Atomic | T ? never : S extends any[] ? never : string extends keyof S ? never : FlatMap<S, T, `${P}.`>);
type FlatMap<S, T = never, P extends string = ''> = Values<{
    [K in keyof S & string as `${P}${K}`]: FlatWrap<S[K], S | T, `${P}${K}`>;
}>;
export type Flatten<S> = Intersect<FlatMap<S>>;
export function isComparable(value: any): value is Comparable;
export function randomId(): string;
export function isEvalExpr(value: any): value is Eval.Expr;
type $Date = Date;
export type Uneval<U> = U extends number ? Eval.Number : U extends string ? Eval.String : U extends boolean ? Eval.Boolean : U extends $Date ? Eval.Date : any;
export type Eval<U> = U extends Comparable ? U : U extends Eval.Expr<infer T> ? T : never;
declare const kExpr: unique symbol;
declare const kType: unique symbol;
export namespace Eval {
    interface Expr<T = any> {
        [kExpr]: true;
        [kType]?: T;
    }
    type Number = number | Expr<number>;
    type String = string | Expr<string>;
    type Boolean = boolean | Expr<boolean>;
    type Date = $Date | Expr<$Date>;
    type Any = Comparable | Expr;
    interface Comparator {
        (x: Number, y: Number): Expr<boolean>;
        (x: String, y: String): Expr<boolean>;
        (x: Date, y: Date): Expr<boolean>;
    }
    interface Static {
        (key: string, value: any): Eval.Expr;
        if<T extends Comparable>(cond: Any, vThen: T | Expr<T>, vElse: T | Expr<T>): Expr<T>;
        ifNull<T extends Comparable>(...args: (T | Expr<T>)[]): Expr<T>;
        add(...args: Number[]): Expr<number>;
        multiply(...args: Number[]): Expr<number>;
        subtract(x: Number, y: Number): Expr<number>;
        divide(x: Number, y: Number): Expr<number>;
        eq(x: Any, y: Any): Expr<boolean>;
        ne(x: Any, y: Any): Expr<boolean>;
        gt: Comparator;
        gte: Comparator;
        lt: Comparator;
        lte: Comparator;
        concat(...args: String[]): Expr<string>;
        and(...args: Boolean[]): Expr<boolean>;
        or(...args: Boolean[]): Expr<boolean>;
        not(value: Boolean): Expr<boolean>;
        sum(value: Number): Expr<number>;
        avg(value: Number): Expr<number>;
        max(value: Number): Expr<number>;
        min(value: Number): Expr<number>;
        count(value: Any): Expr<number>;
    }
}
export const Eval: Eval.Static;
export { Eval as $ };
type MapUneval<S> = {
    [K in keyof S]?: Uneval<S[K]>;
};
export type Update<T = any> = MapUneval<Flatten<T>>;
export function executeEval(data: any, expr: any): any;
export function executeUpdate(data: any, update: any, ref: string): any;
export type Query<T = any> = Query.Expr<T> | Query.Shorthand<Indexable> | Selection.Callback<T, boolean>;
export namespace Query {
    interface FieldExpr<T = any> {
        $or?: FieldQuery<T>[];
        $and?: FieldQuery<T>[];
        $not?: FieldQuery<T>;
        $exists?: boolean;
        $in?: Extract<T, Indexable, T[]>;
        $nin?: Extract<T, Indexable, T[]>;
        $eq?: Extract<T, Comparable>;
        $ne?: Extract<T, Comparable>;
        $gt?: Extract<T, Comparable>;
        $gte?: Extract<T, Comparable>;
        $lt?: Extract<T, Comparable>;
        $lte?: Extract<T, Comparable>;
        $el?: T extends (infer U)[] ? FieldQuery<U> : never;
        $size?: Extract<T, any[], number>;
        $regex?: Extract<T, string, RegExp>;
        $regexFor?: Extract<T, string>;
        $bitsAllClear?: Extract<T, number>;
        $bitsAllSet?: Extract<T, number>;
        $bitsAnyClear?: Extract<T, number>;
        $bitsAnySet?: Extract<T, number>;
    }
    interface LogicalExpr<T = any> {
        $or?: Expr<T>[];
        $and?: Expr<T>[];
        $not?: Expr<T>;
        /** @deprecated use query callback instead */
        $expr?: Eval.Expr<boolean>;
    }
    type Shorthand<T = any> = Extract<T, Comparable> | Extract<T, Indexable, T[]> | Extract<T, string, RegExp>;
    type FieldQuery<T = any> = FieldExpr<T> | Shorthand<T>;
    type Expr<T = any> = LogicalExpr<T> & {
        [K in keyof T]?: null | FieldQuery<T[K]>;
    };
}
export function executeQuery(data: any, query: Query.Expr, ref: string): boolean;
export type Direction = 'asc' | 'desc';
export interface Modifier {
    limit: number;
    offset: number;
    sort: [Eval.Expr, Direction][];
    group: string[];
    having: Eval.Expr<boolean>;
    fields?: Dict<Eval.Expr>;
}
declare namespace Executable {
    type Action = 'get' | 'set' | 'remove' | 'create' | 'upsert' | 'eval';
    interface Payload {
        type: Action;
        table: string | Selection;
        ref: string;
        query: Query.Expr;
        args: any[];
    }
}
export interface Executable extends Executable.Payload {
}
declare class Executable<S = any, T = any> {
    readonly row: Selection.Row<S>;
    readonly model: Model;
    readonly driver: Driver;
    constructor(driver: Driver, payload: Executable.Payload);
    protected resolveQuery(query?: Query<S>): Query.Expr<S>;
    protected resolveField(field: Selection.Field<S>): Eval.Expr;
    protected resolveFields(fields: string | string[] | Dict): any;
    execute(): Promise<T>;
}
export namespace Selection {
    type Callback<S = any, T = any> = (row: Row<S>) => Eval.Expr<T>;
    type Field<S = any> = Keys<S> | Callback<S>;
    type Take<S, F extends Field<S>> = F extends Keys<S> ? S[F] : F extends Callback<S> ? Eval<ReturnType<F>> : never;
    type Value<T> = Eval.Expr<T> & (T extends Comparable ? {} : Row<T>);
    type Row<S> = {
        [K in keyof S]-?: Value<NonNullable<S[K]>>;
    };
    type Yield<S, T> = T | ((row: Row<S>) => T);
    type Project<S, T extends Dict<Field<S>>> = {
        [K in keyof T]: Take<S, T[K]>;
    };
    type Selector<S> = Keys<S>;
    type Resolve<S, T> = T extends Keys<S> ? S[T] : never;
    interface Immutable extends Executable, Executable.Payload {
        tables: Dict<Model>;
    }
    interface Mutable extends Executable, Executable.Payload {
        table: string;
    }
}
export interface Selection extends Executable.Payload {
    args: [Modifier];
}
export class Selection<S = any> extends Executable<S, S[]> {
    tables: Dict<Model>;
    constructor(driver: Driver, table: string | Selection, query?: Query);
    where(query: Query): this;
    limit(limit: number): this;
    limit(offset: number, limit: number): this;
    offset(offset: number): this;
    orderBy(field: Selection.Field<S>, direction?: Direction): this;
    groupBy<T extends Keys<S>>(fields: T | T[], cond?: Selection.Callback<S, boolean>): Selection<Pick<S, T>>;
    groupBy<T extends Keys<S>, U extends Dict<Selection.Field<S>>>(fields: T | T[], extra?: U, cond?: Selection.Callback<S, boolean>): Selection<Pick<S, T> & Selection.Project<S, U>>;
    groupBy<T extends Dict<Selection.Field<S>>>(fields: T, cond?: Selection.Callback<S, boolean>): Selection<Selection.Project<S, T>>;
    groupBy<T extends Dict<Selection.Field<S>>, U extends Dict<Selection.Field<S>>>(fields: T, extra?: U, cond?: Selection.Callback<S, boolean>): Selection<Selection.Project<S, T & U>>;
    having(cond: Selection.Callback<S, boolean>): this;
    project<T extends Keys<S>>(fields: T | T[]): Selection<Pick<S, T>>;
    project<T extends Dict<Selection.Field<S>>>(fields: T): Selection<Selection.Project<S, T>>;
    _action(type: Executable.Action, ...args: any[]): Executable<any, any>;
    /** @deprecated use `selection.execute()` instead */
    evaluate<T>(callback: Selection.Callback<S, T>): Executable;
    execute(): Promise<S[]>;
    execute<T>(callback: Selection.Callback<S, T>): Promise<T>;
}
export function executeSort(data: any[], modifier: Modifier, name: string): any[];
export interface Field<T = any> {
    type: Field.Type<T>;
    length?: number;
    nullable?: boolean;
    initial?: T;
    precision?: number;
    scale?: number;
    expr?: Selection.Callback;
    legacy?: string[];
}
export namespace Field {
    export const number: Type[];
    export const string: Type[];
    export const boolean: Type[];
    export const date: Type[];
    export const object: Type[];
    export type Type<T = any> = T extends number ? 'integer' | 'unsigned' | 'float' | 'double' | 'decimal' : T extends string ? 'char' | 'string' | 'text' : T extends boolean ? 'boolean' : T extends Date ? 'timestamp' | 'date' | 'time' : T extends unknown[] ? 'list' | 'json' : T extends object ? 'json' : 'expr';
    type Shorthand<S extends string> = S | `${S}(${any})`;
    type MapField<O = any> = {
        [K in keyof O]?: Field<O[K]> | Shorthand<Type<O[K]>> | Selection.Callback<O, O[K]>;
    };
    export type Extension<O = any> = MapField<Flatten<O>>;
    export type Config<O = any> = {
        [K in keyof O]?: Field<O[K]>;
    };
    export function parse(source: string | Field): Field;
}
export namespace Model {
    interface Config<O = {}> {
        autoInc: boolean;
        primary: MaybeArray<Keys<O>>;
        unique: MaybeArray<Keys<O>>[];
        foreign: {
            [K in keyof O]?: [string, string];
        };
    }
}
export interface Model<S> extends Model.Config<S> {
}
export class Model<S = any> {
    name: string;
    fields: Field.Config<S>;
    constructor(name: string);
    extend(fields: Field.Extension<S>, config?: Partial<Model.Config<S>>): void;
    private checkIndex;
    resolveValue(key: string, value: any): any;
    format(source: object, strict?: boolean, prefix?: string, result?: S): S;
    parse(source: object): any;
    create(data?: {}): any;
}
export namespace Driver {
    interface Stats {
        size: number;
        tables: Dict<TableStats>;
    }
    interface TableStats {
        count: number;
        size: number;
    }
    type Cursor<K extends string = never> = K[] | CursorOptions<K>;
    interface CursorOptions<K> {
        limit?: number;
        offset?: number;
        fields?: K[];
        sort?: Dict<Direction>;
    }
}
export class Database<S = any> {
    tables: {
        [K in Keys<S>]: Model<S[K]>;
    };
    drivers: Record<keyof any, Driver>;
    private tasks;
    private stashed;
    refresh(): void;
    private getDriver;
    private prepare;
    extend<K extends Keys<S>>(name: K, fields: Field.Extension<S[K]>, config?: Partial<Model.Config<S[K]>>): void;
    select<T extends Selection.Selector<S>>(table: T, query?: Query<Selection.Resolve<S, T>>): Selection<Selection.Resolve<S, T>>;
    get<T extends Keys<S>, K extends Keys<S[T]>>(table: T, query: Query<Selection.Resolve<S, T>>, cursor?: Driver.Cursor<K>): Promise<Pick<S[T], K>[]>;
    eval<K extends Keys<S>, T>(table: K, expr: Selection.Callback<S[K], T>, query?: Query<Selection.Resolve<S, K>>): Promise<T>;
    set<T extends Keys<S>>(table: T, query: Query<Selection.Resolve<S, T>>, update: Selection.Yield<S[T], Update<S[T]>>): Promise<void>;
    remove<T extends Keys<S>>(table: T, query: Query<Selection.Resolve<S, T>>): Promise<void>;
    create<T extends Keys<S>>(table: T, data: Partial<S[T]>): Promise<S[T]>;
    upsert<T extends Keys<S>>(table: T, upsert: Selection.Yield<S[T], Update<S[T]>[]>, keys?: MaybeArray<Keys<Flatten<S[T]>, Indexable>>): Promise<void>;
    stopAll(): Promise<void>;
    dropAll(): Promise<void>;
    stats(): Promise<Driver.Stats>;
}
export namespace Driver {
    type Constructor<T = any> = new (database: Database, config?: T) => Driver;
}
export abstract class Driver {
    database: Database;
    abstract start(): Promise<void>;
    abstract stop(): Promise<void>;
    abstract drop(): Promise<void>;
    abstract stats(): Promise<Partial<Driver.Stats>>;
    abstract prepare(name: string): Promise<void>;
    abstract get(sel: Selection.Immutable, modifier: Modifier): Promise<any>;
    abstract eval(sel: Selection.Immutable, expr: Eval.Expr): Promise<any>;
    abstract set(sel: Selection.Mutable, data: Update): Promise<void>;
    abstract remove(sel: Selection.Mutable): Promise<void>;
    abstract create(sel: Selection.Mutable, data: any): Promise<any>;
    abstract upsert(sel: Selection.Mutable, data: any[], keys: string[]): Promise<void>;
    constructor(database: Database);
    model<S = any>(table: string | Selection<S>): Model<S>;
}
export namespace RuntimeError {
    type Code = 'duplicate-entry' | 'unsupported-expression';
}
export class RuntimeError<T extends RuntimeError.Code> extends Error {
    code: T;
    name: string;
    constructor(code: T, message?: string);
    static check<T extends RuntimeError.Code>(error: any, code?: RuntimeError.Code): error is RuntimeError<T>;
}
