"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// minato/packages/core/src/index.ts
var src_exports = {};
__export(src_exports, {
  $: () => Eval,
  Database: () => Database,
  Driver: () => Driver,
  Eval: () => Eval,
  Field: () => Field,
  Model: () => Model,
  RuntimeError: () => RuntimeError,
  Selection: () => Selection,
  executeEval: () => executeEval,
  executeQuery: () => executeQuery,
  executeSort: () => executeSort,
  executeUpdate: () => executeUpdate,
  isComparable: () => isComparable,
  isEvalExpr: () => isEvalExpr,
  randomId: () => randomId
});
module.exports = __toCommonJS(src_exports);

// minato/packages/core/src/driver.ts
var import_cosmokit4 = require("cosmokit");

// minato/packages/core/src/model.ts
var import_cosmokit2 = require("cosmokit");

// minato/packages/core/src/eval.ts
var import_cosmokit = require("cosmokit");

// minato/packages/core/src/utils.ts
function isComparable(value) {
  return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || value instanceof Date;
}
__name(isComparable, "isComparable");
var letters = "abcdefghijklmnopqrstuvwxyz";
function randomId() {
  return Array(8).fill(0).map(() => letters[Math.floor(Math.random() * letters.length)]).join("");
}
__name(randomId, "randomId");

// minato/packages/core/src/eval.ts
function isEvalExpr(value) {
  return value && Object.keys(value).some((key) => key.startsWith("$"));
}
__name(isEvalExpr, "isEvalExpr");
var kExpr = Symbol("expr");
var kType = Symbol("type");
var Eval = /* @__PURE__ */ __name((key, value) => (0, import_cosmokit.defineProperty)({ ["$" + key]: value }, kExpr, true), "Eval");
var operators = {};
operators["$"] = getRecursive;
function unary(key, callback) {
  operators[`$${key}`] = callback;
  return (value) => Eval(key, value);
}
__name(unary, "unary");
function multary(key, callback) {
  operators[`$${key}`] = callback;
  return (...args) => Eval(key, args);
}
__name(multary, "multary");
Eval.if = multary("if", ([cond, vThen, vElse], data) => executeEval(data, cond) ? executeEval(data, vThen) : executeEval(data, vElse));
Eval.ifNull = multary("ifNull", ([value, fallback], data) => {
  var _a;
  return (_a = executeEval(data, value)) != null ? _a : executeEval(data, fallback);
});
Eval.add = multary("add", (args, data) => args.reduce((prev, curr) => prev + executeEval(data, curr), 0));
Eval.multiply = multary("multiply", (args, data) => args.reduce((prev, curr) => prev * executeEval(data, curr), 1));
Eval.subtract = multary("subtract", ([left, right], data) => executeEval(data, left) - executeEval(data, right));
Eval.divide = multary("divide", ([left, right], data) => executeEval(data, left) / executeEval(data, right));
Eval.eq = multary("eq", ([left, right], data) => executeEval(data, left).valueOf() === executeEval(data, right).valueOf());
Eval.ne = multary("ne", ([left, right], data) => executeEval(data, left).valueOf() !== executeEval(data, right).valueOf());
Eval.gt = multary("gt", ([left, right], data) => executeEval(data, left).valueOf() > executeEval(data, right).valueOf());
Eval.gte = multary("gte", ([left, right], data) => executeEval(data, left).valueOf() >= executeEval(data, right).valueOf());
Eval.lt = multary("lt", ([left, right], data) => executeEval(data, left).valueOf() < executeEval(data, right).valueOf());
Eval.lte = multary("lte", ([left, right], data) => executeEval(data, left).valueOf() <= executeEval(data, right).valueOf());
Eval.concat = multary("concat", (args, data) => args.map((arg) => executeEval(data, arg)).join(""));
Eval.and = multary("and", (args, data) => args.every((arg) => executeEval(data, arg)));
Eval.or = multary("or", (args, data) => args.some((arg) => executeEval(data, arg)));
Eval.not = unary("not", (value, data) => !executeEval(data, value));
Eval.sum = unary("sum", (expr, table) => table.reduce((prev, curr) => prev + executeAggr(expr, curr), 0));
Eval.avg = unary("avg", (expr, table) => table.reduce((prev, curr) => prev + executeAggr(expr, curr), 0) / table.length);
Eval.max = unary("max", (expr, table) => Math.max(...table.map((data) => executeAggr(expr, data))));
Eval.min = unary("min", (expr, table) => Math.min(...table.map((data) => executeAggr(expr, data))));
Eval.count = unary("count", (expr, table) => new Set(table.map((data) => executeAggr(expr, data))).size);
function getRecursive(args, data) {
  if (typeof args === "string") {
    return getRecursive(["_", args], data);
  }
  const [ref, path] = args;
  let value = data[ref];
  if (!value)
    return value;
  if (path in value)
    return value[path];
  const prefix = Object.keys(value).find((s) => path.startsWith(s + ".")) || path.split(".", 1)[0];
  const rest = path.slice(prefix.length + 1).split(".").filter(Boolean);
  rest.unshift(prefix);
  for (const key of rest) {
    value = value[key];
    if (!value)
      return value;
  }
  return value;
}
__name(getRecursive, "getRecursive");
function executeEvalExpr(expr, data) {
  for (const key in expr) {
    if (key in operators) {
      return operators[key](expr[key], data);
    }
  }
  return expr;
}
__name(executeEvalExpr, "executeEvalExpr");
function executeAggr(expr, data) {
  if (typeof expr === "string") {
    return getRecursive(expr, data);
  }
  return executeEvalExpr(expr, data);
}
__name(executeAggr, "executeAggr");
function executeEval(data, expr) {
  if (isComparable(expr) || (0, import_cosmokit.isNullable)(expr)) {
    return expr;
  }
  return executeEvalExpr(expr, data);
}
__name(executeEval, "executeEval");
function executeUpdate(data, update, ref) {
  for (const key in update) {
    let root = data;
    const path = key.split(".");
    const last = path.pop();
    for (const key2 of path) {
      root = root[key2] || (root[key2] = {});
    }
    root[last] = executeEval({ [ref]: data, _: data }, update[key]);
  }
  return data;
}
__name(executeUpdate, "executeUpdate");

// minato/packages/core/src/model.ts
var Field;
((Field3) => {
  Field3.number = ["integer", "unsigned", "float", "double", "decimal"];
  Field3.string = ["char", "string", "text"];
  Field3.boolean = ["boolean"];
  Field3.date = ["timestamp", "date", "time"];
  Field3.object = ["list", "json"];
  const regexp = /^(\w+)(?:\((.+)\))?$/;
  function parse(source) {
    if (typeof source === "function")
      return { type: "expr", expr: source };
    if (typeof source !== "string")
      return { initial: null, ...source };
    const capture = regexp.exec(source);
    if (!capture)
      throw new TypeError("invalid field definition");
    const type = capture[1];
    const args = (capture[2] || "").split(",");
    const field = { type };
    if (field.initial === void 0) {
      if (Field3.number.includes(field.type))
        field.initial = 0;
      if (Field3.string.includes(field.type))
        field.initial = "";
      if (field.type === "list")
        field.initial = [];
      if (field.type === "json")
        field.initial = {};
    }
    if (type === "decimal") {
      field.precision = +args[0];
      field.scale = +args[1];
    } else if (args[0]) {
      field.length = +args[0];
    }
    return field;
  }
  Field3.parse = parse;
  __name(parse, "parse");
})(Field || (Field = {}));
var Model = class {
  constructor(name) {
    this.name = name;
    this.fields = {};
    this.autoInc = false;
    this.primary = "id";
    this.unique = [];
    this.foreign = {};
  }
  extend(fields = {}, config = {}) {
    const { primary, autoInc, unique = [], foreign } = config;
    this.primary = primary || this.primary;
    this.autoInc = autoInc || this.autoInc;
    this.unique.push(...unique);
    Object.assign(this.foreign, foreign);
    for (const key in fields) {
      this.fields[key] = Field.parse(fields[key]);
    }
    this.checkIndex(this.primary);
    this.unique.forEach((index) => this.checkIndex(index));
  }
  checkIndex(index) {
    for (const key of (0, import_cosmokit2.makeArray)(index)) {
      if (!this.fields[key]) {
        throw new TypeError(`missing field definition for index key "${key}"`);
      }
    }
  }
  resolveValue(key, value) {
    var _a;
    if ((0, import_cosmokit2.isNullable)(value))
      return value;
    if (((_a = this.fields[key]) == null ? void 0 : _a.type) === "time") {
      const date = new Date(0);
      date.setHours(value.getHours(), value.getMinutes(), value.getSeconds(), value.getMilliseconds());
      return date;
    }
    return value;
  }
  format(source, strict = true, prefix = "", result = {}) {
    const fields = Object.keys(this.fields);
    Object.entries(source).map(([key, value]) => {
      key = prefix + key;
      if (fields.includes(key)) {
        result[key] = value;
      } else if (!value || typeof value !== "object" || isEvalExpr(value)) {
        const field = fields.find((field2) => key.startsWith(field2 + "."));
        if (field) {
          result[key] = value;
        } else if (strict) {
          throw new TypeError(`unknown field "${key}" in model ${this.name}`);
        }
      } else {
        this.format(value, strict, key + ".", result);
      }
    });
    return result;
  }
  parse(source) {
    var _a;
    const result = {};
    for (const key in source) {
      let node = result;
      const segments = key.split(".").reverse();
      let prefix = "";
      for (let index = segments.length - 1; index > 0; index--) {
        const segment = segments[index];
        prefix += segment + ".";
        node = (_a = node[segment]) != null ? _a : node[segment] = {};
      }
      if (key in source) {
        const value = this.resolveValue(key, source[key]);
        node[segments[0]] = value;
      }
    }
    return result;
  }
  create(data) {
    const result = {};
    const keys = (0, import_cosmokit2.makeArray)(this.primary);
    for (const key in this.fields) {
      const { initial } = this.fields[key];
      if (!keys.includes(key) && !(0, import_cosmokit2.isNullable)(initial)) {
        result[key] = (0, import_cosmokit2.clone)(initial);
      }
    }
    return this.parse({ ...result, ...data });
  }
};
__name(Model, "Model");

// minato/packages/core/src/selection.ts
var import_cosmokit3 = require("cosmokit");
var createRow = /* @__PURE__ */ __name((ref, prefix = "", expr = {}) => new Proxy(expr, {
  get(target, key) {
    if (typeof key === "symbol" || key.startsWith("$"))
      return Reflect.get(target, key);
    return createRow(ref, `${prefix}${key}.`, Eval("", [ref, `${prefix}${key}`]));
  }
}), "createRow");
var Executable = class {
  constructor(driver, payload) {
    Object.assign(this, payload);
    (0, import_cosmokit3.defineProperty)(this, "driver", driver);
    (0, import_cosmokit3.defineProperty)(this, "row", createRow(this.ref));
    (0, import_cosmokit3.defineProperty)(this, "model", driver.model(this.table));
  }
  resolveQuery(query = {}) {
    if (typeof query === "function")
      return { $expr: query(this.row) };
    if (Array.isArray(query) || query instanceof RegExp || ["string", "number"].includes(typeof query)) {
      const { primary } = this.model;
      if (Array.isArray(primary)) {
        throw new TypeError("invalid shorthand for composite primary key");
      }
      return { [primary]: query };
    }
    return query;
  }
  resolveField(field) {
    if (typeof field === "string") {
      return this.row[field];
    } else if (typeof field === "function") {
      return field(this.row);
    } else {
      throw new TypeError("invalid field definition");
    }
  }
  resolveFields(fields) {
    if (typeof fields === "string")
      fields = [fields];
    if (Array.isArray(fields)) {
      const modelFields = Object.keys(this.model.fields);
      const keys = fields.flatMap((key) => {
        if (this.model.fields[key])
          return key;
        return modelFields.filter((path) => path.startsWith(key + "."));
      });
      return Object.fromEntries(keys.map((key) => [key, this.row[key]]));
    } else {
      return (0, import_cosmokit3.valueMap)(fields, (field) => this.resolveField(field));
    }
  }
  execute() {
    return this.driver[this.type](this, ...this.args);
  }
};
__name(Executable, "Executable");
var Selection = class extends Executable {
  constructor(driver, table, query) {
    super(driver, {
      type: "get",
      ref: randomId(),
      table,
      query: null,
      args: [{ sort: [], limit: Infinity, offset: 0, group: [], having: Eval.and() }]
    });
    this.tables = {};
    this.tables[this.ref] = this.model;
    this.query = this.resolveQuery(query);
    if (typeof table !== "string") {
      Object.assign(this.tables, table.tables);
    }
  }
  where(query) {
    var _a;
    (_a = this.query).$and || (_a.$and = []);
    this.query.$and.push(this.resolveQuery(query));
    return this;
  }
  limit(...args) {
    if (args.length > 1)
      this.offset(args.shift());
    this.args[0].limit = args[0];
    return this;
  }
  offset(offset) {
    this.args[0].offset = offset;
    return this;
  }
  orderBy(field, direction = "asc") {
    this.args[0].sort.push([this.resolveField(field), direction]);
    return this;
  }
  groupBy(fields, ...args) {
    this.args[0].fields = this.resolveFields(fields);
    this.args[0].group = Object.keys(this.args[0].fields);
    const extra = typeof args[0] === "function" ? void 0 : args.shift();
    Object.assign(this.args[0].fields, this.resolveFields(extra || {}));
    if (args[0])
      this.having(args[0]);
    return new Selection(this.driver, this);
  }
  having(cond) {
    this.args[0].having["$and"].push(this.resolveField(cond));
    return this;
  }
  project(fields) {
    this.args[0].fields = this.resolveFields(fields);
    return new Selection(this.driver, this);
  }
  _action(type, ...args) {
    return new Executable(this.driver, { ...this, type, args });
  }
  evaluate(callback) {
    return new Selection(this.driver, this)._action("eval", this.resolveField(callback));
  }
  execute(callback) {
    if (!callback)
      return super.execute();
    return new Selection(this.driver, this)._action("eval", this.resolveField(callback)).execute();
  }
};
__name(Selection, "Selection");
function executeSort(data, modifier, name) {
  const { limit, offset, sort } = modifier;
  data.sort((a, b) => {
    for (const [field, direction] of sort) {
      const sign = direction === "asc" ? 1 : -1;
      const x = executeEval({ [name]: a, _: a }, field);
      const y = executeEval({ [name]: b, _: b }, field);
      if (x < y)
        return -sign;
      if (x > y)
        return sign;
    }
    return 0;
  });
  return data.slice(offset, offset + limit);
}
__name(executeSort, "executeSort");

// minato/packages/core/src/driver.ts
var Database = class {
  constructor() {
    this.tables = /* @__PURE__ */ Object.create(null);
    this.drivers = /* @__PURE__ */ Object.create(null);
    this.tasks = /* @__PURE__ */ Object.create(null);
    this.stashed = /* @__PURE__ */ new Set();
  }
  refresh() {
    for (const name in this.tables) {
      this.tasks[name] = this.prepare(name);
    }
  }
  getDriver(name) {
    return Object.values(this.drivers)[0];
  }
  async prepare(name) {
    this.stashed.add(name);
    await this.tasks[name];
    return new Promise(async (resolve) => {
      Promise.resolve().then(async () => {
        var _a;
        if (this.stashed.delete(name)) {
          await ((_a = this.getDriver(name)) == null ? void 0 : _a.prepare(name));
        }
        resolve();
      });
    });
  }
  extend(name, fields, config = {}) {
    let model = this.tables[name];
    if (!model) {
      model = this.tables[name] = new Model(name);
    }
    model.extend(fields, config);
    this.tasks[name] = this.prepare(name);
  }
  select(table, query) {
    return new Selection(this.getDriver(table), table, query);
  }
  async get(table, query, cursor) {
    await this.tasks[table];
    if (Array.isArray(cursor)) {
      cursor = { fields: cursor };
    } else if (!cursor) {
      cursor = {};
    }
    const selection = this.select(table, query);
    if (cursor.fields)
      selection.project(cursor.fields);
    if (cursor.limit !== void 0)
      selection.limit(cursor.limit);
    if (cursor.offset !== void 0)
      selection.offset(cursor.offset);
    if (cursor.sort) {
      for (const field in cursor.sort) {
        selection.orderBy(field, cursor.sort[field]);
      }
    }
    return selection.execute();
  }
  async eval(table, expr, query) {
    await this.tasks[table];
    return this.select(table, query).execute(typeof expr === "function" ? expr : () => expr);
  }
  async set(table, query, update) {
    await this.tasks[table];
    const sel = this.select(table, query);
    if (typeof update === "function")
      update = update(sel.row);
    const primary = (0, import_cosmokit4.makeArray)(sel.model.primary);
    if (primary.some((key) => key in update)) {
      throw new TypeError(`cannot modify primary key`);
    }
    await sel._action("set", sel.model.format(update)).execute();
  }
  async remove(table, query) {
    await this.tasks[table];
    const sel = this.select(table, query);
    await sel._action("remove").execute();
  }
  async create(table, data) {
    await this.tasks[table];
    const sel = this.select(table);
    return sel._action("create", sel.model.create(data)).execute();
  }
  async upsert(table, upsert, keys) {
    await this.tasks[table];
    const sel = this.select(table);
    if (typeof upsert === "function")
      upsert = upsert(sel.row);
    upsert = upsert.map((item) => sel.model.format(item));
    keys = (0, import_cosmokit4.makeArray)(keys || sel.model.primary);
    await sel._action("upsert", upsert, keys).execute();
  }
  async stopAll() {
    const drivers = Object.values(this.drivers);
    this.drivers = /* @__PURE__ */ Object.create(null);
    await Promise.all(drivers.map((driver) => driver.stop()));
  }
  async dropAll() {
    await Promise.all(Object.values(this.drivers).map((driver) => driver.drop()));
  }
  async stats() {
    const stats = { size: 0, tables: {} };
    await Promise.all(Object.values(this.drivers).map(async (driver) => {
      const { size = 0, tables } = await driver.stats();
      stats.size += size;
      Object.assign(stats.tables, tables);
    }));
    return stats;
  }
};
__name(Database, "Database");
var Driver = class {
  constructor(database) {
    this.database = database;
  }
  model(table) {
    if (typeof table === "string") {
      const model2 = this.database.tables[table];
      if (model2)
        return model2;
      throw new TypeError(`unknown table name "${table}"`);
    }
    if (!table.args[0].fields)
      return table.model;
    const model = new Model("temp");
    model.fields = (0, import_cosmokit4.valueMap)(table.args[0].fields, () => ({
      type: "expr"
    }));
    return model;
  }
};
__name(Driver, "Driver");

// minato/packages/core/src/error.ts
var RuntimeError = class extends Error {
  constructor(code, message) {
    super(message || code.replace("-", " "));
    this.code = code;
    this.name = "RuntimeError";
  }
  static check(error, code) {
    if (!(error instanceof RuntimeError))
      return false;
    return !code || error.message === code;
  }
};
__name(RuntimeError, "RuntimeError");

// minato/packages/core/src/query.ts
var import_cosmokit5 = require("cosmokit");
var queryOperators = {
  $or: (query, data) => query.reduce((prev, query2) => prev || executeFieldQuery(query2, data), false),
  $and: (query, data) => query.reduce((prev, query2) => prev && executeFieldQuery(query2, data), true),
  $not: (query, data) => !executeFieldQuery(query, data),
  $exists: (query, data) => query !== (0, import_cosmokit5.isNullable)(data),
  $eq: (query, data) => data.valueOf() === query.valueOf(),
  $ne: (query, data) => data.valueOf() !== query.valueOf(),
  $gt: (query, data) => data.valueOf() > query.valueOf(),
  $gte: (query, data) => data.valueOf() >= query.valueOf(),
  $lt: (query, data) => data.valueOf() < query.valueOf(),
  $lte: (query, data) => data.valueOf() <= query.valueOf(),
  $in: (query, data) => query.includes(data),
  $nin: (query, data) => !query.includes(data),
  $regex: (query, data) => query.test(data),
  $regexFor: (query, data) => new RegExp(data, "i").test(query),
  $bitsAllSet: (query, data) => (query & data) === query,
  $bitsAllClear: (query, data) => (query & data) === 0,
  $bitsAnySet: (query, data) => (query & data) !== 0,
  $bitsAnyClear: (query, data) => (query & data) !== query,
  $el: (query, data) => data.some((item) => executeFieldQuery(query, item)),
  $size: (query, data) => data.length === query
};
function executeFieldQuery(query, data) {
  if (Array.isArray(query)) {
    return query.includes(data);
  } else if (query instanceof RegExp) {
    return query.test(data);
  } else if (isComparable(query)) {
    return data.valueOf() === query.valueOf();
  } else if ((0, import_cosmokit5.isNullable)(query)) {
    return (0, import_cosmokit5.isNullable)(data);
  }
  for (const key in query) {
    if (key in queryOperators) {
      if (!queryOperators[key](query[key], data))
        return false;
    }
  }
  return true;
}
__name(executeFieldQuery, "executeFieldQuery");
function executeQuery(data, query, ref) {
  const entries = Object.entries(query);
  return entries.every(([key, value]) => {
    if (key === "$and") {
      return value.reduce((prev, query2) => prev && executeQuery(data, query2, ref), true);
    } else if (key === "$or") {
      return value.reduce((prev, query2) => prev || executeQuery(data, query2, ref), false);
    } else if (key === "$not") {
      return !executeQuery(data, value, ref);
    } else if (key === "$expr") {
      return executeEval({ [ref]: data, _: data }, value);
    }
    try {
      return executeFieldQuery(value, data[key]);
    } catch {
      return false;
    }
  });
}
__name(executeQuery, "executeQuery");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  $,
  Database,
  Driver,
  Eval,
  Field,
  Model,
  RuntimeError,
  Selection,
  executeEval,
  executeQuery,
  executeSort,
  executeUpdate,
  isComparable,
  isEvalExpr,
  randomId
});
//# sourceMappingURL=index.cjs.map
