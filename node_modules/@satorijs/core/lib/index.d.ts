/// <reference types="ws" />
import * as cordis from 'cordis';
import segment, { Fragment, Render, escape, unescape } from '@satorijs/element';
import WebSocket from 'ws';
import { Awaitable, Dict } from 'cosmokit';
import Schema from 'schemastery';
import Logger from 'reggol';
import Quester from 'cordis-axios';
export namespace Universal {
    interface Methods {
        sendMessage(channelId: string, content: segment.Fragment, guildId?: string, options?: SendOptions): Promise<string[]>;
        sendPrivateMessage(userId: string, content: segment.Fragment, options?: SendOptions): Promise<string[]>;
        getMessage(channelId: string, messageId: string): Promise<Message>;
        getMessageList(channelId: string, before?: string): Promise<Message[]>;
        editMessage(channelId: string, messageId: string, content: segment.Fragment): Promise<void>;
        deleteMessage(channelId: string, messageId: string): Promise<void>;
        getSelf(): Promise<User>;
        getUser(userId: string): Promise<User>;
        getFriendList(): Promise<User[]>;
        deleteFriend(userId: string): Promise<void>;
        getGuild(guildId: string): Promise<Guild>;
        getGuildList(): Promise<Guild[]>;
        getGuildMember(guildId: string, userId: string): Promise<GuildMember>;
        getGuildMemberList(guildId: string): Promise<GuildMember[]>;
        kickGuildMember(guildId: string, userId: string, permanent?: boolean): Promise<void>;
        muteGuildMember(guildId: string, userId: string, duration: number, reason?: string): Promise<void>;
        getChannel(channelId: string, guildId?: string): Promise<Channel>;
        getChannelList(guildId: string): Promise<Channel[]>;
        muteChannel(channelId: string, guildId?: string, enable?: boolean): Promise<void>;
        handleFriendRequest(messageId: string, approve: boolean, comment?: string): Promise<void>;
        handleGuildRequest(messageId: string, approve: boolean, comment?: string): Promise<void>;
        handleGuildMemberRequest(messageId: string, approve: boolean, comment?: string): Promise<void>;
    }
    interface Channel {
        channelId: string;
        channelName?: string;
    }
    interface Guild {
        guildId: string;
        guildName?: string;
    }
    interface UserBase {
        username?: string;
        nickname?: string;
        avatar?: string;
        discriminator?: string;
        isBot?: boolean;
    }
    interface User extends UserBase {
        userId: string;
    }
    interface GuildMember extends User {
        roles?: string[];
    }
    interface Author extends GuildMember {
        anonymous?: string;
    }
    interface Role {
        id: string;
    }
    interface MessageBase {
        messageId?: string;
        channelId?: string;
        guildId?: string;
        userId?: string;
        content?: string;
        elements?: segment[];
        timestamp?: number;
        author?: Author;
        quote?: Message;
    }
    interface Message extends MessageBase {
        subtype?: string;
    }
}
export interface SendOptions {
    session?: Session;
}
export interface Session extends Session.Payload, Satori.Session {
}
export namespace Session {
    interface Payload {
        platform: string;
        selfId: string;
        type?: string;
        subtype?: string;
        subsubtype?: string;
        messageId?: string;
        channelId?: string;
        guildId?: string;
        userId?: string;
        content?: string;
        elements?: segment[];
        timestamp?: number;
        author?: Universal.Author;
        quote?: Universal.Message;
        channelName?: string;
        guildName?: string;
        operatorId?: string;
        targetId?: string;
        duration?: number;
    }
}
export class Session {
    id: string;
    bot: Bot;
    app: Context;
    constructor(bot: Bot, payload?: Partial<Session.Payload>);
    initialize(): void;
    get uid(): string;
    get gid(): string;
    get cid(): string;
    get sid(): string;
    get content(): string;
    set content(value: string);
    toJSON(): Session.Payload;
}
export interface Bot extends Universal.Methods, Universal.User {
    socket?: WebSocket;
}
export abstract class Bot<T extends Bot.Config = Bot.Config> {
    ctx: Context;
    config: T;
    static reusable: boolean;
    isBot: boolean;
    hidden: boolean;
    platform: string;
    selfId: string;
    internal?: any;
    adapter?: Adapter<this>;
    error?: Error;
    protected context: Context;
    protected _status: Bot.Status;
    constructor(ctx: Context, config: T);
    get status(): Bot.Status;
    set status(value: Bot.Status);
    online(): void;
    offline(error?: Error): void;
    start(): Promise<void>;
    stop(): Promise<void>;
    get sid(): string;
    session(payload?: Partial<Session.Payload>): Session;
    dispatch(session: Session): void;
}
export namespace Bot {
    interface Config {
        platform?: string;
        selfId?: string;
    }
    type Status = 'offline' | 'online' | 'connect' | 'disconnect' | 'reconnect';
}
export type Filter = (session: Session) => boolean;
export interface Context {
    selector: Selector;
    filter: Filter;
    any(): this;
    never(): this;
    union(arg: Filter | this): this;
    intersect(arg: Filter | this): this;
    exclude(arg: Filter | this): this;
    user(...values: string[]): this;
    self(...values: string[]): this;
    guild(...values: string[]): this;
    channel(...values: string[]): this;
    platform(...values: string[]): this;
    private(...values: string[]): this;
}
export class Selector {
    private app;
    static readonly methods: string[];
    constructor(app: Context);
    protected get caller(): Context;
    any(): Context;
    never(): Context;
    union(arg: Filter | Context): Context;
    intersect(arg: Filter | Context): Context;
    exclude(arg: Filter | Context): Context;
    user(...values: string[]): Context;
    self(...values: string[]): Context;
    guild(...values: string[]): Context;
    channel(...values: string[]): Context;
    platform(...values: string[]): Context;
    private(...values: string[]): Context;
}
export abstract class Messenger<B extends Bot = Bot> {
    bot: B;
    channelId: string;
    guildId?: string;
    options?: SendOptions;
    errors: Error[];
    results: Session[];
    session: Session;
    constructor(bot: B, channelId: string, guildId?: string, options?: SendOptions);
    abstract flush(): Promise<void>;
    abstract visit(element: segment): Promise<void>;
    render(elements: segment[], flush?: boolean): Promise<void>;
    send(content: segment.Fragment): Promise<string[]>;
}
export { Messenger as Modulator };
export { Fragment, Render, escape, unescape };
export { Schema, Logger, segment, segment as Element, segment as h, Quester };
declare global {
    namespace Satori {
        type Genres = 'friend' | 'channel' | 'guild' | 'guild-member' | 'guild-role' | 'guild-file' | 'guild-emoji';
        type Actions = 'added' | 'deleted' | 'updated';
        interface Session {
        }
        interface Events extends Record<`${Genres}-${Actions}`, {}> {
            'message': {};
            'message-deleted': {};
            'message-updated': {};
            'reaction-added': {};
            'reaction-deleted': {};
            'reaction-deleted/one': {};
            'reaction-deleted/all': {};
            'reaction-deleted/emoji': {};
            'send': {};
            'friend-request': {};
            'guild-request': {};
            'guild-member-request': {};
            'guild-member/role': {};
            'guild-member/ban': {};
            'guild-member/nickname': {};
            'notice/poke': {};
            'notice/lucky-king': {};
            'notice/honor': {};
            'notice/honor/talkative': {};
            'notice/honor/performer': {};
            'notice/honor/emotion': {};
        }
    }
}
type EventCallback<T = void, R extends any[] = []> = (this: Session, session: Session, ...args: R) => T;
export interface Events<C extends Context = Context> extends cordis.Events<C>, Record<keyof Satori.Events, EventCallback> {
    'before-send': EventCallback<Awaitable<void | boolean>, [SendOptions]>;
    'bot-added'(client: Bot): void;
    'bot-removed'(client: Bot): void;
    'bot-status-updated'(client: Bot): void;
    'bot-connect'(client: Bot): Awaitable<void>;
    'bot-disconnect'(client: Bot): Awaitable<void>;
}
export interface Context {
    [Context.config]: Context.Config;
    [Context.events]: Events<this>;
    bots: Bot[] & Dict<Bot> & {
        counter: number;
    };
}
export class Context extends cordis.Context {
    static readonly session: unique symbol;
    constructor(options?: Context.Config);
    logger(name: string): Logger;
}
export namespace Context {
    export interface Config extends cordis.Context.Config {
    }
    export const Config: Config.Static;
    namespace Config {
        interface Static extends Schema<Config> {
        }
    }
}
export abstract class Adapter<T extends Bot = Bot> {
    static schema: boolean;
    start(bot: T): Promise<void>;
    stop(bot: T): Promise<void>;
}
export namespace Adapter {
    abstract class Client<T extends Bot = Bot> extends Adapter<T> {
        protected ctx: Context;
        protected bot: T;
        static reusable: boolean;
        constructor(ctx: Context, bot: T);
    }
    abstract class Server<T extends Bot = Bot> extends Adapter<T> {
        bots: T[];
        fork(ctx: Context, bot: T): void;
    }
    namespace WsClient {
        interface Config extends Bot.Config {
            retryLazy?: number;
            retryTimes?: number;
            retryInterval?: number;
        }
    }
    abstract class WsClient<T extends Bot<WsClient.Config>> extends Adapter.Client<T> {
        static reusable: boolean;
        static Config: Schema<Adapter.WsClient.Config>;
        protected abstract prepare(bot: T): Awaitable<WebSocket>;
        protected abstract accept(bot: T): void;
        start(bot: T): Promise<void>;
        stop(bot: T): Promise<void>;
    }
}
