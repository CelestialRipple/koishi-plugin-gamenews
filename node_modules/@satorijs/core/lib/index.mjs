var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// satori/packages/core/src/index.ts
import * as cordis from "cordis";

// satori/packages/core/src/selector.ts
import { defineProperty } from "cosmokit";
function property(ctx, key, ...values) {
  return ctx.intersect((session) => {
    return values.length ? values.includes(session[key]) : !!session[key];
  });
}
__name(property, "property");
var Selector = class {
  constructor(app) {
    this.app = app;
    defineProperty(this, Context.current, app);
    app.filter = () => true;
    app.on("internal/runtime", (runtime) => {
      if (!runtime.uid)
        return;
      runtime.ctx.filter = (session) => {
        return runtime.children.some((p) => p.ctx.filter(session));
      };
    });
  }
  get caller() {
    return this[Context.current];
  }
  any() {
    return this.caller.extend({ filter: () => true });
  }
  never() {
    return this.caller.extend({ filter: () => false });
  }
  union(arg) {
    const caller = this.caller;
    const filter = typeof arg === "function" ? arg : arg.filter;
    return this.caller.extend({ filter: (s) => caller.filter(s) || filter(s) });
  }
  intersect(arg) {
    const caller = this.caller;
    const filter = typeof arg === "function" ? arg : arg.filter;
    return this.caller.extend({ filter: (s) => caller.filter(s) && filter(s) });
  }
  exclude(arg) {
    const caller = this.caller;
    const filter = typeof arg === "function" ? arg : arg.filter;
    return this.caller.extend({ filter: (s) => caller.filter(s) && !filter(s) });
  }
  user(...values) {
    return property(this.caller, "userId", ...values);
  }
  self(...values) {
    return property(this.caller, "selfId", ...values);
  }
  guild(...values) {
    return property(this.caller, "guildId", ...values);
  }
  channel(...values) {
    return property(this.caller, "channelId", ...values);
  }
  platform(...values) {
    return property(this.caller, "platform", ...values);
  }
  private(...values) {
    return property(this.caller.exclude(property(this.caller, "guildId")), "userId", ...values);
  }
};
__name(Selector, "Selector");
__publicField(Selector, "methods", [
  "any",
  "never",
  "union",
  "intersect",
  "exclude",
  "user",
  "self",
  "guild",
  "channel",
  "platform",
  "private"
]);

// satori/packages/core/src/session.ts
import { defineProperty as defineProperty2 } from "cosmokit";
import segment from "@satorijs/element";
var Session = class {
  id;
  bot;
  app;
  constructor(bot, payload) {
    Object.assign(this, payload);
    this.selfId = bot.selfId;
    this.platform = bot.platform;
    defineProperty2(this, "bot", bot);
    defineProperty2(this, "app", bot.ctx.root);
    defineProperty2(this, "id", bot.ctx.bots.counter);
    this.initialize();
  }
  initialize() {
  }
  get uid() {
    return `${this.platform}:${this.userId}`;
  }
  get gid() {
    return `${this.platform}:${this.guildId}`;
  }
  get cid() {
    return `${this.platform}:${this.channelId}`;
  }
  get sid() {
    return `${this.platform}:${this.selfId}`;
  }
  get content() {
    return this.elements.join("");
  }
  set content(value) {
    this.elements = segment.parse(value);
  }
  toJSON() {
    return Object.fromEntries(Object.entries(this).filter(([key]) => {
      return !key.startsWith("_") && !key.startsWith("$");
    }));
  }
};
__name(Session, "Session");

// satori/packages/core/src/index.ts
import Schema2 from "schemastery";
import Logger2 from "reggol";
import Quester from "cordis-axios";
import segment3 from "@satorijs/element";
import { Fragment, Render, escape, unescape } from "@satorijs/element";

// satori/packages/core/src/bot.ts
import { remove } from "cosmokit";
var Bot = class {
  constructor(ctx, config) {
    this.ctx = ctx;
    this.config = config;
    if (config.platform) {
      this.platform = config.platform;
    }
    if (config.selfId) {
      this.selfId = config.selfId;
    }
    this.context = ctx;
    ctx.bots.push(this);
    this.context.emit("bot-added", this);
    ctx.on("ready", () => this.start());
    ctx.on("dispose", () => {
      remove(ctx.bots, this);
      this.context.emit("bot-removed", this);
      this.stop();
    });
  }
  isBot = true;
  hidden = false;
  platform;
  selfId;
  internal;
  adapter;
  error;
  context;
  _status = "offline";
  get status() {
    return this._status;
  }
  set status(value) {
    this._status = value;
    if (this.ctx.bots.includes(this)) {
      this.context.emit("bot-status-updated", this);
    }
  }
  online() {
    this.status = "online";
    this.error = null;
  }
  offline(error) {
    this.status = "offline";
    this.error = error;
  }
  async start() {
    if (["connect", "reconnect", "online"].includes(this.status))
      return;
    this.status = "connect";
    try {
      await this.context.parallel("bot-connect", this);
      await this.adapter.start(this);
    } catch (error) {
      this.offline(error);
    }
  }
  async stop() {
    if (["disconnect", "offline"].includes(this.status))
      return;
    this.status = "disconnect";
    try {
      await this.context.parallel("bot-disconnect", this);
      await this.adapter.stop(this);
    } catch (error) {
      this.context.emit("internal/warning", error);
      this.offline();
    }
  }
  get sid() {
    return `${this.platform}:${this.selfId}`;
  }
  session(payload) {
    return new Session(this, payload);
  }
  dispatch(session) {
    if (!this.ctx.lifecycle.isActive)
      return;
    const events = [session.type];
    if (session.subtype) {
      events.unshift(events[0] + "/" + session.subtype);
      if (session.subsubtype) {
        events.unshift(events[0] + "/" + session.subsubtype);
      }
    }
    for (const event of events) {
      this.context.emit(session, event, session);
    }
  }
};
__name(Bot, "Bot");
__publicField(Bot, "reusable", true);

// satori/packages/core/src/adapter.ts
import { remove as remove2, Time } from "cosmokit";
import Schema from "schemastery";
import Logger from "reggol";
var logger = new Logger("adapter");
var Adapter = class {
  async start(bot) {
  }
  async stop(bot) {
  }
};
__name(Adapter, "Adapter");
__publicField(Adapter, "schema", false);
((Adapter2) => {
  class Client extends Adapter2 {
    constructor(ctx, bot) {
      super();
      this.ctx = ctx;
      this.bot = bot;
      bot.adapter = this;
    }
    static reusable = true;
  }
  __name(Client, "Client");
  Adapter2.Client = Client;
  class Server extends Adapter2 {
    bots = [];
    fork(ctx, bot) {
      bot.adapter = this;
      this.bots.push(bot);
      ctx.on("dispose", () => {
        remove2(this.bots, bot);
      });
    }
  }
  __name(Server, "Server");
  Adapter2.Server = Server;
  class WsClient extends Adapter2.Client {
    static reusable = true;
    static Config = Schema.object({
      retryTimes: Schema.natural().description("初次连接时的最大重试次数。").default(6),
      retryInterval: Schema.natural().role("ms").description("初次连接时的重试时间间隔。").default(5 * Time.second),
      retryLazy: Schema.natural().role("ms").description("连接关闭后的重试时间间隔。").default(Time.minute)
    }).description("连接设置");
    async start(bot) {
      let _retryCount = 0;
      const { retryTimes, retryInterval, retryLazy } = bot.config;
      const reconnect = /* @__PURE__ */ __name(async (initial = false) => {
        logger.debug("websocket client opening");
        const socket = await this.prepare(bot);
        const url = socket.url.replace(/\?.+/, "");
        socket.onerror = (error) => logger.debug(error);
        socket.onclose = ({ code, reason }) => {
          bot.socket = null;
          logger.debug(`websocket closed with ${code}`);
          if (bot.status === "disconnect") {
            return bot.status = "offline";
          }
          const message = reason.toString() || `failed to connect to ${url}, code: ${code}`;
          let timeout = retryInterval;
          if (_retryCount >= retryTimes) {
            if (initial) {
              bot.error = new Error(message);
              return bot.status = "offline";
            } else {
              timeout = retryLazy;
            }
          }
          _retryCount++;
          bot.status = "reconnect";
          logger.warn(`${message}, will retry in ${Time.format(timeout)}...`);
          setTimeout(() => {
            if (bot.status === "reconnect")
              reconnect();
          }, timeout);
        };
        socket.onopen = () => {
          _retryCount = 0;
          bot.socket = socket;
          logger.info("connect to server: %c", url);
          this.accept(bot);
        };
      }, "reconnect");
      reconnect(true);
    }
    async stop(bot) {
      bot.socket?.close();
    }
  }
  __name(WsClient, "WsClient");
  Adapter2.WsClient = WsClient;
})(Adapter || (Adapter = {}));

// satori/packages/core/src/message.ts
import { defineProperty as defineProperty3 } from "cosmokit";
import segment2 from "@satorijs/element";
var AggregateError = class extends Error {
  constructor(errors, message = "") {
    super(message);
    this.errors = errors;
  }
};
__name(AggregateError, "AggregateError");
var Messenger = class {
  constructor(bot, channelId, guildId, options) {
    this.bot = bot;
    this.channelId = channelId;
    this.guildId = guildId;
    this.options = options;
    this.session = bot.session({
      type: "send",
      author: bot,
      channelId,
      guildId,
      subtype: guildId ? "group" : "private"
    });
    defineProperty3(this.session, bot.platform, Object.create(bot.internal));
  }
  errors = [];
  results = [];
  session;
  async render(elements, flush) {
    for (const element of elements) {
      await this.visit(element);
    }
    if (flush) {
      await this.flush();
    }
  }
  async send(content) {
    this.session.elements = segment2.normalize(content);
    if (await this.session.app.serial(this.session, "before-send", this.session, this.options))
      return;
    await this.render(this.session.elements);
    await this.flush();
    if (this.errors.length) {
      throw new AggregateError(this.errors);
    } else {
      return this.results.map((result) => result.messageId);
    }
  }
};
__name(Messenger, "Messenger");

// satori/packages/core/src/index.ts
var Context = class extends cordis.Context {
  constructor(options) {
    super(options);
    this.on("internal/warning", (format, ...args) => {
      this.logger("app").warn(format, ...args);
    });
  }
  logger(name) {
    return new Logger2(name);
  }
};
__name(Context, "Context");
__publicField(Context, "session", Symbol("session"));
((Context3) => {
  Context3.Config = Schema2.intersect([
    Schema2.object({})
  ]);
})(Context || (Context = {}));
Session.prototype[Context.filter] = function(ctx) {
  return ctx.filter(this);
};
Context.service("selector", Selector);
Context.service("bots", class {
  constructor(root) {
    const list = [];
    let counter = 0;
    return new Proxy(list, {
      get(target, prop) {
        if (prop in target || typeof prop === "symbol") {
          return target[prop];
        }
        if (prop === "counter")
          return counter++;
        return list.find((bot) => bot.sid === prop);
      },
      deleteProperty(target, prop) {
        if (prop in target || typeof prop === "symbol") {
          return delete target[prop];
        }
        const bot = target.findIndex((bot2) => bot2.sid === prop);
        if (bot < 0)
          return true;
        target.splice(bot, 1);
        return true;
      }
    });
  }
});
export {
  Adapter,
  Bot,
  Context,
  segment3 as Element,
  Fragment,
  Logger2 as Logger,
  Messenger,
  Messenger as Modulator,
  Quester,
  Render,
  Schema2 as Schema,
  Selector,
  Session,
  escape,
  segment3 as h,
  segment3 as segment,
  unescape
};
//# sourceMappingURL=index.mjs.map
