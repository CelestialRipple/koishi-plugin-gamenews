var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// satori/packages/core/src/index.ts
var src_exports = {};
__export(src_exports, {
  Adapter: () => Adapter,
  Bot: () => Bot,
  Context: () => Context,
  Element: () => import_element3.default,
  Fragment: () => import_element4.Fragment,
  Logger: () => import_reggol2.default,
  Messenger: () => Messenger,
  Modulator: () => Messenger,
  Quester: () => import_cordis_axios.default,
  Render: () => import_element4.Render,
  Schema: () => import_schemastery2.default,
  Selector: () => Selector,
  Session: () => Session,
  escape: () => import_element4.escape,
  h: () => import_element3.default,
  segment: () => import_element3.default,
  unescape: () => import_element4.unescape
});
module.exports = __toCommonJS(src_exports);
var cordis = __toESM(require("cordis"));

// satori/packages/core/src/selector.ts
var import_cosmokit = require("cosmokit");
function property(ctx, key, ...values) {
  return ctx.intersect((session) => {
    return values.length ? values.includes(session[key]) : !!session[key];
  });
}
__name(property, "property");
var Selector = class {
  constructor(app) {
    this.app = app;
    (0, import_cosmokit.defineProperty)(this, Context.current, app);
    app.filter = () => true;
    app.on("internal/runtime", (runtime) => {
      if (!runtime.uid)
        return;
      runtime.ctx.filter = (session) => {
        return runtime.children.some((p) => p.ctx.filter(session));
      };
    });
  }
  get caller() {
    return this[Context.current];
  }
  any() {
    return this.caller.extend({ filter: () => true });
  }
  never() {
    return this.caller.extend({ filter: () => false });
  }
  union(arg) {
    const caller = this.caller;
    const filter = typeof arg === "function" ? arg : arg.filter;
    return this.caller.extend({ filter: (s) => caller.filter(s) || filter(s) });
  }
  intersect(arg) {
    const caller = this.caller;
    const filter = typeof arg === "function" ? arg : arg.filter;
    return this.caller.extend({ filter: (s) => caller.filter(s) && filter(s) });
  }
  exclude(arg) {
    const caller = this.caller;
    const filter = typeof arg === "function" ? arg : arg.filter;
    return this.caller.extend({ filter: (s) => caller.filter(s) && !filter(s) });
  }
  user(...values) {
    return property(this.caller, "userId", ...values);
  }
  self(...values) {
    return property(this.caller, "selfId", ...values);
  }
  guild(...values) {
    return property(this.caller, "guildId", ...values);
  }
  channel(...values) {
    return property(this.caller, "channelId", ...values);
  }
  platform(...values) {
    return property(this.caller, "platform", ...values);
  }
  private(...values) {
    return property(this.caller.exclude(property(this.caller, "guildId")), "userId", ...values);
  }
};
__name(Selector, "Selector");
Selector.methods = [
  "any",
  "never",
  "union",
  "intersect",
  "exclude",
  "user",
  "self",
  "guild",
  "channel",
  "platform",
  "private"
];

// satori/packages/core/src/session.ts
var import_cosmokit2 = require("cosmokit");
var import_element = __toESM(require("@satorijs/element"));
var Session = class {
  constructor(bot, payload) {
    Object.assign(this, payload);
    this.selfId = bot.selfId;
    this.platform = bot.platform;
    (0, import_cosmokit2.defineProperty)(this, "bot", bot);
    (0, import_cosmokit2.defineProperty)(this, "app", bot.ctx.root);
    (0, import_cosmokit2.defineProperty)(this, "id", bot.ctx.bots.counter);
    this.initialize();
  }
  initialize() {
  }
  get uid() {
    return `${this.platform}:${this.userId}`;
  }
  get gid() {
    return `${this.platform}:${this.guildId}`;
  }
  get cid() {
    return `${this.platform}:${this.channelId}`;
  }
  get sid() {
    return `${this.platform}:${this.selfId}`;
  }
  get content() {
    return this.elements.join("");
  }
  set content(value) {
    this.elements = import_element.default.parse(value);
  }
  toJSON() {
    return Object.fromEntries(Object.entries(this).filter(([key]) => {
      return !key.startsWith("_") && !key.startsWith("$");
    }));
  }
};
__name(Session, "Session");

// satori/packages/core/src/index.ts
var import_schemastery2 = __toESM(require("schemastery"));
var import_reggol2 = __toESM(require("reggol"));
var import_cordis_axios = __toESM(require("cordis-axios"));
var import_element3 = __toESM(require("@satorijs/element"));
var import_element4 = require("@satorijs/element");

// satori/packages/core/src/bot.ts
var import_cosmokit3 = require("cosmokit");
var Bot = class {
  constructor(ctx, config) {
    this.ctx = ctx;
    this.config = config;
    this.isBot = true;
    this.hidden = false;
    this._status = "offline";
    if (config.platform) {
      this.platform = config.platform;
    }
    if (config.selfId) {
      this.selfId = config.selfId;
    }
    this.context = ctx;
    ctx.bots.push(this);
    this.context.emit("bot-added", this);
    ctx.on("ready", () => this.start());
    ctx.on("dispose", () => {
      (0, import_cosmokit3.remove)(ctx.bots, this);
      this.context.emit("bot-removed", this);
      this.stop();
    });
  }
  get status() {
    return this._status;
  }
  set status(value) {
    this._status = value;
    if (this.ctx.bots.includes(this)) {
      this.context.emit("bot-status-updated", this);
    }
  }
  online() {
    this.status = "online";
    this.error = null;
  }
  offline(error) {
    this.status = "offline";
    this.error = error;
  }
  async start() {
    if (["connect", "reconnect", "online"].includes(this.status))
      return;
    this.status = "connect";
    try {
      await this.context.parallel("bot-connect", this);
      await this.adapter.start(this);
    } catch (error) {
      this.offline(error);
    }
  }
  async stop() {
    if (["disconnect", "offline"].includes(this.status))
      return;
    this.status = "disconnect";
    try {
      await this.context.parallel("bot-disconnect", this);
      await this.adapter.stop(this);
    } catch (error) {
      this.context.emit("internal/warning", error);
      this.offline();
    }
  }
  get sid() {
    return `${this.platform}:${this.selfId}`;
  }
  session(payload) {
    return new Session(this, payload);
  }
  dispatch(session) {
    if (!this.ctx.lifecycle.isActive)
      return;
    const events = [session.type];
    if (session.subtype) {
      events.unshift(events[0] + "/" + session.subtype);
      if (session.subsubtype) {
        events.unshift(events[0] + "/" + session.subsubtype);
      }
    }
    for (const event of events) {
      this.context.emit(session, event, session);
    }
  }
};
__name(Bot, "Bot");
Bot.reusable = true;

// satori/packages/core/src/adapter.ts
var import_cosmokit4 = require("cosmokit");
var import_schemastery = __toESM(require("schemastery"));
var import_reggol = __toESM(require("reggol"));
var logger = new import_reggol.default("adapter");
var Adapter = class {
  async start(bot) {
  }
  async stop(bot) {
  }
};
__name(Adapter, "Adapter");
Adapter.schema = false;
((Adapter2) => {
  class Client extends Adapter2 {
    constructor(ctx, bot) {
      super();
      this.ctx = ctx;
      this.bot = bot;
      bot.adapter = this;
    }
  }
  __name(Client, "Client");
  Client.reusable = true;
  Adapter2.Client = Client;
  class Server extends Adapter2 {
    constructor() {
      super(...arguments);
      this.bots = [];
    }
    fork(ctx, bot) {
      bot.adapter = this;
      this.bots.push(bot);
      ctx.on("dispose", () => {
        (0, import_cosmokit4.remove)(this.bots, bot);
      });
    }
  }
  __name(Server, "Server");
  Adapter2.Server = Server;
  class WsClient extends Adapter2.Client {
    async start(bot) {
      let _retryCount = 0;
      const { retryTimes, retryInterval, retryLazy } = bot.config;
      const reconnect = /* @__PURE__ */ __name(async (initial = false) => {
        logger.debug("websocket client opening");
        const socket = await this.prepare(bot);
        const url = socket.url.replace(/\?.+/, "");
        socket.onerror = (error) => logger.debug(error);
        socket.onclose = ({ code, reason }) => {
          bot.socket = null;
          logger.debug(`websocket closed with ${code}`);
          if (bot.status === "disconnect") {
            return bot.status = "offline";
          }
          const message = reason.toString() || `failed to connect to ${url}, code: ${code}`;
          let timeout = retryInterval;
          if (_retryCount >= retryTimes) {
            if (initial) {
              bot.error = new Error(message);
              return bot.status = "offline";
            } else {
              timeout = retryLazy;
            }
          }
          _retryCount++;
          bot.status = "reconnect";
          logger.warn(`${message}, will retry in ${import_cosmokit4.Time.format(timeout)}...`);
          setTimeout(() => {
            if (bot.status === "reconnect")
              reconnect();
          }, timeout);
        };
        socket.onopen = () => {
          _retryCount = 0;
          bot.socket = socket;
          logger.info("connect to server: %c", url);
          this.accept(bot);
        };
      }, "reconnect");
      reconnect(true);
    }
    async stop(bot) {
      var _a;
      (_a = bot.socket) == null ? void 0 : _a.close();
    }
  }
  __name(WsClient, "WsClient");
  WsClient.reusable = true;
  WsClient.Config = import_schemastery.default.object({
    retryTimes: import_schemastery.default.natural().description("初次连接时的最大重试次数。").default(6),
    retryInterval: import_schemastery.default.natural().role("ms").description("初次连接时的重试时间间隔。").default(5 * import_cosmokit4.Time.second),
    retryLazy: import_schemastery.default.natural().role("ms").description("连接关闭后的重试时间间隔。").default(import_cosmokit4.Time.minute)
  }).description("连接设置");
  Adapter2.WsClient = WsClient;
})(Adapter || (Adapter = {}));

// satori/packages/core/src/message.ts
var import_cosmokit5 = require("cosmokit");
var import_element2 = __toESM(require("@satorijs/element"));
var AggregateError = class extends Error {
  constructor(errors, message = "") {
    super(message);
    this.errors = errors;
  }
};
__name(AggregateError, "AggregateError");
var Messenger = class {
  constructor(bot, channelId, guildId, options) {
    this.bot = bot;
    this.channelId = channelId;
    this.guildId = guildId;
    this.options = options;
    this.errors = [];
    this.results = [];
    this.session = bot.session({
      type: "send",
      author: bot,
      channelId,
      guildId,
      subtype: guildId ? "group" : "private"
    });
    (0, import_cosmokit5.defineProperty)(this.session, bot.platform, Object.create(bot.internal));
  }
  async render(elements, flush) {
    for (const element of elements) {
      await this.visit(element);
    }
    if (flush) {
      await this.flush();
    }
  }
  async send(content) {
    this.session.elements = import_element2.default.normalize(content);
    if (await this.session.app.serial(this.session, "before-send", this.session, this.options))
      return;
    await this.render(this.session.elements);
    await this.flush();
    if (this.errors.length) {
      throw new AggregateError(this.errors);
    } else {
      return this.results.map((result) => result.messageId);
    }
  }
};
__name(Messenger, "Messenger");

// satori/packages/core/src/index.ts
var Context = class extends cordis.Context {
  constructor(options) {
    super(options);
    this.on("internal/warning", (format, ...args) => {
      this.logger("app").warn(format, ...args);
    });
  }
  logger(name) {
    return new import_reggol2.default(name);
  }
};
__name(Context, "Context");
Context.session = Symbol("session");
((Context3) => {
  Context3.Config = import_schemastery2.default.intersect([
    import_schemastery2.default.object({})
  ]);
})(Context || (Context = {}));
Session.prototype[Context.filter] = function(ctx) {
  return ctx.filter(this);
};
Context.service("selector", Selector);
Context.service("bots", class {
  constructor(root) {
    const list = [];
    let counter = 0;
    return new Proxy(list, {
      get(target, prop) {
        if (prop in target || typeof prop === "symbol") {
          return target[prop];
        }
        if (prop === "counter")
          return counter++;
        return list.find((bot) => bot.sid === prop);
      },
      deleteProperty(target, prop) {
        if (prop in target || typeof prop === "symbol") {
          return delete target[prop];
        }
        const bot = target.findIndex((bot2) => bot2.sid === prop);
        if (bot < 0)
          return true;
        target.splice(bot, 1);
        return true;
      }
    });
  }
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Adapter,
  Bot,
  Context,
  Element,
  Fragment,
  Logger,
  Messenger,
  Modulator,
  Quester,
  Render,
  Schema,
  Selector,
  Session,
  escape,
  h,
  segment,
  unescape
});
//# sourceMappingURL=index.cjs.map
