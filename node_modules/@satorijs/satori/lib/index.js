var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// satori/packages/satori/src/index.ts
var src_exports = {};
__export(src_exports, {
  Router: () => Router,
  WebSocketLayer: () => WebSocketLayer,
  getAgent: () => getAgent,
  register: () => register
});
module.exports = __toCommonJS(src_exports);
var import_core3 = require("@satorijs/core");
var import_cosmokit3 = require("cosmokit");

// satori/packages/satori/src/listen.ts
function listen(server, { host, port, maxPort = port }) {
  return new Promise((resolve, reject) => {
    function onListen() {
      server.removeListener("error", onError);
      resolve(port);
    }
    __name(onListen, "onListen");
    function onError(err) {
      server.removeListener("listening", onListen);
      if (!(err.code == "EADDRINUSE" || err.code == "EACCES")) {
        return reject(err);
      }
      port++;
      if (port > maxPort) {
        return reject(new Error("No open ports available"));
      }
      testPort();
    }
    __name(onError, "onError");
    function testPort() {
      server.once("error", onError);
      server.once("listening", onListen);
      server.listen(port, host);
    }
    __name(testPort, "testPort");
    testPort();
  });
}
__name(listen, "listen");

// satori/packages/satori/src/index.ts
__reExport(src_exports, require("@satorijs/core"), module.exports);
__reExport(src_exports, require("cosmokit"), module.exports);

// satori/packages/satori/src/axios.ts
var import_core = require("@satorijs/core");
var import_cosmokit = require("cosmokit");
var import_ws = require("ws");
var import_file_type = require("file-type");
var import_path = require("path");
var import_fs = require("fs");
var import_url = require("url");
var import_http_proxy_agent = __toESM(require("http-proxy-agent"));
var import_https_proxy_agent = __toESM(require("https-proxy-agent"));
var import_socks_proxy_agent = __toESM(require("socks-proxy-agent"));
var import_schemastery = __toESM(require("schemastery"));
var oldFile = import_core.Quester.prototype.file;
import_core.Quester.prototype.file = /* @__PURE__ */ __name(async function file(url) {
  if (url.startsWith("file://")) {
    const data = await import_fs.promises.readFile((0, import_url.fileURLToPath)(url));
    const result = await (0, import_file_type.fromBuffer)(data);
    return { mime: result == null ? void 0 : result.mime, filename: (0, import_path.basename)(url), data };
  }
  return oldFile.call(this, url);
}, "file");
import_core.Quester.prototype.ws = /* @__PURE__ */ __name(function ws(url, options = {}) {
  return new import_ws.WebSocket(url, {
    agent: getAgent(this.config.proxyAgent),
    handshakeTimeout: this.config.timeout,
    ...options,
    headers: {
      ...this.config.headers,
      ...options.headers
    }
  });
}, "ws");
var _prepare = import_core.Quester.prototype.prepare;
import_core.Quester.prototype.prepare = /* @__PURE__ */ __name(function prepare() {
  const options = _prepare.call(this);
  options.httpAgent = getAgent(this.config.proxyAgent);
  options.httpsAgent = getAgent(this.config.proxyAgent);
  return options;
}, "prepare");
(0, import_cosmokit.defineProperty)(import_core.Quester, "Config", import_schemastery.default.object({
  ...import_core.Quester.Config.dict,
  proxyAgent: import_schemastery.default.string().description("使用的代理服务器地址。")
}).description("请求设置"));
var agents = /* @__PURE__ */ Object.create(null);
var proxies = /* @__PURE__ */ Object.create(null);
function register(protocols, callback) {
  for (const protocol of protocols) {
    proxies[protocol] = callback;
  }
}
__name(register, "register");
register(["http"], import_http_proxy_agent.default);
register(["https"], import_https_proxy_agent.default);
register(["socks", "socks4", "socks4a", "socks5", "socks5h"], import_socks_proxy_agent.default);
function getAgent(url) {
  if (!url)
    return;
  if (agents[url])
    return agents[url];
  const { protocol } = new URL(url);
  const callback = proxies[protocol.slice(0, -1)];
  return agents[url] || (agents[url] = callback(url));
}
__name(getAgent, "getAgent");

// satori/packages/satori/src/router.ts
var import_core2 = require("@satorijs/core");
var import_cosmokit2 = require("cosmokit");
var import_http = require("http");
var import_path_to_regexp = require("path-to-regexp");
var import_parseurl = __toESM(require("parseurl"));
var import_ws2 = __toESM(require("ws"));
var import_router = __toESM(require("@koa/router"));
var import_koa = __toESM(require("koa"));
var WebSocketLayer = class {
  constructor(router, path, callback) {
    this.router = router;
    this.callback = callback;
    this.clients = /* @__PURE__ */ new Set();
    this.regexp = (0, import_path_to_regexp.pathToRegexp)(path);
  }
  accept(socket, request) {
    var _a;
    if (!this.regexp.test((0, import_parseurl.default)(request).pathname))
      return;
    this.clients.add(socket);
    socket.on("close", () => {
      this.clients.delete(socket);
    });
    (_a = this.callback) == null ? void 0 : _a.call(this, socket, request);
    return true;
  }
  close() {
    (0, import_cosmokit2.remove)(this.router.wsStack, this);
    for (const socket of this.clients) {
      socket.close();
    }
  }
};
__name(WebSocketLayer, "WebSocketLayer");
var Router = class extends import_router.default {
  constructor(ctx) {
    super();
    this.wsStack = [];
    const koa = new import_koa.default();
    koa.use(require("koa-bodyparser")());
    koa.use(this.routes());
    koa.use(this.allowedMethods());
    this._http = (0, import_http.createServer)(koa.callback());
    this._ws = new import_ws2.default.Server({
      server: this._http
    });
    this._ws.on("connection", (socket, request) => {
      for (const manager of this.wsStack) {
        if (manager.accept(socket, request))
          return;
      }
      socket.close();
    });
  }
  register(...args) {
    const layer = super.register(...args);
    const context = this[import_core2.Context.current];
    context == null ? void 0 : context.state.disposables.push(() => {
      (0, import_cosmokit2.remove)(this.stack, layer);
    });
    return layer;
  }
  ws(path, callback) {
    const layer = new WebSocketLayer(this, path, callback);
    this.wsStack.push(layer);
    const context = this[import_core2.Context.current];
    context == null ? void 0 : context.state.disposables.push(() => layer.close());
    return layer;
  }
};
__name(Router, "Router");
import_core2.Context.service("router", Router);

// satori/packages/satori/src/index.ts
(0, import_cosmokit3.defineProperty)(import_core3.Context.Config, "Network", import_core3.Schema.object({
  host: import_core3.Schema.string().default("localhost").description("要监听的 IP 地址。如果将此设置为 `0.0.0.0` 将监听所有地址，包括局域网和公网地址。"),
  port: import_core3.Schema.natural().max(65535).description("要监听的初始端口号。"),
  maxPort: import_core3.Schema.natural().max(65535).description("允许监听的最大端口号。"),
  selfUrl: import_core3.Schema.string().role("link").description("应用暴露在公网的地址。")
}).description("网络设置"));
import_core3.Context.Config.list.unshift(import_core3.Context.Config.Network);
import_core3.Context.Config.list.push(import_core3.Schema.object({
  request: import_core3.Quester.Config
}));
var logger = new import_core3.Logger("app");
var start = import_core3.Context.prototype.start;
import_core3.Context.prototype.start = async function(...args) {
  if (this.root.config.selfUrl) {
    this.root.config.selfUrl = (0, import_cosmokit3.trimSlash)(this.root.config.selfUrl);
  }
  if (this.root.config.port) {
    const { host, port } = this.root.config;
    await listen(this.router._http, this.root.config);
    logger.info("server listening at %c", `http://${host}:${port}`);
    this.on("dispose", () => {
      var _a, _b;
      logger.info("http server closing");
      (_a = this.router._ws) == null ? void 0 : _a.close();
      (_b = this.router._http) == null ? void 0 : _b.close();
    });
  }
  this.decline(["selfUrl", "host", "port", "maxPort"]);
  return start.call(this, ...args);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Router,
  WebSocketLayer,
  getAgent,
  register
});
//# sourceMappingURL=index.js.map
