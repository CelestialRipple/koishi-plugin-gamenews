/// <reference types="node" />
import { Context } from '@satorijs/core';
import { Dict } from 'cosmokit';
import { ClientRequestArgs } from 'http';
import WebSocket from 'ws';
import { AxiosRequestConfig, AxiosResponse, Method } from 'axios';
import Schema from 'schemastery';
declare module '@satorijs/core' {
    interface Context {
        http: Quester;
    }
    namespace Context {
        interface Config {
            request?: Quester.Config;
        }
    }
}
export interface Quester {
    <T = any>(method: Method, url: string, config?: AxiosRequestConfig): Promise<T>;
    axios<T = any>(url: string, config?: AxiosRequestConfig): Promise<AxiosResponse<T>>;
    extend(config: Quester.Config): Quester;
    config: Quester.Config;
    head(url: string, config?: AxiosRequestConfig): Promise<Dict<string>>;
    get<T = any>(url: string, config?: AxiosRequestConfig): Promise<T>;
    delete<T = any>(url: string, config?: AxiosRequestConfig): Promise<T>;
    post<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T>;
    put<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T>;
    patch<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T>;
    ws(url: string, options?: ClientRequestArgs): WebSocket;
}
export declare class Quester {
    constructor(ctx: Context, config: Context.Config);
}
export declare namespace Quester {
    const isAxiosError: (payload: any) => payload is import("axios").AxiosError<any, any>;
    interface Config {
        headers?: Dict;
        endpoint?: string;
        timeout?: number;
        proxyAgent?: string;
    }
    const Config: Schema<Config>;
    const createConfig: (endpoint: string | boolean) => Schema<Config>;
    function create(config?: Quester.Config): Quester;
}
