{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["import { Awaitable, camelize, capitalize, defineProperty, Dict, hyphenate, is, isNullable } from 'cosmokit'\n\nconst kElement = Symbol.for('satori.element')\n\nfunction isElement(source: any): source is Element {\n  return source && typeof source === 'object' && source[kElement]\n}\n\nfunction toElement(content: string | Element) {\n  if (typeof content === 'string' || typeof content === 'number' || typeof content === 'boolean') {\n    if (content) return Element('text', { content: '' + content })\n  } else if (isElement(content)) {\n    return content\n  } else if (!isNullable(content)) {\n    throw new TypeError(`Invalid content: ${content}`)\n  }\n}\n\nfunction toElementArray(content: Element.Fragment) {\n  if (Array.isArray(content)) {\n    return content.map(toElement).filter(x => x)\n  } else {\n    return [toElement(content)].filter(x => x)\n  }\n}\n\ninterface Element {\n  [kElement]: true\n  type: string\n  attrs: Dict\n  /** @deprecated use `attrs` instead */\n  data: Dict\n  children: Element[]\n  source?: string\n  toString(strip?: boolean): string\n}\n\ninterface ElementConstructor extends Element {}\n\nclass ElementConstructor {\n  get data() {\n    return this.attrs\n  }\n\n  toString(strip = false) {\n    if (this.type === 'text') return Element.escape(this.attrs.content)\n    const inner = this.children.map(child => child.toString(strip)).join('')\n    if (strip) return inner\n    const attrs = Object.entries(this.attrs).map(([key, value]) => {\n      if (isNullable(value)) return ''\n      key = hyphenate(key)\n      if (value === true) return ` ${key}`\n      if (value === false) return ` no-${key}`\n      return ` ${key}=\"${Element.escape('' + value, true)}\"`\n    }).join('')\n    if (!this.children.length) return `<${this.type}${attrs}/>`\n    return `<${this.type}${attrs}>${inner}</${this.type}>`\n  }\n}\n\ndefineProperty(ElementConstructor, 'name', 'Element')\ndefineProperty(ElementConstructor.prototype, kElement, true)\n\nfunction Element(type: string, ...children: Element.Fragment[]): Element\nfunction Element(type: string, attrs: Dict, ...children: Element.Fragment[]): Element\nfunction Element(type: string, ...args: any[]) {\n  const el = Object.create(ElementConstructor.prototype)\n  let attrs: Dict = {}, children: Element[] = []\n  if (args[0] && typeof args[0] === 'object' && !isElement(args[0]) && !Array.isArray(args[0])) {\n    for (const [key, value] of Object.entries(args.shift())) {\n      if (isNullable(value)) continue\n      // https://github.com/reactjs/rfcs/pull/107\n      if (key === 'children') {\n        children = toElementArray(value as Element.Fragment)\n      } else {\n        attrs[key] = value\n      }\n    }\n  }\n  for (const child of args) {\n    children.push(...toElementArray(child))\n  }\n  return Object.assign(el, { type, attrs, children })\n}\n\n// eslint-disable-next-line no-new-func\nconst evaluate = new Function('expr', 'context', `\n  try {\n    with (context) {\n      return eval(expr)\n    }\n  } catch {}\n`) as ((expr: string, context: object) => string)\n\nnamespace Element {\n  export const jsx = Element\n  export const jsxs = Element\n  export const jsxDEV = Element\n  export const Fragment = 'template'\n\n  export type Fragment = string | Element | (string | Element)[]\n  export type Render<T, S> = (attrs: Dict<any>, children: Element[], session: S) => T\n  export type Transformer<S = never> = boolean | Fragment | Render<boolean | Fragment, S>\n  export type AsyncTransformer<S = never> = boolean | Fragment | Render<Awaitable<boolean | Fragment>, S>\n\n  export function normalize(source: Fragment, context?: any) {\n    if (typeof source !== 'string') return toElementArray(source)\n    return Element.parse(source, context)\n  }\n\n  export function escape(source: string, inline = false) {\n    const result = source\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n    return inline\n      ? result.replace(/\"/g, '&quot;')\n      : result\n  }\n\n  export function unescape(source: string) {\n    return source\n      .replace(/&lt;/g, '<')\n      .replace(/&gt;/g, '>')\n      .replace(/&quot;/g, '\"')\n      .replace(/&#(\\d+);/g, (_, code) => code === '38' ? _ : String.fromCharCode(+code))\n      .replace(/&#x([0-9a-f]+);/gi, (_, code) => code === '26' ? _ : String.fromCharCode(parseInt(code, 16)))\n      .replace(/&(amp|#38|#x26);/g, '&')\n  }\n\n  export interface FindOptions {\n    type?: string\n    caret?: boolean\n  }\n\n  /** @deprecated use `Element.select()` instead */\n  export function from(source: string, options: FindOptions = {}): Element {\n    const elements = parse(source)\n    if (options.caret) {\n      if (options.type && elements[0]?.type !== options.type) return\n      return elements[0]\n    }\n    return select(elements, options.type || '*')[0]\n  }\n\n  type Combinator = ' ' | '>' | '+' | '~'\n\n  export interface Selector {\n    type: string\n    combinator: Combinator\n  }\n\n  const combRegExp = / *([ >+~]) */g\n\n  export function parseSelector(input: string): Selector[][] {\n    return input.split(',').map((query) => {\n      const selectors: Selector[] = []\n      query = query.trim()\n      let combCap: RegExpExecArray, combinator: Combinator = ' '\n      while ((combCap = combRegExp.exec(query))) {\n        selectors.push({ type: query.slice(0, combCap.index), combinator })\n        combinator = combCap[1] as Combinator\n        query = query.slice(combCap.index + combCap[0].length)\n      }\n      selectors.push({ type: query, combinator })\n      return selectors\n    })\n  }\n\n  export function select(source: string | Element[], query: string | Selector[][]): Element[] {\n    if (typeof source === 'string') source = parse(source)\n    if (typeof query === 'string') query = parseSelector(query)\n    if (!query.length) return\n    let adjacent: Selector[][] = []\n    const results: Element[] = []\n    for (const [index, element] of source.entries()) {\n      const inner: Selector[][] = []\n      const local = [...query, ...adjacent]\n      adjacent = []\n      let matched = false\n      for (const group of local) {\n        const { type, combinator } = group[0]\n        if (type === element.type || type === '*') {\n          if (group.length === 1) {\n            matched = true\n          } else if ([' ', '>'].includes(group[1].combinator)) {\n            inner.push(group.slice(1))\n          } else if (group[1].combinator === '+') {\n            adjacent.push(group.slice(1))\n          } else {\n            query.push(group.slice(1))\n          }\n        }\n        if (combinator === ' ') {\n          inner.push(group)\n        }\n      }\n      if (matched) results.push(source[index])\n      results.push(...select(element.children, inner))\n    }\n    return results\n  }\n\n  export function interpolate(expr: string, context: any) {\n    expr = expr.trim()\n    if (!/^[\\w.]+$/.test(expr)) {\n      return evaluate(expr, context) ?? ''\n    }\n    let value = context\n    for (const part of expr.split('.')) {\n      value = value[part]\n      if (isNullable(value)) return ''\n    }\n    return value ?? ''\n  }\n\n  const tagRegExp = /<!--[\\s\\S]*?-->|<(\\/?)\\s*([^!\\s>/]*)([^>]*?)\\s*(\\/?)>/\n  const attrRegExp1 = /([^\\s=]+)(?:=\"([^\"]*)\"|='([^']*)')?/g\n  const attrRegExp2 = /([^\\s=]+)(?:=\"([^\"]*)\"|='([^']*)'|=\\{([^}]+)\\})?/g\n  const interpRegExp = /\\{([^}]*)\\}/\n\n  interface Token {\n    type: string\n    close: string\n    empty: string\n    attrs: Dict\n    source: string\n  }\n\n  export function parse(source: string, context?: any) {\n    const tokens: (Element | Token)[] = []\n    function pushText(content: string) {\n      if (content) tokens.push(Element('text', { content }))\n    }\n\n    const attrRegExp = context ? attrRegExp2 : attrRegExp1\n    let tagCap: RegExpExecArray\n    while ((tagCap = tagRegExp.exec(source))) {\n      parseContent(source.slice(0, tagCap.index))\n      const [_, close, type, attrs, empty] = tagCap\n      source = source.slice(tagCap.index + _.length)\n      if (_.startsWith('<!')) continue\n      const token: Token = { source: _, type: type || Fragment, close, empty, attrs: {} }\n      let attrCap: RegExpExecArray\n      while ((attrCap = attrRegExp.exec(attrs))) {\n        const [_, key, v1, v2 = v1, v3] = attrCap\n        if (v3) {\n          token.attrs[camelize(key)] = interpolate(v3, context)\n        } else if (!isNullable(v2)) {\n          token.attrs[camelize(key)] = unescape(v2)\n        } else if (key.startsWith('no-')) {\n          token.attrs[camelize(key.slice(3))] = false\n        } else {\n          token.attrs[camelize(key)] = true\n        }\n      }\n      tokens.push(token)\n    }\n\n    parseContent(source)\n    function parseContent(source: string) {\n      source = source\n        .replace(/^\\s*\\n\\s*/, '')\n        .replace(/\\s*\\n\\s*$/, '')\n      if (context) {\n        let interpCap: RegExpExecArray\n        while ((interpCap = interpRegExp.exec(source))) {\n          const [_, expr] = interpCap\n          pushText(unescape(source.slice(0, interpCap.index)))\n          source = source.slice(interpCap.index + _.length)\n          const content = interpolate(expr, context)\n          tokens.push(...toElementArray(content))\n        }\n      }\n      pushText(unescape(source))\n    }\n\n    const stack = [Element(Fragment)]\n    function rollback(index: number) {\n      for (; index > 0; index--) {\n        const { children } = stack.shift()\n        const { source } = stack[0].children.pop()\n        stack[0].children.push(Element('text', { content: source }))\n        stack[0].children.push(...children)\n      }\n    }\n\n    for (const token of tokens) {\n      if (isElement(token)) {\n        stack[0].children.push(token)\n      } else if (token.close) {\n        let index = 0\n        while (index < stack.length && stack[index].type !== token.type) index++\n        if (index === stack.length) {\n          // no matching open tag\n          stack[0].children.push(Element('text', { content: token.source }))\n        } else {\n          rollback(index)\n          const element = stack.shift()\n          delete element.source\n        }\n      } else {\n        const element = Element(token.type, token.attrs)\n        stack[0].children.push(element)\n        if (!token.empty) {\n          element.source = token.source\n          stack.unshift(element)\n        }\n      }\n    }\n    rollback(stack.length - 1)\n    return stack[0].children\n  }\n\n  export function transform<S = never>(source: string, rules: Dict<Transformer<S>>, session?: S): string\n  export function transform<S = never>(source: Element[], rules: Dict<Transformer<S>>, session?: S): Element[]\n  export function transform<S>(source: string | Element[], rules: Dict<Transformer<S>>, session?: S) {\n    const elements = typeof source === 'string' ? parse(source) : source\n    const output: Element[] = []\n    elements.forEach((element) => {\n      const { type, attrs, children } = element\n      let result = rules[type] ?? rules.default ?? true\n      if (typeof result === 'function') {\n        result = result(attrs, children, session)\n      }\n      if (result === true) {\n        output.push(Element(type, attrs, transform(children, rules, session)))\n      } else if (result !== false) {\n        output.push(...normalize(result))\n      }\n    })\n    return typeof source === 'string' ? output.join('') : output\n  }\n\n  export async function transformAsync<S = never>(source: string, rules: Dict<AsyncTransformer<S>>, session?: S): Promise<string>\n  export async function transformAsync<S = never>(source: Element[], rules: Dict<AsyncTransformer<S>>, session?: S): Promise<Element[]>\n  export async function transformAsync<S>(source: string | Element[], rules: Dict<AsyncTransformer<S>>, session?: S) {\n    const elements = typeof source === 'string' ? parse(source) : source\n    const children = (await Promise.all(elements.map(async (element) => {\n      const { type, attrs, children } = element\n      let result = rules[type] ?? rules.default ?? true\n      if (typeof result === 'function') {\n        result = await result(attrs, children, session)\n      }\n      if (result === true) {\n        return [Element(type, attrs, await transformAsync(children, rules, session))]\n      } else if (result !== false) {\n        return normalize(result)\n      } else {\n        return []\n      }\n    }))).flat(1)\n    return typeof source === 'string' ? children.join('') : children\n  }\n\n  export type Factory<R extends any[]> = (...args: [...rest: R, attrs?: Dict<any>]) => Element\n\n  function createFactory<R extends any[] = any[]>(type: string, ...keys: string[]): Factory<R> {\n    return (...args: any[]) => {\n      const element = Element(type)\n      keys.forEach((key, index) => {\n        if (!isNullable(args[index])) {\n          element.attrs[key] = args[index]\n        }\n      })\n      if (args[keys.length]) {\n        Object.assign(element.attrs, args[keys.length])\n      }\n      return element\n    }\n  }\n\n  function createAssetFactory(type: string): Factory<[data: string | Buffer | ArrayBuffer]> {\n    return (value, attrs = {}) => {\n      if (is('Buffer', value)) {\n        value = 'base64://' + value.toString('base64')\n      } else if (is('ArrayBuffer', value)) {\n        value = 'base64://' + Buffer.from(value).toString('base64')\n      }\n      return Element(type, { ...attrs, url: value })\n    }\n  }\n\n  export const text = createFactory<[content: any]>('text', 'content')\n  export const at = createFactory<[id: any]>('at', 'id')\n  export const sharp = createFactory<[id: any]>('sharp', 'id')\n  export const quote = createFactory<[id: any]>('quote', 'id')\n  export const image = createAssetFactory('image')\n  export const video = createAssetFactory('video')\n  export const audio = createAssetFactory('audio')\n  export const file = createAssetFactory('file')\n}\n\nexport = Element\n"],
  "mappings": "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",
  "names": ["Element", "_", "source", "children"]
}
