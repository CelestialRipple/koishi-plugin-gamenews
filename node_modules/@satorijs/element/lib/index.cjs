var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// satori/packages/element/src/index.ts
var import_cosmokit = require("cosmokit");
var kElement = Symbol.for("satori.element");
function isElement(source) {
  return source && typeof source === "object" && source[kElement];
}
__name(isElement, "isElement");
function toElement(content) {
  if (typeof content === "string" || typeof content === "number" || typeof content === "boolean") {
    if (content)
      return Element("text", { content: "" + content });
  } else if (isElement(content)) {
    return content;
  } else if (!(0, import_cosmokit.isNullable)(content)) {
    throw new TypeError(`Invalid content: ${content}`);
  }
}
__name(toElement, "toElement");
function toElementArray(content) {
  if (Array.isArray(content)) {
    return content.map(toElement).filter((x) => x);
  } else {
    return [toElement(content)].filter((x) => x);
  }
}
__name(toElementArray, "toElementArray");
var ElementConstructor = class {
  get data() {
    return this.attrs;
  }
  toString(strip = false) {
    if (this.type === "text")
      return Element.escape(this.attrs.content);
    const inner = this.children.map((child) => child.toString(strip)).join("");
    if (strip)
      return inner;
    const attrs = Object.entries(this.attrs).map(([key, value]) => {
      if ((0, import_cosmokit.isNullable)(value))
        return "";
      key = (0, import_cosmokit.hyphenate)(key);
      if (value === true)
        return ` ${key}`;
      if (value === false)
        return ` no-${key}`;
      return ` ${key}="${Element.escape("" + value, true)}"`;
    }).join("");
    if (!this.children.length)
      return `<${this.type}${attrs}/>`;
    return `<${this.type}${attrs}>${inner}</${this.type}>`;
  }
};
__name(ElementConstructor, "ElementConstructor");
(0, import_cosmokit.defineProperty)(ElementConstructor, "name", "Element");
(0, import_cosmokit.defineProperty)(ElementConstructor.prototype, kElement, true);
function Element(type, ...args) {
  const el = Object.create(ElementConstructor.prototype);
  let attrs = {}, children = [];
  if (args[0] && typeof args[0] === "object" && !isElement(args[0]) && !Array.isArray(args[0])) {
    for (const [key, value] of Object.entries(args.shift())) {
      if ((0, import_cosmokit.isNullable)(value))
        continue;
      if (key === "children") {
        children = toElementArray(value);
      } else {
        attrs[key] = value;
      }
    }
  }
  for (const child of args) {
    children.push(...toElementArray(child));
  }
  return Object.assign(el, { type, attrs, children });
}
__name(Element, "Element");
var evaluate = new Function("expr", "context", `
  try {
    with (context) {
      return eval(expr)
    }
  } catch {}
`);
((Element2) => {
  Element2.jsx = Element2;
  Element2.jsxs = Element2;
  Element2.jsxDEV = Element2;
  Element2.Fragment = "template";
  function normalize(source, context) {
    if (typeof source !== "string")
      return toElementArray(source);
    return Element2.parse(source, context);
  }
  Element2.normalize = normalize;
  __name(normalize, "normalize");
  function escape(source, inline = false) {
    const result = source.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    return inline ? result.replace(/"/g, "&quot;") : result;
  }
  Element2.escape = escape;
  __name(escape, "escape");
  function unescape(source) {
    return source.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#(\d+);/g, (_, code) => code === "38" ? _ : String.fromCharCode(+code)).replace(/&#x([0-9a-f]+);/gi, (_, code) => code === "26" ? _ : String.fromCharCode(parseInt(code, 16))).replace(/&(amp|#38|#x26);/g, "&");
  }
  Element2.unescape = unescape;
  __name(unescape, "unescape");
  function from(source, options = {}) {
    var _a;
    const elements = parse(source);
    if (options.caret) {
      if (options.type && ((_a = elements[0]) == null ? void 0 : _a.type) !== options.type)
        return;
      return elements[0];
    }
    return select(elements, options.type || "*")[0];
  }
  Element2.from = from;
  __name(from, "from");
  const combRegExp = / *([ >+~]) */g;
  function parseSelector(input) {
    return input.split(",").map((query) => {
      const selectors = [];
      query = query.trim();
      let combCap, combinator = " ";
      while (combCap = combRegExp.exec(query)) {
        selectors.push({ type: query.slice(0, combCap.index), combinator });
        combinator = combCap[1];
        query = query.slice(combCap.index + combCap[0].length);
      }
      selectors.push({ type: query, combinator });
      return selectors;
    });
  }
  Element2.parseSelector = parseSelector;
  __name(parseSelector, "parseSelector");
  function select(source, query) {
    if (typeof source === "string")
      source = parse(source);
    if (typeof query === "string")
      query = parseSelector(query);
    if (!query.length)
      return;
    let adjacent = [];
    const results = [];
    for (const [index, element] of source.entries()) {
      const inner = [];
      const local = [...query, ...adjacent];
      adjacent = [];
      let matched = false;
      for (const group of local) {
        const { type, combinator } = group[0];
        if (type === element.type || type === "*") {
          if (group.length === 1) {
            matched = true;
          } else if ([" ", ">"].includes(group[1].combinator)) {
            inner.push(group.slice(1));
          } else if (group[1].combinator === "+") {
            adjacent.push(group.slice(1));
          } else {
            query.push(group.slice(1));
          }
        }
        if (combinator === " ") {
          inner.push(group);
        }
      }
      if (matched)
        results.push(source[index]);
      results.push(...select(element.children, inner));
    }
    return results;
  }
  Element2.select = select;
  __name(select, "select");
  function interpolate(expr, context) {
    var _a;
    expr = expr.trim();
    if (!/^[\w.]+$/.test(expr)) {
      return (_a = evaluate(expr, context)) != null ? _a : "";
    }
    let value = context;
    for (const part of expr.split(".")) {
      value = value[part];
      if ((0, import_cosmokit.isNullable)(value))
        return "";
    }
    return value != null ? value : "";
  }
  Element2.interpolate = interpolate;
  __name(interpolate, "interpolate");
  const tagRegExp = /<!--[\s\S]*?-->|<(\/?)\s*([^!\s>/]*)([^>]*?)\s*(\/?)>/;
  const attrRegExp1 = /([^\s=]+)(?:="([^"]*)"|='([^']*)')?/g;
  const attrRegExp2 = /([^\s=]+)(?:="([^"]*)"|='([^']*)'|=\{([^}]+)\})?/g;
  const interpRegExp = /\{([^}]*)\}/;
  function parse(source, context) {
    const tokens = [];
    function pushText(content) {
      if (content)
        tokens.push(Element2("text", { content }));
    }
    __name(pushText, "pushText");
    const attrRegExp = context ? attrRegExp2 : attrRegExp1;
    let tagCap;
    while (tagCap = tagRegExp.exec(source)) {
      parseContent(source.slice(0, tagCap.index));
      const [_, close, type, attrs, empty] = tagCap;
      source = source.slice(tagCap.index + _.length);
      if (_.startsWith("<!"))
        continue;
      const token = { source: _, type: type || Element2.Fragment, close, empty, attrs: {} };
      let attrCap;
      while (attrCap = attrRegExp.exec(attrs)) {
        const [_2, key, v1, v2 = v1, v3] = attrCap;
        if (v3) {
          token.attrs[(0, import_cosmokit.camelize)(key)] = interpolate(v3, context);
        } else if (!(0, import_cosmokit.isNullable)(v2)) {
          token.attrs[(0, import_cosmokit.camelize)(key)] = unescape(v2);
        } else if (key.startsWith("no-")) {
          token.attrs[(0, import_cosmokit.camelize)(key.slice(3))] = false;
        } else {
          token.attrs[(0, import_cosmokit.camelize)(key)] = true;
        }
      }
      tokens.push(token);
    }
    parseContent(source);
    function parseContent(source2) {
      source2 = source2.replace(/^\s*\n\s*/, "").replace(/\s*\n\s*$/, "");
      if (context) {
        let interpCap;
        while (interpCap = interpRegExp.exec(source2)) {
          const [_, expr] = interpCap;
          pushText(unescape(source2.slice(0, interpCap.index)));
          source2 = source2.slice(interpCap.index + _.length);
          const content = interpolate(expr, context);
          tokens.push(...toElementArray(content));
        }
      }
      pushText(unescape(source2));
    }
    __name(parseContent, "parseContent");
    const stack = [Element2(Element2.Fragment)];
    function rollback(index) {
      for (; index > 0; index--) {
        const { children } = stack.shift();
        const { source: source2 } = stack[0].children.pop();
        stack[0].children.push(Element2("text", { content: source2 }));
        stack[0].children.push(...children);
      }
    }
    __name(rollback, "rollback");
    for (const token of tokens) {
      if (isElement(token)) {
        stack[0].children.push(token);
      } else if (token.close) {
        let index = 0;
        while (index < stack.length && stack[index].type !== token.type)
          index++;
        if (index === stack.length) {
          stack[0].children.push(Element2("text", { content: token.source }));
        } else {
          rollback(index);
          const element = stack.shift();
          delete element.source;
        }
      } else {
        const element = Element2(token.type, token.attrs);
        stack[0].children.push(element);
        if (!token.empty) {
          element.source = token.source;
          stack.unshift(element);
        }
      }
    }
    rollback(stack.length - 1);
    return stack[0].children;
  }
  Element2.parse = parse;
  __name(parse, "parse");
  function transform(source, rules, session) {
    const elements = typeof source === "string" ? parse(source) : source;
    const output = [];
    elements.forEach((element) => {
      var _a, _b;
      const { type, attrs, children } = element;
      let result = (_b = (_a = rules[type]) != null ? _a : rules.default) != null ? _b : true;
      if (typeof result === "function") {
        result = result(attrs, children, session);
      }
      if (result === true) {
        output.push(Element2(type, attrs, transform(children, rules, session)));
      } else if (result !== false) {
        output.push(...normalize(result));
      }
    });
    return typeof source === "string" ? output.join("") : output;
  }
  Element2.transform = transform;
  __name(transform, "transform");
  async function transformAsync(source, rules, session) {
    const elements = typeof source === "string" ? parse(source) : source;
    const children = (await Promise.all(elements.map(async (element) => {
      var _a, _b;
      const { type, attrs, children: children2 } = element;
      let result = (_b = (_a = rules[type]) != null ? _a : rules.default) != null ? _b : true;
      if (typeof result === "function") {
        result = await result(attrs, children2, session);
      }
      if (result === true) {
        return [Element2(type, attrs, await transformAsync(children2, rules, session))];
      } else if (result !== false) {
        return normalize(result);
      } else {
        return [];
      }
    }))).flat(1);
    return typeof source === "string" ? children.join("") : children;
  }
  Element2.transformAsync = transformAsync;
  __name(transformAsync, "transformAsync");
  function createFactory(type, ...keys) {
    return (...args) => {
      const element = Element2(type);
      keys.forEach((key, index) => {
        if (!(0, import_cosmokit.isNullable)(args[index])) {
          element.attrs[key] = args[index];
        }
      });
      if (args[keys.length]) {
        Object.assign(element.attrs, args[keys.length]);
      }
      return element;
    };
  }
  __name(createFactory, "createFactory");
  function createAssetFactory(type) {
    return (value, attrs = {}) => {
      if ((0, import_cosmokit.is)("Buffer", value)) {
        value = "base64://" + value.toString("base64");
      } else if ((0, import_cosmokit.is)("ArrayBuffer", value)) {
        value = "base64://" + Buffer.from(value).toString("base64");
      }
      return Element2(type, { ...attrs, url: value });
    };
  }
  __name(createAssetFactory, "createAssetFactory");
  Element2.text = createFactory("text", "content");
  Element2.at = createFactory("at", "id");
  Element2.sharp = createFactory("sharp", "id");
  Element2.quote = createFactory("quote", "id");
  Element2.image = createAssetFactory("image");
  Element2.video = createAssetFactory("video");
  Element2.audio = createAssetFactory("audio");
  Element2.file = createAssetFactory("file");
})(Element || (Element = {}));
module.exports = Element;
//# sourceMappingURL=index.cjs.map
