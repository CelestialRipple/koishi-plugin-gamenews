/// <reference types="node" />
import { Awaitable, Dict } from 'cosmokit';
declare const kElement: unique symbol;
interface Element {
    [kElement]: true;
    type: string;
    attrs: Dict;
    /** @deprecated use `attrs` instead */
    data: Dict;
    children: Element[];
    source?: string;
    toString(strip?: boolean): string;
}
declare function Element(type: string, ...children: Element.Fragment[]): Element;
declare function Element(type: string, attrs: Dict, ...children: Element.Fragment[]): Element;
declare namespace Element {
    export const jsx: typeof Element;
    export const jsxs: typeof Element;
    export const jsxDEV: typeof Element;
    export const Fragment = "template";
    export type Fragment = string | Element | (string | Element)[];
    export type Render<T, S> = (attrs: Dict<any>, children: Element[], session: S) => T;
    export type Transformer<S = never> = boolean | Fragment | Render<boolean | Fragment, S>;
    export type AsyncTransformer<S = never> = boolean | Fragment | Render<Awaitable<boolean | Fragment>, S>;
    export function normalize(source: Fragment, context?: any): Element[];
    export function escape(source: string, inline?: boolean): string;
    export function unescape(source: string): string;
    export interface FindOptions {
        type?: string;
        caret?: boolean;
    }
    /** @deprecated use `Element.select()` instead */
    export function from(source: string, options?: FindOptions): Element;
    type Combinator = ' ' | '>' | '+' | '~';
    export interface Selector {
        type: string;
        combinator: Combinator;
    }
    export function parseSelector(input: string): Selector[][];
    export function select(source: string | Element[], query: string | Selector[][]): Element[];
    export function interpolate(expr: string, context: any): any;
    export function parse(source: string, context?: any): Element[];
    export function transform<S = never>(source: string, rules: Dict<Transformer<S>>, session?: S): string;
    export function transform<S = never>(source: Element[], rules: Dict<Transformer<S>>, session?: S): Element[];
    export function transformAsync<S = never>(source: string, rules: Dict<AsyncTransformer<S>>, session?: S): Promise<string>;
    export function transformAsync<S = never>(source: Element[], rules: Dict<AsyncTransformer<S>>, session?: S): Promise<Element[]>;
    export type Factory<R extends any[]> = (...args: [...rest: R, attrs?: Dict<any>]) => Element;
    export const text: Factory<[content: any]>;
    export const at: Factory<[id: any]>;
    export const sharp: Factory<[id: any]>;
    export const quote: Factory<[id: any]>;
    export const image: Factory<[data: string | Buffer | ArrayBuffer]>;
    export const video: Factory<[data: string | Buffer | ArrayBuffer]>;
    export const audio: Factory<[data: string | Buffer | ArrayBuffer]>;
    export const file: Factory<[data: string | Buffer | ArrayBuffer]>;
    export {};
}
export = Element;
