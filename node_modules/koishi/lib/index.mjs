var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// koishi/packages/koishi/src/index.ts
import { Context as Context3, Schema as Schema2 } from "@koishijs/core";
import { Router, WebSocketLayer } from "@satorijs/satori";

// koishi/packages/koishi/src/assets.ts
import { Context, Schema, segment, Service } from "@koishijs/core";
import { defineProperty } from "@koishijs/utils";
import { createHash } from "crypto";
import { basename } from "path";
import FileType from "file-type";
Context.service("assets");
defineProperty(Context.Config, "Assets", Schema.object({
  whitelist: Schema.array(Schema.string().required().role("link")).description("不处理的白名单 URL 列表。")
}).description("资源设置"));
var _Assets = class extends Service {
  constructor(ctx) {
    super(ctx, "assets");
    this.ctx = ctx;
  }
  types = _Assets.types;
  async transform(content) {
    return await segment.transformAsync(content, Object.fromEntries(this.types.map((type) => {
      return [type, async (data) => {
        if (this.ctx.root.config.assets.whitelist.some((prefix) => data.url.startsWith(prefix))) {
          return segment(type, data);
        } else {
          return segment(type, { url: await this.upload(data.url, data.file) });
        }
      }];
    })));
  }
  async analyze(url, name = "") {
    const file = await this.ctx.http.file(url);
    const buffer = Buffer.from(file.data);
    const hash = createHash("sha1").update(buffer).digest("hex");
    if (name) {
      name = basename(name);
      if (!name.startsWith(".")) {
        name = `-${name}`;
      }
    } else {
      const fileType = await FileType.fromBuffer(buffer);
      if (fileType) {
        name = `.${fileType.ext}`;
      }
    }
    return { buffer, hash, name, filename: `${hash}${name}` };
  }
};
var Assets = _Assets;
__name(Assets, "Assets");
__publicField(Assets, "types", ["image", "audio", "video"]);

// koishi/packages/koishi/src/patch.ts
import { Context as Context2 } from "@koishijs/core";
import ns from "ns-require";
var Patch = class {
  constructor(ctx) {
    ctx.root.baseDir ??= process.cwd();
  }
};
__name(Patch, "Patch");
Context2.service("$patch", Patch);
var scope = ns({
  namespace: "koishi",
  prefix: "plugin",
  official: "koishijs"
});
var plugin = Context2.prototype.plugin;
Context2.prototype.plugin = function(entry, config) {
  if (typeof entry === "string") {
    entry = scope.require(entry);
  }
  return plugin.call(this, entry, config);
};

// koishi/packages/koishi/src/index.ts
export * from "@koishijs/core";
export * from "@koishijs/utils";
Context3.Config.list.push(Schema2.object({
  assets: Context3.Config.Assets
}));
export {
  Assets,
  Patch,
  Router,
  WebSocketLayer,
  scope
};
//# sourceMappingURL=index.mjs.map
