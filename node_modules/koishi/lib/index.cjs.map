{
  "version": 3,
  "sources": ["../src/index.ts", "../src/assets.ts", "../src/patch.ts"],
  "sourcesContent": ["import { Context, Schema } from '@koishijs/core'\nimport { Assets } from './assets'\n\nexport { Router, WebSocketLayer } from '@satorijs/satori'\n\nexport * from './assets'\nexport * from './patch'\n\nexport * from '@koishijs/core'\nexport * from '@koishijs/utils'\n\ndeclare module '@satorijs/core' {\n  interface Context {\n    assets: Assets\n    cache: Cache\n  }\n}\n\nContext.Config.list.push(Schema.object({\n  assets: Context.Config.Assets,\n}))\n", "import { Context, Schema, segment, Service } from '@koishijs/core'\nimport { defineProperty } from '@koishijs/utils'\nimport { createHash } from 'crypto'\nimport { basename } from 'path'\nimport FileType from 'file-type'\n\ndeclare module '@satorijs/core' {\n  namespace Context {\n    interface Config {\n      assets?: Config.Assets\n    }\n\n    namespace Config {\n      interface Static {\n        Assets?: Schema<Assets>\n      }\n\n      interface Assets {\n        whitelist?: string[]\n      }\n    }\n  }\n}\n\nContext.service('assets')\n\ndefineProperty(Context.Config, 'Assets', Schema.object({\n  whitelist: Schema.array(Schema.string().required().role('link')).description('不处理的白名单 URL 列表。'),\n}).description('资源设置'))\n\nexport abstract class Assets extends Service {\n  static types = ['image', 'audio', 'video']\n  protected types: readonly string[] = Assets.types\n\n  abstract upload(url: string, file: string): Promise<string>\n  abstract stats(): Promise<Assets.Stats>\n\n  constructor(protected ctx: Context) {\n    super(ctx, 'assets')\n  }\n\n  public async transform(content: string) {\n    return await segment.transformAsync(content, Object.fromEntries(this.types.map((type) => {\n      return [type, async (data) => {\n        if (this.ctx.root.config.assets.whitelist.some(prefix => data.url.startsWith(prefix))) {\n          return segment(type, data)\n        } else {\n          return segment(type, { url: await this.upload(data.url, data.file) })\n        }\n      }]\n    })))\n  }\n\n  protected async analyze(url: string, name = ''): Promise<Assets.FileInfo> {\n    const file = await this.ctx.http.file(url)\n    const buffer = Buffer.from(file.data)\n    const hash = createHash('sha1').update(buffer).digest('hex')\n    if (name) {\n      name = basename(name)\n      if (!name.startsWith('.')) {\n        name = `-${name}`\n      }\n    } else {\n      const fileType = await FileType.fromBuffer(buffer)\n      if (fileType) {\n        name = `.${fileType.ext}`\n      }\n    }\n    return { buffer, hash, name, filename: `${hash}${name}` }\n  }\n}\n\nexport namespace Assets {\n  export interface Stats {\n    assetCount?: number\n    assetSize?: number\n  }\n\n  export interface FileInfo {\n    buffer: Buffer\n    hash: string\n    name: string\n    filename: string\n  }\n}\n", "import { Context } from '@koishijs/core'\nimport ns from 'ns-require'\n\ndeclare module 'cordis' {\n  interface Context {\n    plugin(path: string, config?: any): Fork<this>\n  }\n}\n\ndeclare module '@satorijs/core' {\n  interface Context {\n    baseDir: string\n  }\n}\n\nexport class Patch {\n  constructor(ctx: Context) {\n    ctx.root.baseDir ??= process.cwd()\n  }\n}\n\nContext.service('$patch', Patch)\n\nexport const scope = ns({\n  namespace: 'koishi',\n  prefix: 'plugin',\n  official: 'koishijs',\n})\n\nconst plugin = Context.prototype.plugin\nContext.prototype.plugin = function (this: Context, entry: any, config?: any) {\n  if (typeof entry === 'string') {\n    entry = scope.require(entry)\n  }\n  return plugin.call(this, entry, config)\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAA,eAAgC;AAGhC,oBAAuC;;;ACHvC,kBAAkD;AAClD,mBAA+B;AAC/B,oBAA2B;AAC3B,kBAAyB;AACzB,uBAAqB;AAoBrB,oBAAQ,QAAQ,QAAQ;AAAA,IAExB,6BAAe,oBAAQ,QAAQ,UAAU,mBAAO,OAAO;AAAA,EACrD,WAAW,mBAAO,MAAM,mBAAO,OAAO,EAAE,SAAS,EAAE,KAAK,MAAM,CAAC,EAAE,YAAY,iBAAiB;AAChG,CAAC,EAAE,YAAY,MAAM,CAAC;AAEf,IAAe,UAAf,cAA8B,oBAAQ;AAAA,EAO3C,YAAsB,KAAc;AAClC,UAAM,KAAK,QAAQ;AADC;AALtB,SAAU,QAA2B,QAAO;AAAA,EAO5C;AAAA,EAEA,MAAa,UAAU,SAAiB;AACtC,WAAO,MAAM,oBAAQ,eAAe,SAAS,OAAO,YAAY,KAAK,MAAM,IAAI,CAAC,SAAS;AACvF,aAAO,CAAC,MAAM,OAAO,SAAS;AAC5B,YAAI,KAAK,IAAI,KAAK,OAAO,OAAO,UAAU,KAAK,YAAU,KAAK,IAAI,WAAW,MAAM,CAAC,GAAG;AACrF,qBAAO,qBAAQ,MAAM,IAAI;AAAA,QAC3B,OAAO;AACL,qBAAO,qBAAQ,MAAM,EAAE,KAAK,MAAM,KAAK,OAAO,KAAK,KAAK,KAAK,IAAI,EAAE,CAAC;AAAA,QACtE;AAAA,MACF,CAAC;AAAA,IACH,CAAC,CAAC,CAAC;AAAA,EACL;AAAA,EAEA,MAAgB,QAAQ,KAAa,OAAO,IAA8B;AACxE,UAAM,OAAO,MAAM,KAAK,IAAI,KAAK,KAAK,GAAG;AACzC,UAAM,SAAS,OAAO,KAAK,KAAK,IAAI;AACpC,UAAM,WAAO,0BAAW,MAAM,EAAE,OAAO,MAAM,EAAE,OAAO,KAAK;AAC3D,QAAI,MAAM;AACR,iBAAO,sBAAS,IAAI;AACpB,UAAI,CAAC,KAAK,WAAW,GAAG,GAAG;AACzB,eAAO,IAAI;AAAA,MACb;AAAA,IACF,OAAO;AACL,YAAM,WAAW,MAAM,iBAAAC,QAAS,WAAW,MAAM;AACjD,UAAI,UAAU;AACZ,eAAO,IAAI,SAAS;AAAA,MACtB;AAAA,IACF;AACA,WAAO,EAAE,QAAQ,MAAM,MAAM,UAAU,GAAG,OAAO,OAAO;AAAA,EAC1D;AACF;AAxCO,IAAe,SAAf;AAAe;AAAA,OACb,QAAQ,CAAC,SAAS,SAAS,OAAO;;;AC/B3C,IAAAC,eAAwB;AACxB,wBAAe;AAcR,IAAM,QAAN,MAAY;AAAA,EACjB,YAAY,KAAc;AAhB5B;AAiBI,oBAAI,MAAK,YAAT,eAAS,UAAY,QAAQ,IAAI;AAAA,EACnC;AACF;AAJa;AAMb,qBAAQ,QAAQ,UAAU,KAAK;AAExB,IAAM,YAAQ,kBAAAC,SAAG;AAAA,EACtB,WAAW;AAAA,EACX,QAAQ;AAAA,EACR,UAAU;AACZ,CAAC;AAED,IAAM,SAAS,qBAAQ,UAAU;AACjC,qBAAQ,UAAU,SAAS,SAAyB,OAAY,QAAc;AAC5E,MAAI,OAAO,UAAU,UAAU;AAC7B,YAAQ,MAAM,QAAQ,KAAK;AAAA,EAC7B;AACA,SAAO,OAAO,KAAK,MAAM,OAAO,MAAM;AACxC;;;AF3BA,wBAAc,2BARd;AASA,wBAAc,4BATd;AAkBA,qBAAQ,OAAO,KAAK,KAAK,oBAAO,OAAO;AAAA,EACrC,QAAQ,qBAAQ,OAAO;AACzB,CAAC,CAAC;",
  "names": ["import_core", "FileType", "import_core", "ns"]
}
