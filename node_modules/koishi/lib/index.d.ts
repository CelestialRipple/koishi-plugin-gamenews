/// <reference types="node" />
import * as utils from '@koishijs/utils';
import * as cordis from 'cordis';
import ns from 'ns-require';
import { Dict, Awaitable, Promisify, MaybeArray } from 'cosmokit';
import { Database, Driver, Result, Update } from '@minatojs/core';
import { Disposable, GetEvents, Parameters, ReturnType, ThisType } from 'cordis';
import { version } from '../package.json';
import segment from '@satorijs/element';
import WebSocket from 'ws';
import Schema from 'schemastery';
import Logger from 'reggol';
import Quester from 'cordis-axios';
import { Agent } from 'agent-base';
import { Server } from 'net';
import { IncomingMessage, Server } from 'http';
import KoaRouter from '@koa/router';
export namespace Context {
    interface Config {
        assets?: Config.Assets;
    }
    namespace Config {
        interface Static {
            Assets?: Schema<Assets>;
        }
        interface Assets {
            whitelist?: string[];
        }
    }
}
export abstract class Assets extends Service {
    protected ctx: Context;
    static types: string[];
    protected types: readonly string[];
    abstract upload(url: string, file: string): Promise<string>;
    abstract stats(): Promise<Assets.Stats>;
    constructor(ctx: Context);
    transform(content: string): Promise<string>;
    protected analyze(url: string, name?: string): Promise<Assets.FileInfo>;
}
export namespace Assets {
    interface Stats {
        assetCount?: number;
        assetSize?: number;
    }
    interface FileInfo {
        buffer: Buffer;
        hash: string;
        name: string;
        filename: string;
    }
}
declare module 'cordis' {
    interface Context {
        plugin(path: string, config?: any): Fork<this>;
    }
}
export interface Context {
    baseDir: string;
}
export class Patch {
    constructor(ctx: Context);
}
export const scope: ns.Scope;
export * from '@koishijs/utils';
export interface Context {
    assets: Assets;
    cache: Cache;
}
/// <reference types="node" />
export interface Bot {
    getGuildMemberMap(guildId: string): Promise<Dict<string>>;
    broadcast(channels: (string | [string, string])[], content: Fragment, delay?: number): Promise<string[]>;
}
export interface Events {
    'appellation'(name: string, session: Session): string;
}
export interface Events {
    'model'(name: keyof Tables): void;
}
export interface Context {
    database: DatabaseService;
    model: DatabaseService;
    getSelfIds(type?: string, assignees?: string[]): Dict<string[]>;
    broadcast(content: Fragment, forced?: boolean): Promise<string[]>;
    broadcast(channels: readonly string[], content: Fragment, forced?: boolean): Promise<string[]>;
}
export interface User {
    id: string;
    flag: number;
    authority: number;
    name: string;
    locale: string;
}
export namespace User {
    enum Flag {
        ignore = 1
    }
    type Field = keyof User;
    const fields: Field[];
    type Observed<K extends Field = Field> = utils.Observed<Pick<User, K>, Promise<void>>;
}
export interface Channel {
    id: string;
    platform: string;
    flag: number;
    assignee: string;
    guildId: string;
    locale: string;
}
export namespace Channel {
    enum Flag {
        ignore = 1,
        silent = 4
    }
    type Field = keyof Channel;
    const fields: Field[];
    type Observed<K extends Field = Field> = utils.Observed<Pick<Channel, K>, Promise<void>>;
}
export interface Tables {
    user: User;
    channel: Channel;
}
export class DatabaseService extends Database<Tables> {
    protected app: Context;
    static readonly methods: string[];
    constructor(app: Context);
    getUser<T extends string, K extends User.Field>(platform: T, id: string, modifier?: Driver.Cursor<K>): Promise<Result<User, K> & Record<T, string>>;
    getUser<T extends string, K extends User.Field>(platform: T, ids: string[], modifier?: Driver.Cursor<K>): Promise<Result<User, K>[]>;
    setUser(platform: string, id: string, data: Update<User>): Promise<void>;
    createUser(platform: string, id: string, data: Partial<User>): Promise<User>;
    getChannel<K extends Channel.Field>(platform: string, id: string, modifier?: Driver.Cursor<K>): Promise<Result<Channel, K | 'id' | 'platform'>>;
    getChannel<K extends Channel.Field>(platform: string, ids: string[], modifier?: Driver.Cursor<K>): Promise<Result<Channel, K>[]>;
    getSelfIds(type?: string, assignees?: string[]): Dict<string[]>;
    getAssignedChannels<K extends Channel.Field>(fields?: K[], assignMap?: Dict<string[]>): Promise<Result<Channel, K>[]>;
    setChannel(platform: string, id: string, data: Update<Channel>): Promise<void>;
    createChannel(platform: string, id: string, data: Partial<Channel>): Promise<Channel>;
    broadcast(...args: [Fragment, boolean?] | [readonly string[], Fragment, boolean?]): Promise<any[]>;
}
export const defineDriver: <T>(constructor: Driver.Constructor<T>, schema?: utils.Schema, prepare?: Plugin.Function<T>) => Plugin.Object<T, any>;
export interface Context {
    $internal: Internal;
    middleware(middleware: Middleware, prepend?: boolean): () => boolean;
}
export interface Events {
    'before-attach-channel'(session: Session, fields: Set<Channel.Field>): void;
    'attach-channel'(session: Session): Awaitable<void | boolean>;
    'before-attach-user'(session: Session, fields: Set<User.Field>): void;
    'attach-user'(session: Session): Awaitable<void | boolean>;
    'before-attach'(session: Session): void;
    'attach'(session: Session): void;
    'middleware'(session: Session): void;
}
export type Next = (next?: Next.Callback) => Promise<void | Fragment>;
export type Middleware = (session: Session, next: Next) => Awaitable<void | Fragment>;
export namespace Next {
    const MAX_DEPTH = 64;
    type Queue = ((next?: Next) => Awaitable<void | Fragment>)[];
    type Callback = void | string | ((next?: Next) => Awaitable<void | Fragment>);
    function compose(callback: Callback, next?: Next): Promise<void | segment.Fragment>;
}
export namespace Internal {
    interface Config {
        nickname?: string | string[];
        prefix?: Computed<string | string[]>;
    }
}
export class Internal {
    private ctx;
    private config;
    static readonly methods: string[];
    _hooks: [Context, Middleware][];
    _nameRE: RegExp;
    _sessions: Dict<Session>;
    _userCache: SharedCache<User.Observed<any>>;
    _channelCache: SharedCache<Channel.Observed<any>>;
    constructor(ctx: Context, config: Internal.Config);
    protected get caller(): any;
    middleware(middleware: Middleware, prepend?: boolean): any;
    prepare(): void;
    private _resolvePrefixes;
    private _stripNickname;
    private _process;
    private _handleMessage;
}
export namespace SharedCache {
    interface Entry<T> {
        value: T;
        key: string;
        refs: Set<string>;
    }
}
export class SharedCache<T> {
    #private;
    get(ref: string, key: string): T;
    set(ref: string, key: string, value: T): void;
    delete(ref: string): void;
}
export interface Token {
    rest?: string;
    content: string;
    quoted: boolean;
    terminator: string;
    inters: Argv[];
}
export interface Argv<U extends User.Field = never, G extends Channel.Field = never, A extends any[] = any[], O extends {} = {}> {
    args?: A;
    options?: O;
    error?: string;
    source?: string;
    initiator?: string;
    terminator?: string;
    session?: Session<U, G>;
    command?: Command<U, G, A, O>;
    rest?: string;
    pos?: number;
    root?: boolean;
    tokens?: Token[];
    name?: string;
    next?: Next;
}
export namespace Argv {
    export interface Interpolation {
        terminator?: string;
        parse?(source: string): Argv;
    }
    export function interpolate(initiator: string, terminator: string, parse?: (source: string) => Argv): void;
    export namespace whitespace {
        const unescape: (source: string) => string;
        const escape: (source: string) => string;
    }
    export class Tokenizer {
        private bracs;
        constructor();
        interpolate(initiator: string, terminator: string, parse?: (source: string) => Argv): void;
        parseToken(source: string, stopReg?: string): Token;
        parse(source: string, terminator?: string): Argv;
        stringify(argv: Argv): string;
    }
    export function parse(source: string, terminator?: string): Argv<never, never, any[], {}>;
    export function stringify(argv: Argv): string;
    export function revert(token: Token): void;
    export interface Domain {
        string: string;
        number: number;
        boolean: boolean;
        text: string;
        rawtext: string;
        user: string;
        channel: string;
        integer: number;
        posint: number;
        natural: number;
        date: Date;
    }
    type DomainType = keyof Domain;
    type ParamType<S extends string, F> = S extends `${any}:${infer T}` ? T extends DomainType ? Domain[T] : F : F;
    type Replace<S extends string, X extends string, Y extends string> = S extends `${infer L}${X}${infer R}` ? `${L}${Y}${Replace<R, X, Y>}` : S;
    type ExtractAll<S extends string, F> = S extends `${infer L}]${infer R}` ? [ParamType<L, F>, ...ExtractAll<R, F>] : [];
    type ExtractFirst<S extends string, F> = S extends `${infer L}]${any}` ? ParamType<L, F> : boolean;
    type ExtractSpread<S extends string> = S extends `${infer L}...${infer R}` ? [...ExtractAll<L, string>, ...ExtractFirst<R, string>[]] : [...ExtractAll<S, string>, ...string[]];
    export type ArgumentType<S extends string> = ExtractSpread<Replace<S, '>', ']'>>;
    export type OptionType<S extends string> = ExtractFirst<Replace<S, '>', ']'>, any>;
    export type Type = DomainType | RegExp | readonly string[] | Transform<any>;
    export interface Declaration {
        name?: string;
        type?: Type;
        fallback?: any;
        variadic?: boolean;
        required?: boolean;
    }
    export type Transform<T> = (source: string, session: Session) => T;
    export interface DomainConfig<T> {
        transform?: Transform<T>;
        greedy?: boolean;
    }
    export function createDomain<K extends keyof Domain>(name: K, transform: Transform<Domain[K]>, options?: DomainConfig<Domain[K]>): void;
    export function parseValue(source: string, quoted: boolean, kind: string, argv: Argv, decl?: Declaration): any;
    export interface OptionConfig<T extends Type = Type> {
        value?: any;
        fallback?: any;
        type?: T;
        authority?: number;
        descPath?: string;
    }
    export interface TypedOptionConfig<T extends Type> extends OptionConfig<T> {
        type: T;
    }
    export interface OptionVariant extends OptionConfig {
        syntax: string;
    }
    export interface OptionDeclaration extends Declaration, OptionVariant {
        values: Dict<any>;
        /** @deprecated */
        valuesSyntax: Dict<string>;
        variants: Dict<OptionVariant>;
    }
    type OptionDeclarationMap = Dict<OptionDeclaration>;
    export class CommandBase {
        readonly name: string;
        ctx: Context;
        declaration: string;
        _arguments: Declaration[];
        _options: OptionDeclarationMap;
        private _namedOptions;
        private _symbolicOptions;
        constructor(name: string, declaration: string, ctx: Context);
        _createOption(name: string, def: string, config: OptionConfig): void;
        private _assignOption;
        removeOption<K extends string>(name: K): boolean;
        parse(argv: string | Argv, terminator?: string, args?: any[], options?: Dict<any>): Argv;
        private stringifyArg;
        stringify(args: readonly string[], options: any): string;
    }
}
export type Extend<O extends {}, K extends string, T> = {
    [P in K | keyof O]?: (P extends keyof O ? O[P] : unknown) & (P extends K ? T : unknown);
};
export interface CommandService {
}
export namespace Command {
    interface Shortcut {
        name?: string | RegExp;
        command?: Command;
        prefix?: boolean;
        fuzzy?: boolean;
        args?: string[];
        options?: Dict;
    }
    type Action<U extends User.Field = never, G extends Channel.Field = never, A extends any[] = any[], O extends {} = {}> = (argv: Argv<U, G, A, O>, ...args: A) => Awaitable<void | Fragment>;
    type Usage<U extends User.Field = never, G extends Channel.Field = never> = string | ((session: Session<U, G>) => Awaitable<string>);
}
export class Command<U extends User.Field = never, G extends Channel.Field = never, A extends any[] = any[], O extends {} = {}> extends Argv.CommandBase {
    config: Command.Config;
    children: Command[];
    parent: Command;
    _aliases: string[];
    _examples: string[];
    _usage?: Command.Usage;
    _disposed?: boolean;
    _disposables?: Disposable[];
    private _userFields;
    private _channelFields;
    private _actions;
    private _checkers;
    static defaultConfig: Command.Config;
    static defaultOptionConfig: Argv.OptionConfig;
    private static _userFields;
    private static _channelFields;
    /** @deprecated use `command-added` event instead */
    static userFields(fields: FieldCollector<'user'>): typeof Command;
    /** @deprecated use `command-added` event instead */
    static channelFields(fields: FieldCollector<'channel'>): typeof Command;
    constructor(name: string, decl: string, ctx: Context);
    get displayName(): string;
    set displayName(name: string);
    private _registerAlias;
    userFields<T extends User.Field = never>(fields: FieldCollector<'user', T, A, O>): Command<U | T, G, A, O>;
    channelFields<T extends Channel.Field = never>(fields: FieldCollector<'channel', T, A, O>): Command<U, G | T, A, O>;
    alias(...names: string[]): this;
    shortcut(name: string | RegExp, config?: Command.Shortcut): this;
    subcommand<D extends string>(def: D, config?: Command.Config): Command<never, never, Argv.ArgumentType<D>>;
    subcommand<D extends string>(def: D, desc: string, config?: Command.Config): Command<never, never, Argv.ArgumentType<D>>;
    usage(text: Command.Usage<U, G>): this;
    example(example: string): this;
    option<K extends string>(name: K, desc: string, config: Argv.TypedOptionConfig<RegExp>): Command<U, G, A, Extend<O, K, string>>;
    option<K extends string, R>(name: K, desc: string, config: Argv.TypedOptionConfig<(source: string) => R>): Command<U, G, A, Extend<O, K, R>>;
    option<K extends string, R extends string>(name: K, desc: string, config: Argv.TypedOptionConfig<R[]>): Command<U, G, A, Extend<O, K, R>>;
    option<K extends string, D extends string>(name: K, desc: D, config?: Argv.OptionConfig): Command<U, G, A, Extend<O, K, Argv.OptionType<D>>>;
    match(session: Session): boolean;
    getConfig<K extends keyof Command.Config>(key: K, session: Session): Exclude<Command.Config[K], (session: Session) => any>;
    check(callback: Command.Action<U, G, A, O>, append?: boolean): this;
    before(callback: Command.Action<U, G, A, O>, append?: boolean): this;
    action(callback: Command.Action<U, G, A, O>, prepend?: boolean): this;
    use<T extends Command, R extends any[]>(callback: (command: this, ...args: R) => T, ...args: R): T;
    execute(argv: Argv<U, G, A, O>, fallback?: typeof Next.compose): Promise<Fragment>;
    dispose(): void;
}
export namespace Command {
    interface Config {
        /** min authority */
        authority?: Computed<number>;
        /** disallow unknown options */
        checkUnknown?: boolean;
        /** check argument count */
        checkArgCount?: boolean;
        /** show command warnings */
        showWarning?: boolean;
        /** depend on existing commands */
        patch?: boolean;
    }
    const Config: Schema<Config>;
}
export interface CommandMap extends Map<string, Command> {
    resolve(key: string): Command;
}
export interface Context {
    $commander: Commander;
    command<D extends string>(def: D, config?: Command.Config): Command<never, never, Argv.ArgumentType<D>>;
    command<D extends string>(def: D, desc: string, config?: Command.Config): Command<never, never, Argv.ArgumentType<D>>;
}
export interface Events {
    'before-parse'(content: string, session: Session): Argv;
    'command-added'(command: Command): void;
    'command-removed'(command: Command): void;
    'command-error'(argv: Argv, error: any): void;
    'command/before-execute'(argv: Argv): Awaitable<void | string>;
    'command/before-attach-channel'(argv: Argv, fields: Set<Channel.Field>): void;
    'command/before-attach-user'(argv: Argv, fields: Set<User.Field>): void;
}
export namespace Commander {
    interface Config {
    }
}
export class Commander {
    private ctx;
    private config;
    static readonly key = "$commander";
    static readonly methods: string[];
    _commandList: Command[];
    _commands: CommandMap;
    _shortcuts: Command.Shortcut[];
    constructor(ctx: Context, config?: Commander.Config);
    protected get caller(): any;
    resolve(key: string): Command<never, never, any[], {}>;
    getCommand(name: string): Command<never, never, any[], {}>;
    command(def: string, ...args: [Command.Config?] | [string, Command.Config?]): any;
}
export interface Session<U extends User.Field = never, G extends Channel.Field = never> {
    argv?: Argv<U, G>;
    user?: User.Observed<U>;
    channel?: Channel.Observed<G>;
    guild?: Channel.Observed<G>;
    parsed?: Parsed;
    scope?: string;
    username?: string;
    send(content: Fragment, options?: SendOptions): Promise<string[]>;
    cancelQueued(delay?: number): void;
    sendQueued(content: Fragment, delay?: number): Promise<string[]>;
    resolveValue<T>(source: T | ((session: Session) => T)): T;
    getChannel<K extends Channel.Field = never>(id?: string, fields?: K[]): Promise<Channel>;
    observeChannel<T extends Channel.Field = never>(fields?: Iterable<T>): Promise<Channel.Observed<T | G>>;
    getUser<K extends User.Field = never>(id?: string, fields?: K[]): Promise<User>;
    observeUser<T extends User.Field = never>(fields?: Iterable<T>): Promise<User.Observed<T | U>>;
    withScope<T>(scope: string, callback: () => T): Promisify<T>;
    text(path: string | string[], params?: object): string;
    collect<T extends 'user' | 'channel'>(key: T, argv: Argv, fields?: Set<keyof Tables[T]>): Set<keyof Tables[T]>;
    inferCommand(argv: Argv): Command;
    resolve(argv: Argv): Command;
    execute(content: string, next?: true | Next): Promise<string>;
    execute(argv: Argv, next?: true | Next): Promise<string>;
    middleware(middleware: Middleware): () => boolean;
    prompt(timeout?: number): Promise<string>;
}
export namespace Session {
    interface Private extends Session {
        _queuedTasks: Task[];
        _queuedTimeout: NodeJS.Timeout;
        _next(): void;
        _observeChannelLike<T extends Channel.Field = never>(channelId: string, fields: Iterable<T>): Promise<any>;
    }
}
export interface Parsed {
    content: string;
    prefix: string;
    appel: boolean;
}
export type Computed<T> = T | ((session: Session) => T);
export interface Task {
    delay: number;
    content: Fragment;
    resolve(ids: string[]): void;
    reject(reason: any): void;
}
export function getSessionId(session: Session): string;
export type FieldCollector<T extends keyof Tables, K = keyof Tables[T], A extends any[] = any[], O = {}> = Iterable<K> | ((argv: Argv<never, never, A, O>, fields: Set<keyof Tables[T]>) => void);
export type Plugin = cordis.Plugin<Context>;
export namespace Plugin {
    type Function<T = any> = cordis.Plugin.Function<T, Context>;
    type Constructor<T = any> = cordis.Plugin.Constructor<T, Context>;
    type Object<S = any, T = any> = cordis.Plugin.Object<S, T, Context>;
}
export type State = cordis.State<Context>;
export type Fork = cordis.Fork<Context>;
export type Runtime = cordis.Runtime<Context>;
export type Service = cordis.Service<Context>;
export const Service: {
    new (ctx: Context, name: string, immediate?: boolean): cordis.Service<Context>;
};
export { resolveConfig } from 'cordis';
export type { Disposable } from 'cordis';
export interface Context {
}
export namespace Context {
    interface Config extends Config.Basic, Config.Message, Config.Advanced {
    }
    namespace Config {
        interface Basic {
            locale?: string;
            prefix?: Computed<string | string[]>;
            nickname?: string | string[];
            autoAssign?: Computed<Awaitable<boolean>>;
            autoAuthorize?: Computed<Awaitable<number>>;
        }
        interface Message {
            delay?: DelayConfig;
        }
        interface DelayConfig {
            character?: number;
            message?: number;
            cancel?: number;
            broadcast?: number;
            prompt?: number;
        }
        interface Advanced {
            maxListeners?: number;
            prettyErrors?: boolean;
        }
        interface Static extends Schema<Config> {
            Basic: Schema<Basic>;
            Message: Schema<Message>;
            Advanced: Schema<Advanced>;
        }
    }
}
export { Context as App };
export function defineConfig(config: Context.Config): Context.Config;
declare const kTemplate: unique symbol;
export interface Context {
    i18n: I18n;
}
export namespace I18n {
    type Node = string | Store;
    interface Store {
        [kTemplate]?: string;
        [K: string]: Node;
    }
    type Formatter = (value: any, args: string[], locale: string) => string;
    type Renderer = (dict: Dict, params: any, locale: string) => string;
}
export class I18n {
    _data: Dict<I18n.Store>;
    _formatters: Dict<I18n.Formatter>;
    _presets: Dict<I18n.Renderer>;
    constructor(ctx: Context);
    private set;
    define(locale: string, dict: I18n.Store): void;
    define(locale: string, key: string, value: I18n.Node): void;
    formatter(name: string, callback: I18n.Formatter): void;
    preset(name: string, callback: I18n.Renderer): void;
    render(value: I18n.Node, params: any, locale: string): string;
    text(locales: Iterable<string>, paths: string[], params: object): string;
    private registerBuiltins;
}
export interface Context {
    /** @deprecated use `ctx.root` instead */
    app: Context;
    /** @deprecated use `root.config` instead */
    options: Context.Config;
    logger(name: string): Logger;
    waterfall<K extends keyof GetEvents<this>>(name: K, ...args: Parameters<GetEvents<this>[K]>): Promisify<ReturnType<GetEvents<this>[K]>>;
    waterfall<K extends keyof GetEvents<this>>(thisArg: ThisType<GetEvents<this>[K]>, name: K, ...args: Parameters<GetEvents<this>[K]>): Promisify<ReturnType<GetEvents<this>[K]>>;
    chain<K extends keyof GetEvents<this>>(name: K, ...args: Parameters<GetEvents<this>[K]>): ReturnType<GetEvents<this>[K]>;
    chain<K extends keyof GetEvents<this>>(thisArg: ThisType<GetEvents<this>[K]>, name: K, ...args: Parameters<GetEvents<this>[K]>): ReturnType<GetEvents<this>[K]>;
    before<K extends BeforeEventName>(name: K, listener: BeforeEventMap[K], append?: boolean): () => boolean;
    setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]): () => boolean;
    setInterval(callback: (...args: any[]) => void, ms: number, ...args: any[]): () => boolean;
}
export namespace Context {
    interface Private extends Context {
        createTimerDispose(timer: NodeJS.Timeout): () => boolean;
    }
}
type OmitSubstring<S extends string, T extends string> = S extends `${infer L}${T}${infer R}` ? `${L}${R}` : never;
type BeforeEventName = OmitSubstring<keyof Events & string, 'before-'>;
export type BeforeEventMap = {
    [E in keyof Events & string as OmitSubstring<E, 'before-'>]: Events[E];
};
export * from '@koishijs/utils';
export * from '@minatojs/core';
export { version };
/// <reference types="ws" />
export namespace Universal {
    interface Methods {
        sendMessage(channelId: string, content: segment.Fragment, guildId?: string, options?: SendOptions): Promise<string[]>;
        sendPrivateMessage(userId: string, content: segment.Fragment, options?: SendOptions): Promise<string[]>;
        getMessage(channelId: string, messageId: string): Promise<Message>;
        getMessageList(channelId: string, before?: string): Promise<Message[]>;
        editMessage(channelId: string, messageId: string, content: segment.Fragment): Promise<void>;
        deleteMessage(channelId: string, messageId: string): Promise<void>;
        getSelf(): Promise<User>;
        getUser(userId: string): Promise<User>;
        getFriendList(): Promise<User[]>;
        deleteFriend(userId: string): Promise<void>;
        getGuild(guildId: string): Promise<Guild>;
        getGuildList(): Promise<Guild[]>;
        getGuildMember(guildId: string, userId: string): Promise<GuildMember>;
        getGuildMemberList(guildId: string): Promise<GuildMember[]>;
        kickGuildMember(guildId: string, userId: string, permanent?: boolean): Promise<void>;
        muteGuildMember(guildId: string, userId: string, duration: number, reason?: string): Promise<void>;
        getChannel(channelId: string, guildId?: string): Promise<Channel>;
        getChannelList(guildId: string): Promise<Channel[]>;
        muteChannel(channelId: string, guildId?: string, enable?: boolean): Promise<void>;
        handleFriendRequest(messageId: string, approve: boolean, comment?: string): Promise<void>;
        handleGuildRequest(messageId: string, approve: boolean, comment?: string): Promise<void>;
        handleGuildMemberRequest(messageId: string, approve: boolean, comment?: string): Promise<void>;
    }
    interface Channel {
        channelId: string;
        channelName?: string;
    }
    interface Guild {
        guildId: string;
        guildName?: string;
    }
    interface UserBase {
        username?: string;
        nickname?: string;
        avatar?: string;
        discriminator?: string;
        isBot?: boolean;
    }
    interface User extends UserBase {
        userId: string;
    }
    interface GuildMember extends User {
        roles?: string[];
    }
    interface Author extends GuildMember {
        anonymous?: string;
    }
    interface Role {
        id: string;
    }
    interface MessageBase {
        messageId?: string;
        channelId?: string;
        guildId?: string;
        userId?: string;
        content?: string;
        elements?: segment[];
        timestamp?: number;
        author?: Author;
        quote?: Message;
    }
    interface Message extends MessageBase {
        subtype?: string;
    }
}
export interface SendOptions {
    session?: Session;
}
export interface Session extends Session.Payload {
}
export namespace Session {
    interface Payload {
        platform: string;
        selfId: string;
        type?: string;
        subtype?: string;
        subsubtype?: string;
        messageId?: string;
        channelId?: string;
        guildId?: string;
        userId?: string;
        content?: string;
        elements?: segment[];
        timestamp?: number;
        author?: Universal.Author;
        quote?: Universal.Message;
        channelName?: string;
        guildName?: string;
        operatorId?: string;
        targetId?: string;
        duration?: number;
    }
    type EventCallback<T = void> = (this: Session, session: Session) => T;
}
export class Session {
    id: string;
    bot: Bot;
    app: Context;
    constructor(bot: Bot, payload?: Partial<Session.Payload>);
    initialize(): void;
    get uid(): string;
    get gid(): string;
    get cid(): string;
    get sid(): string;
    get content(): string;
    set content(value: string);
    toJSON(): Session.Payload;
}
export interface Bot extends Universal.Methods, Universal.User {
    socket?: WebSocket;
}
export abstract class Bot<T extends Bot.Config = Bot.Config> {
    ctx: Context;
    config: T;
    static reusable: boolean;
    isBot: boolean;
    hidden: boolean;
    platform: string;
    selfId: string;
    internal?: any;
    adapter?: Adapter<this>;
    error?: Error;
    protected context: Context;
    protected _status: Bot.Status;
    constructor(ctx: Context, config: T);
    get status(): Bot.Status;
    set status(value: Bot.Status);
    online(): void;
    offline(error?: Error): void;
    start(): Promise<void>;
    stop(): Promise<void>;
    get sid(): string;
    session(payload?: Partial<Session.Payload>): Session;
    dispatch(session: Session): void;
}
export namespace Bot {
    interface Config {
        platform?: string;
        selfId?: string;
    }
    type Status = 'offline' | 'online' | 'connect' | 'disconnect' | 'reconnect';
}
export type Filter = (session: Session) => boolean;
export interface Context {
    selector: Selector;
    filter: Filter;
    any(): this;
    never(): this;
    union(arg: Filter | this): this;
    intersect(arg: Filter | this): this;
    exclude(arg: Filter | this): this;
    user(...values: string[]): this;
    self(...values: string[]): this;
    guild(...values: string[]): this;
    channel(...values: string[]): this;
    platform(...values: string[]): this;
    private(...values: string[]): this;
}
export class Selector {
    private app;
    static readonly methods: string[];
    constructor(app: Context);
    protected get caller(): Context;
    any(): Context;
    never(): Context;
    union(arg: Filter | Context): Context;
    intersect(arg: Filter | Context): Context;
    exclude(arg: Filter | Context): Context;
    user(...values: string[]): Context;
    self(...values: string[]): Context;
    guild(...values: string[]): Context;
    channel(...values: string[]): Context;
    platform(...values: string[]): Context;
    private(...values: string[]): Context;
}
export abstract class Modulator<B extends Bot = Bot> {
    bot: B;
    channelId: string;
    guildId?: string;
    options?: SendOptions;
    errors: Error[];
    results: Session[];
    session: Session;
    constructor(bot: B, channelId: string, guildId?: string, options?: SendOptions);
    abstract flush(): Promise<void>;
    abstract visit(element: segment): Promise<void>;
    render(elements: segment[], flush?: boolean): Promise<void>;
    send(content: segment.Fragment): Promise<string[]>;
}
export { Schema, Logger, segment, segment as h, Quester };
type Genres = 'friend' | 'channel' | 'guild' | 'guild-member' | 'guild-role' | 'guild-file' | 'guild-emoji';
type Actions = 'added' | 'deleted' | 'updated';
export interface Events<C extends Context = Context> extends cordis.Events<C>, Record<`${Genres}-${Actions}`, Session.EventCallback> {
    'message': Session.EventCallback;
    'message-deleted': Session.EventCallback;
    'message-updated': Session.EventCallback;
    'reaction-added': Session.EventCallback;
    'reaction-deleted': Session.EventCallback;
    'reaction-deleted/one': Session.EventCallback;
    'reaction-deleted/all': Session.EventCallback;
    'reaction-deleted/emoji': Session.EventCallback;
    'send': Session.EventCallback;
    'friend-request': Session.EventCallback;
    'guild-request': Session.EventCallback;
    'guild-member-request': Session.EventCallback;
    'guild-member/role': Session.EventCallback;
    'guild-member/ban': Session.EventCallback;
    'guild-member/nickname': Session.EventCallback;
    'notice/poke': Session.EventCallback;
    'notice/lucky-king': Session.EventCallback;
    'notice/honor': Session.EventCallback;
    'notice/honor/talkative': Session.EventCallback;
    'notice/honor/performer': Session.EventCallback;
    'notice/honor/emotion': Session.EventCallback;
    'before-send': Session.EventCallback<Awaitable<void | boolean>>;
    'bot-added'(client: Bot): void;
    'bot-removed'(client: Bot): void;
    'bot-status-updated'(client: Bot): void;
    'bot-connect'(client: Bot): Awaitable<void>;
    'bot-disconnect'(client: Bot): Awaitable<void>;
}
export interface Context {
    [Context.config]: Context.Config;
    [Context.events]: Events<this>;
    bots: Bot[] & Dict<Bot> & {
        counter: number;
    };
}
export type Fragment = segment.Fragment;
export type Render = segment.Render<Awaitable<Fragment>, Session>;
export class Context extends cordis.Context {
    static readonly session: unique symbol;
    _components: Dict<Render>;
    constructor(options?: Context.Config);
    logger(name: string): Logger;
    component(name: string, render: Render): void;
}
export namespace Context {
    export interface Config extends cordis.Context.Config {
    }
    export const Config: Config.Static;
    namespace Config {
        interface Static extends Schema<Config> {
        }
    }
}
export abstract class Adapter<T extends Bot = Bot> {
    static schema: boolean;
    start(bot: T): Promise<void>;
    stop(bot: T): Promise<void>;
}
export namespace Adapter {
    abstract class Client<T extends Bot = Bot> extends Adapter<T> {
        protected ctx: Context;
        protected bot: T;
        static reusable: boolean;
        constructor(ctx: Context, bot: T);
    }
    abstract class Server<T extends Bot = Bot> extends Adapter<T> {
        bots: T[];
        fork(ctx: Context, bot: T): void;
    }
    namespace WsClient {
        interface Config extends Bot.Config {
            retryLazy?: number;
            retryTimes?: number;
            retryInterval?: number;
        }
    }
    abstract class WsClient<T extends Bot<WsClient.Config>> extends Adapter.Client<T> {
        static reusable: boolean;
        static Config: Schema<Adapter.WsClient.Config>;
        protected abstract prepare(bot: T): Awaitable<WebSocket>;
        protected abstract accept(bot: T): void;
        start(bot: T): Promise<void>;
        stop(bot: T): Promise<void>;
    }
}
/// <reference types="node" />
/// <reference types="ws" />
/// <reference types="node" />
/// <reference types="koa__router" />
type CreateAgent = (opts: string) => Agent;
export function register(protocols: string[], callback: CreateAgent): void;
export function getAgent(url: string): Agent;
export interface ListenOptions {
    host?: string;
    port?: number;
    maxPort?: number;
}
export function listen(server: Server, { host, port, maxPort }: ListenOptions): Promise<number>;
declare module 'koa' {
    interface Request {
        body?: any;
        rawBody?: string;
    }
}
export interface Context {
    router: Router;
}
type WebSocketCallback = (socket: WebSocket, request: IncomingMessage) => void;
export class WebSocketLayer {
    private router;
    callback?: WebSocketCallback;
    clients: Set<WebSocket>;
    regexp: RegExp;
    constructor(router: Router, path: MaybeArray<string | RegExp>, callback?: WebSocketCallback);
    accept(socket: WebSocket, request: IncomingMessage): boolean;
    close(): void;
}
export class Router extends KoaRouter {
    _http?: Server;
    _ws?: WebSocket.Server;
    wsStack: WebSocketLayer[];
    constructor(ctx: Context);
    /**
     * hack into router methods to make sure that koa middlewares are disposable
     */
    register(...args: Parameters<KoaRouter['register']>): KoaRouter.Layer;
    ws(path: MaybeArray<string | RegExp>, callback?: WebSocketCallback): WebSocketLayer;
}
export * from 'cosmokit';
export namespace Context {
    interface Config extends Config.Network {
    }
    namespace Config {
        interface Network {
            host?: string;
            port?: number;
            maxPort?: number;
            selfUrl?: string;
        }
        interface Static extends Schema<Config> {
            Network: Schema<Network>;
        }
    }
}
