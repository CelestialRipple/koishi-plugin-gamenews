{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["interface Random {\n  id(length?: number, radix?: number): string\n  bool(probability: number): boolean\n  real(upper: number): number\n  real(lower: number, upper: number): number\n  int(upper: number): number\n  int(lower: number, upper: number): number\n  splice<T>(source: T[]): T\n  pick<T>(source: readonly T[]): T\n  pick<T>(source: readonly T[], count: number): T[]\n  shuffle<T>(source: readonly T[]): T[]\n  weightedPick<T extends string>(weights: Readonly<Record<T, number>>): T\n}\n\nnamespace Random {\n  export interface Static extends Random {\n    chars: string\n    new (get?: () => number): Random\n  }\n}\n\nclass Random {\n  static chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\n  constructor(private get = Math.random) {}\n\n  id(length = 8, radix = 16) {\n    let result = ''\n    for (let i = 0; i < length; ++i) {\n      result += Random.chars[Math.floor(Math.random() * radix)]\n    }\n    return result\n  }\n\n  bool(probability: number) {\n    if (probability >= 1) return true\n    if (probability <= 0) return false\n    return this.get() < probability\n  }\n\n  real(...args: [number, number?]): number {\n    const lower = args.length > 1 ? args[0] : 0\n    const upper = args[args.length - 1]\n    return this.get() * (upper - lower) + lower\n  }\n\n  int(...args: [number, number?]): number {\n    return Math.floor(this.real(...args))\n  }\n\n  splice<T>(source: T[]) {\n    return source.splice(Math.floor(this.get() * source.length), 1)[0]\n  }\n\n  pick<T>(source: readonly T[], count?: number) {\n    if (count === undefined) return this.pick(source, 1)[0]\n    const copy = source.slice()\n    const result: T[] = []\n    count = Math.min(copy.length, count)\n    for (let i = 0; i < count; i += 1) {\n      result.push(this.splice(copy))\n    }\n    return result\n  }\n\n  shuffle<T>(source: readonly T[]) {\n    return this.pick(source, source.length)\n  }\n\n  weightedPick<T extends string>(weights: Readonly<Record<T, number>>): T {\n    const total = Object.entries(weights).reduce((prev, [, curr]) => prev + (curr as number), 0)\n    const pointer = this.get() * total\n    let counter = 0\n    for (const key in weights) {\n      counter += weights[key]\n      if (pointer < counter) return key\n    }\n  }\n}\n\nconst instance = new Random()\n\nfor (const key of ['id', 'bool', 'int', 'real', 'splice', 'pick', 'shuffle', 'weightedPick']) {\n  Random[key] = instance[key].bind(instance)\n}\n\nexport = Random as Random.Static\n"],
  "mappings": ";;;;;;;;;;;;;AAAA;AAAA;AAqBA,QAAM,UAAN,MAAa;AAAA,MAGX,YAAoB,MAAM,KAAK,QAAQ;AAAnB;AAAA,MAAoB;AAAA,MAExC,GAAG,SAAS,GAAG,QAAQ,IAAI;AACzB,YAAI,SAAS;AACb,iBAAS,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAC/B,oBAAU,QAAO,MAAM,KAAK,MAAM,KAAK,OAAO,IAAI,KAAK;AAAA,QACzD;AACA,eAAO;AAAA,MACT;AAAA,MAEA,KAAK,aAAqB;AACxB,YAAI,eAAe;AAAG,iBAAO;AAC7B,YAAI,eAAe;AAAG,iBAAO;AAC7B,eAAO,KAAK,IAAI,IAAI;AAAA,MACtB;AAAA,MAEA,QAAQ,MAAiC;AACvC,cAAM,QAAQ,KAAK,SAAS,IAAI,KAAK,KAAK;AAC1C,cAAM,QAAQ,KAAK,KAAK,SAAS;AACjC,eAAO,KAAK,IAAI,KAAK,QAAQ,SAAS;AAAA,MACxC;AAAA,MAEA,OAAO,MAAiC;AACtC,eAAO,KAAK,MAAM,KAAK,KAAK,GAAG,IAAI,CAAC;AAAA,MACtC;AAAA,MAEA,OAAU,QAAa;AACrB,eAAO,OAAO,OAAO,KAAK,MAAM,KAAK,IAAI,IAAI,OAAO,MAAM,GAAG,CAAC,EAAE;AAAA,MAClE;AAAA,MAEA,KAAQ,QAAsB,OAAgB;AAC5C,YAAI,UAAU;AAAW,iBAAO,KAAK,KAAK,QAAQ,CAAC,EAAE;AACrD,cAAM,OAAO,OAAO,MAAM;AAC1B,cAAM,SAAc,CAAC;AACrB,gBAAQ,KAAK,IAAI,KAAK,QAAQ,KAAK;AACnC,iBAAS,IAAI,GAAG,IAAI,OAAO,KAAK,GAAG;AACjC,iBAAO,KAAK,KAAK,OAAO,IAAI,CAAC;AAAA,QAC/B;AACA,eAAO;AAAA,MACT;AAAA,MAEA,QAAW,QAAsB;AAC/B,eAAO,KAAK,KAAK,QAAQ,OAAO,MAAM;AAAA,MACxC;AAAA,MAEA,aAA+B,SAAyC;AACtE,cAAM,QAAQ,OAAO,QAAQ,OAAO,EAAE,OAAO,CAAC,MAAM,CAAC,EAAE,IAAI,MAAM,OAAQ,MAAiB,CAAC;AAC3F,cAAM,UAAU,KAAK,IAAI,IAAI;AAC7B,YAAI,UAAU;AACd,mBAAW,OAAO,SAAS;AACzB,qBAAW,QAAQ;AACnB,cAAI,UAAU;AAAS,mBAAO;AAAA,QAChC;AAAA,MACF;AAAA,IACF;AAzDA,QAAM,SAAN;AAAM;AACJ,kBADI,QACG,SAAQ;AA0DjB,QAAM,WAAW,IAAI,OAAO;AAE5B,eAAW,OAAO,CAAC,MAAM,QAAQ,OAAO,QAAQ,UAAU,QAAQ,WAAW,cAAc,GAAG;AAC5F,aAAO,OAAO,SAAS,KAAK,KAAK,QAAQ;AAAA,IAC3C;AAEA,qBAAS;AAAA;AAAA;",
  "names": []
}
