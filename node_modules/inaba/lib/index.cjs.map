{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["interface Random {\n  id(length?: number, radix?: number): string\n  bool(probability: number): boolean\n  real(upper: number): number\n  real(lower: number, upper: number): number\n  int(upper: number): number\n  int(lower: number, upper: number): number\n  splice<T>(source: T[]): T\n  pick<T>(source: readonly T[]): T\n  pick<T>(source: readonly T[], count: number): T[]\n  shuffle<T>(source: readonly T[]): T[]\n  weightedPick<T extends string>(weights: Readonly<Record<T, number>>): T\n}\n\nnamespace Random {\n  export interface Static extends Random {\n    chars: string\n    new (get?: () => number): Random\n  }\n}\n\nclass Random {\n  static chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\n  constructor(private get = Math.random) {}\n\n  id(length = 8, radix = 16) {\n    let result = ''\n    for (let i = 0; i < length; ++i) {\n      result += Random.chars[Math.floor(Math.random() * radix)]\n    }\n    return result\n  }\n\n  bool(probability: number) {\n    if (probability >= 1) return true\n    if (probability <= 0) return false\n    return this.get() < probability\n  }\n\n  real(...args: [number, number?]): number {\n    const lower = args.length > 1 ? args[0] : 0\n    const upper = args[args.length - 1]\n    return this.get() * (upper - lower) + lower\n  }\n\n  int(...args: [number, number?]): number {\n    return Math.floor(this.real(...args))\n  }\n\n  splice<T>(source: T[]) {\n    return source.splice(Math.floor(this.get() * source.length), 1)[0]\n  }\n\n  pick<T>(source: readonly T[], count?: number) {\n    if (count === undefined) return this.pick(source, 1)[0]\n    const copy = source.slice()\n    const result: T[] = []\n    count = Math.min(copy.length, count)\n    for (let i = 0; i < count; i += 1) {\n      result.push(this.splice(copy))\n    }\n    return result\n  }\n\n  shuffle<T>(source: readonly T[]) {\n    return this.pick(source, source.length)\n  }\n\n  weightedPick<T extends string>(weights: Readonly<Record<T, number>>): T {\n    const total = Object.entries(weights).reduce((prev, [, curr]) => prev + (curr as number), 0)\n    const pointer = this.get() * total\n    let counter = 0\n    for (const key in weights) {\n      counter += weights[key]\n      if (pointer < counter) return key\n    }\n  }\n}\n\nconst instance = new Random()\n\nfor (const key of ['id', 'bool', 'int', 'real', 'splice', 'pick', 'shuffle', 'weightedPick']) {\n  Random[key] = instance[key].bind(instance)\n}\n\nexport = Random as Random.Static\n"],
  "mappings": ";;;;AAqBA,IAAM,UAAN,MAAa;AAAA,EAGX,YAAoB,MAAM,KAAK,QAAQ;AAAnB;AAAA,EAAoB;AAAA,EAExC,GAAG,SAAS,GAAG,QAAQ,IAAI;AACzB,QAAI,SAAS;AACb,aAAS,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAC/B,gBAAU,QAAO,MAAM,KAAK,MAAM,KAAK,OAAO,IAAI,KAAK;AAAA,IACzD;AACA,WAAO;AAAA,EACT;AAAA,EAEA,KAAK,aAAqB;AACxB,QAAI,eAAe;AAAG,aAAO;AAC7B,QAAI,eAAe;AAAG,aAAO;AAC7B,WAAO,KAAK,IAAI,IAAI;AAAA,EACtB;AAAA,EAEA,QAAQ,MAAiC;AACvC,UAAM,QAAQ,KAAK,SAAS,IAAI,KAAK,KAAK;AAC1C,UAAM,QAAQ,KAAK,KAAK,SAAS;AACjC,WAAO,KAAK,IAAI,KAAK,QAAQ,SAAS;AAAA,EACxC;AAAA,EAEA,OAAO,MAAiC;AACtC,WAAO,KAAK,MAAM,KAAK,KAAK,GAAG,IAAI,CAAC;AAAA,EACtC;AAAA,EAEA,OAAU,QAAa;AACrB,WAAO,OAAO,OAAO,KAAK,MAAM,KAAK,IAAI,IAAI,OAAO,MAAM,GAAG,CAAC,EAAE;AAAA,EAClE;AAAA,EAEA,KAAQ,QAAsB,OAAgB;AAC5C,QAAI,UAAU;AAAW,aAAO,KAAK,KAAK,QAAQ,CAAC,EAAE;AACrD,UAAM,OAAO,OAAO,MAAM;AAC1B,UAAM,SAAc,CAAC;AACrB,YAAQ,KAAK,IAAI,KAAK,QAAQ,KAAK;AACnC,aAAS,IAAI,GAAG,IAAI,OAAO,KAAK,GAAG;AACjC,aAAO,KAAK,KAAK,OAAO,IAAI,CAAC;AAAA,IAC/B;AACA,WAAO;AAAA,EACT;AAAA,EAEA,QAAW,QAAsB;AAC/B,WAAO,KAAK,KAAK,QAAQ,OAAO,MAAM;AAAA,EACxC;AAAA,EAEA,aAA+B,SAAyC;AACtE,UAAM,QAAQ,OAAO,QAAQ,OAAO,EAAE,OAAO,CAAC,MAAM,CAAC,EAAE,IAAI,MAAM,OAAQ,MAAiB,CAAC;AAC3F,UAAM,UAAU,KAAK,IAAI,IAAI;AAC7B,QAAI,UAAU;AACd,eAAW,OAAO,SAAS;AACzB,iBAAW,QAAQ;AACnB,UAAI,UAAU;AAAS,eAAO;AAAA,IAChC;AAAA,EACF;AACF;AAzDA,IAAM,SAAN;AAAM;AAAA,OACG,QAAQ;AA0DjB,IAAM,WAAW,IAAI,OAAO;AAE5B,WAAW,OAAO,CAAC,MAAM,QAAQ,OAAO,QAAQ,UAAU,QAAQ,WAAW,cAAc,GAAG;AAC5F,SAAO,OAAO,SAAS,KAAK,KAAK,QAAQ;AAC3C;AAEA,iBAAS;",
  "names": []
}
