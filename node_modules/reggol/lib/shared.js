"use strict";
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// packages/reggol/src/shared.ts
var import_supports_color = require("supports-color");
var import_cosmokit = require("cosmokit");
var c16 = [6, 2, 3, 4, 5, 1];
var c256 = [
  20,
  21,
  26,
  27,
  32,
  33,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  56,
  57,
  62,
  63,
  68,
  69,
  74,
  75,
  76,
  77,
  78,
  79,
  80,
  81,
  92,
  93,
  98,
  99,
  112,
  113,
  129,
  134,
  135,
  148,
  149,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  178,
  179,
  184,
  185,
  196,
  197,
  198,
  199,
  200,
  201,
  202,
  203,
  204,
  205,
  206,
  207,
  208,
  209,
  214,
  215,
  220,
  221
];
function isAggregateError(error) {
  return error instanceof Error && Array.isArray(error["errors"]);
}
__name(isAggregateError, "isAggregateError");
var _Logger = class {
  constructor(name) {
    this.name = name;
    this.extend = (namespace) => {
      return new _Logger(`${this.name}:${namespace}`);
    };
    if (name in _Logger.instances)
      return _Logger.instances[name];
    _Logger.instances[name] = this;
    this.createMethod("success", "[S]", _Logger.SUCCESS);
    this.createMethod("error", "[E]", _Logger.ERROR);
    this.createMethod("info", "[I]", _Logger.INFO);
    this.createMethod("warn", "[W]", _Logger.WARN);
    this.createMethod("debug", "[D]", _Logger.DEBUG);
  }
  static format(name, formatter) {
    this.formatters[name] = formatter;
  }
  static color(target, code, value, decoration = "") {
    if (!target.colors)
      return "" + value;
    return `\x1B[3${code < 8 ? code : "8;5;" + code}${target.colors >= 2 ? decoration : ""}m${value}\x1B[0m`;
  }
  static code(name, target) {
    let hash = 0;
    for (let i = 0; i < name.length; i++) {
      hash = (hash << 3) - hash + name.charCodeAt(i);
      hash |= 0;
    }
    const colors = target.colors >= 2 ? c256 : target.colors >= 1 ? c16 : [];
    return colors[Math.abs(hash) % colors.length];
  }
  createMethod(name, prefix, minLevel) {
    this[name] = (...args) => {
      var _a, _b, _c, _d, _e, _f;
      if (args.length === 1 && isAggregateError(args[0])) {
        args[0].errors.forEach((error) => this[name](error));
        return;
      }
      if (this.level < minLevel)
        return;
      const now = Date.now();
      for (const target of _Logger.targets) {
        const space = " ".repeat((_b = (_a = target.label) == null ? void 0 : _a.margin) != null ? _b : 1);
        let indent = 3 + space.length, output = "";
        if (target.showTime) {
          indent += target.showTime.length + space.length;
          output += _Logger.color(target, 8, import_cosmokit.Time.template(target.showTime)) + space;
        }
        const label = this.color(target, this.name, ";1");
        const padLength = ((_d = (_c = target.label) == null ? void 0 : _c.width) != null ? _d : 0) + label.length - this.name.length;
        if (((_e = target.label) == null ? void 0 : _e.align) === "right") {
          output += label.padStart(padLength) + space + prefix + space;
          indent += ((_f = target.label.width) != null ? _f : 0) + space.length;
        } else {
          output += prefix + space + label.padEnd(padLength) + space;
        }
        output += this.format(target, indent, ...args);
        if (target.showDiff) {
          const diff = _Logger.timestamp && now - _Logger.timestamp;
          output += this.color(target, " +" + import_cosmokit.Time.format(diff));
        }
        const { maxLength = 10240 } = target;
        if (output.length > maxLength) {
          output = output.slice(0, maxLength) + "...";
        }
        target.print(output);
      }
      _Logger.timestamp = now;
    };
  }
  color(target, value, decoration = "") {
    const code = _Logger.code(this.name, target);
    return _Logger.color(target, code, value, decoration);
  }
  format(target, indent, ...args) {
    if (args[0] instanceof Error) {
      args[0] = args[0].stack || args[0].message;
      args.unshift("%s");
    } else if (typeof args[0] !== "string") {
      args.unshift("%o");
    }
    let format = args.shift();
    format = format.replace(/%([a-zA-Z%])/g, (match, char) => {
      if (match === "%%")
        return "%";
      const formatter = _Logger.formatters[char];
      if (typeof formatter === "function") {
        const value = args.shift();
        return formatter(value, target, this);
      }
      return match;
    }).replace(/\n/g, "\n" + " ".repeat(indent));
    for (const arg of args) {
      format += " " + _Logger.formatters["o"](arg, target, this);
    }
    return format;
  }
  get level() {
    var _a;
    const paths = this.name.split(":");
    let config = _Logger.levels;
    do {
      config = (_a = config[paths.shift()]) != null ? _a : config["base"];
    } while (paths.length && typeof config === "object");
    return config;
  }
  set level(value) {
    const paths = this.name.split(":");
    let config = _Logger.levels;
    while (paths.length > 1) {
      const name = paths.shift();
      const value2 = config[name];
      if (typeof value2 === "object") {
        config = value2;
      } else {
        config = config[name] = { base: value2 != null ? value2 : config.base };
      }
    }
    config[paths[0]] = value;
  }
};
var Logger = _Logger;
__name(Logger, "Logger");
Logger.SILENT = 0;
Logger.SUCCESS = 1;
Logger.ERROR = 1;
Logger.INFO = 2;
Logger.WARN = 2;
Logger.DEBUG = 3;
Logger.timestamp = 0;
Logger.targets = [{
  colors: import_supports_color.stdout && import_supports_color.stdout.level,
  print(text) {
    console.log(text);
  }
}];
Logger.formatters = /* @__PURE__ */ Object.create(null);
Logger.instances = /* @__PURE__ */ Object.create(null);
Logger.levels = {
  base: 2
};
Logger.format("s", (value) => value);
Logger.format("d", (value) => +value);
Logger.format("j", (value) => JSON.stringify(value));
Logger.format("c", (value, target, logger) => {
  return Logger.color(target, Logger.code(logger.name, target), value);
});
Logger.format("C", (value, target) => {
  return Logger.color(target, 15, value, ";1");
});
module.exports = Logger;
//# sourceMappingURL=shared.js.map
