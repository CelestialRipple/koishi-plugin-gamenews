var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// packages/reggol/src/shared.ts
import { stdout } from "supports-color";
import { Time } from "cosmokit";
var require_shared = __commonJS({
  "packages/reggol/src/shared.ts"(exports, module) {
    var c16 = [6, 2, 3, 4, 5, 1];
    var c256 = [
      20,
      21,
      26,
      27,
      32,
      33,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      56,
      57,
      62,
      63,
      68,
      69,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      81,
      92,
      93,
      98,
      99,
      112,
      113,
      129,
      134,
      135,
      148,
      149,
      160,
      161,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      178,
      179,
      184,
      185,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      203,
      204,
      205,
      206,
      207,
      208,
      209,
      214,
      215,
      220,
      221
    ];
    function isAggregateError(error) {
      return error instanceof Error && Array.isArray(error["errors"]);
    }
    __name(isAggregateError, "isAggregateError");
    var _Logger = class {
      constructor(name) {
        this.name = name;
        if (name in _Logger.instances)
          return _Logger.instances[name];
        _Logger.instances[name] = this;
        this.createMethod("success", "[S]", _Logger.SUCCESS);
        this.createMethod("error", "[E]", _Logger.ERROR);
        this.createMethod("info", "[I]", _Logger.INFO);
        this.createMethod("warn", "[W]", _Logger.WARN);
        this.createMethod("debug", "[D]", _Logger.DEBUG);
      }
      static format(name, formatter) {
        this.formatters[name] = formatter;
      }
      static color(target, code, value, decoration = "") {
        if (!target.colors)
          return "" + value;
        return `\x1B[3${code < 8 ? code : "8;5;" + code}${target.colors >= 2 ? decoration : ""}m${value}\x1B[0m`;
      }
      static code(name, target) {
        let hash = 0;
        for (let i = 0; i < name.length; i++) {
          hash = (hash << 3) - hash + name.charCodeAt(i);
          hash |= 0;
        }
        const colors = target.colors >= 2 ? c256 : target.colors >= 1 ? c16 : [];
        return colors[Math.abs(hash) % colors.length];
      }
      extend = (namespace) => {
        return new _Logger(`${this.name}:${namespace}`);
      };
      createMethod(name, prefix, minLevel) {
        this[name] = (...args) => {
          if (args.length === 1 && isAggregateError(args[0])) {
            args[0].errors.forEach((error) => this[name](error));
            return;
          }
          if (this.level < minLevel)
            return;
          const now = Date.now();
          for (const target of _Logger.targets) {
            const space = " ".repeat(target.label?.margin ?? 1);
            let indent = 3 + space.length, output = "";
            if (target.showTime) {
              indent += target.showTime.length + space.length;
              output += _Logger.color(target, 8, Time.template(target.showTime)) + space;
            }
            const label = this.color(target, this.name, ";1");
            const padLength = (target.label?.width ?? 0) + label.length - this.name.length;
            if (target.label?.align === "right") {
              output += label.padStart(padLength) + space + prefix + space;
              indent += (target.label.width ?? 0) + space.length;
            } else {
              output += prefix + space + label.padEnd(padLength) + space;
            }
            output += this.format(target, indent, ...args);
            if (target.showDiff) {
              const diff = _Logger.timestamp && now - _Logger.timestamp;
              output += this.color(target, " +" + Time.format(diff));
            }
            const { maxLength = 10240 } = target;
            if (output.length > maxLength) {
              output = output.slice(0, maxLength) + "...";
            }
            target.print(output);
          }
          _Logger.timestamp = now;
        };
      }
      color(target, value, decoration = "") {
        const code = _Logger.code(this.name, target);
        return _Logger.color(target, code, value, decoration);
      }
      format(target, indent, ...args) {
        if (args[0] instanceof Error) {
          args[0] = args[0].stack || args[0].message;
          args.unshift("%s");
        } else if (typeof args[0] !== "string") {
          args.unshift("%o");
        }
        let format = args.shift();
        format = format.replace(/%([a-zA-Z%])/g, (match, char) => {
          if (match === "%%")
            return "%";
          const formatter = _Logger.formatters[char];
          if (typeof formatter === "function") {
            const value = args.shift();
            return formatter(value, target, this);
          }
          return match;
        }).replace(/\n/g, "\n" + " ".repeat(indent));
        for (const arg of args) {
          format += " " + _Logger.formatters["o"](arg, target, this);
        }
        return format;
      }
      get level() {
        const paths = this.name.split(":");
        let config = _Logger.levels;
        do {
          config = config[paths.shift()] ?? config["base"];
        } while (paths.length && typeof config === "object");
        return config;
      }
      set level(value) {
        const paths = this.name.split(":");
        let config = _Logger.levels;
        while (paths.length > 1) {
          const name = paths.shift();
          const value2 = config[name];
          if (typeof value2 === "object") {
            config = value2;
          } else {
            config = config[name] = { base: value2 ?? config.base };
          }
        }
        config[paths[0]] = value;
      }
    };
    var Logger = _Logger;
    __name(Logger, "Logger");
    __publicField(Logger, "SILENT", 0);
    __publicField(Logger, "SUCCESS", 1);
    __publicField(Logger, "ERROR", 1);
    __publicField(Logger, "INFO", 2);
    __publicField(Logger, "WARN", 2);
    __publicField(Logger, "DEBUG", 3);
    __publicField(Logger, "timestamp", 0);
    __publicField(Logger, "targets", [{
      colors: stdout && stdout.level,
      print(text) {
        console.log(text);
      }
    }]);
    __publicField(Logger, "formatters", /* @__PURE__ */ Object.create(null));
    __publicField(Logger, "instances", /* @__PURE__ */ Object.create(null));
    __publicField(Logger, "levels", {
      base: 2
    });
    Logger.format("s", (value) => value);
    Logger.format("d", (value) => +value);
    Logger.format("j", (value) => JSON.stringify(value));
    Logger.format("c", (value, target, logger) => {
      return Logger.color(target, Logger.code(logger.name, target), value);
    });
    Logger.format("C", (value, target) => {
      return Logger.color(target, 15, value, ";1");
    });
    module.exports = Logger;
  }
});
export default require_shared();
//# sourceMappingURL=shared.mjs.map
