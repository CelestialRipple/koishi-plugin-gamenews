var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// satori/packages/axios/src/index.ts
var src_exports = {};
__export(src_exports, {
  Quester: () => Quester,
  base64ToArrayBuffer: () => base64ToArrayBuffer,
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_cordis = require("cordis");
var import_cosmokit = require("cosmokit");
var import_file_type = require("file-type");
var import_mime_db = __toESM(require("mime-db"));
var import_axios = __toESM(require("axios"));
var import_schemastery = __toESM(require("schemastery"));
function base64ToArrayBuffer(base64) {
  if (typeof Buffer !== "undefined") {
    return Buffer.from(base64, "base64").buffer;
  } else {
    const binary = atob(base64.replace(/\s/g, ""));
    const buffer = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
      buffer[i] = binary.charCodeAt(i);
    }
    return buffer;
  }
}
__name(base64ToArrayBuffer, "base64ToArrayBuffer");
var Quester = class {
  constructor(ctx, config) {
    return Quester.create(config.request);
  }
  extend(newConfig) {
    return Quester.create({
      ...this.config,
      ...newConfig,
      headers: {
        ...this.config.headers,
        ...newConfig.headers
      }
    });
  }
  get(url, config) {
    return this("GET", url, config);
  }
  delete(url, config) {
    return this("DELETE", url, config);
  }
  post(url, data, config) {
    return this("POST", url, { ...config, data });
  }
  put(url, data, config) {
    return this("PUT", url, { ...config, data });
  }
  patch(url, data, config) {
    return this("PATCH", url, { ...config, data });
  }
  async head(url, config) {
    const response = await this.axios(url, { ...config, method: "HEAD" });
    return response.headers;
  }
  ws(url, options) {
    return new WebSocket(url);
  }
  prepare() {
    return (0, import_cosmokit.pick)(this.config, ["timeout", "headers"]);
  }
  async file(url) {
    var _a, _b;
    if (url.startsWith("base64://")) {
      const data2 = base64ToArrayBuffer(url.slice(9));
      const result = await (0, import_file_type.fromBuffer)(data2);
      const name2 = "file" + (result ? "." + result.ext : "");
      return { mime: result == null ? void 0 : result.mime, filename: name2, data: data2 };
    }
    const capture = /^data:([\w/-]+);base64,(.*)$/.exec(url);
    if (capture) {
      const [, mime2, base64] = capture;
      const ext = (_b = (_a = import_mime_db.default[mime2]) == null ? void 0 : _a.extensions) == null ? void 0 : _b[0];
      const name2 = "file" + (ext ? "." + ext : "");
      return { mime: mime2, filename: name2, data: base64ToArrayBuffer(base64) };
    }
    const [_, name] = new URL(url).pathname.match(/.+\/([^/]*)/);
    const { headers, data } = await this.axios(url, { method: "GET", responseType: "arraybuffer" });
    const mime = headers["content-type"];
    return { mime, filename: name, data };
  }
};
__name(Quester, "Quester");
((Quester2) => {
  Quester2.isAxiosError = import_axios.default.isAxiosError;
  Quester2.Config = import_schemastery.default.object({
    timeout: import_schemastery.default.natural().role("ms").description("等待连接建立的最长时间。")
  }).description("请求设置");
  function createConfig(endpoint) {
    return import_schemastery.default.object({
      endpoint: import_schemastery.default.string().role("link").description("要连接的服务器地址。").default(typeof endpoint === "string" ? endpoint : null).required(typeof endpoint === "boolean" ? endpoint : false),
      headers: import_schemastery.default.dict(String).description("要附加的额外请求头。"),
      ...this.Config.dict
    }).description("请求设置");
  }
  Quester2.createConfig = createConfig;
  __name(createConfig, "createConfig");
  function create(config = {}) {
    const endpoint = (0, import_cosmokit.trimSlash)(config.endpoint || "");
    const request = /* @__PURE__ */ __name(async (url, config2 = {}) => {
      const options = http.prepare();
      return (0, import_axios.default)({
        ...options,
        ...config2,
        url: endpoint + url,
        headers: {
          ...options.headers,
          ...config2.headers
        }
      });
    }, "request");
    const http = /* @__PURE__ */ __name(async (method, url, config2) => {
      const response = await request(url, { ...config2, method });
      return response.data;
    }, "http");
    Object.setPrototypeOf(http, this.prototype);
    for (const key of ["extend", "get", "delete", "post", "put", "patch", "head", "ws"]) {
      http[key] = this.prototype[key].bind(http);
    }
    http.config = config;
    http.axios = request;
    return http;
  }
  Quester2.create = create;
  __name(create, "create");
})(Quester || (Quester = {}));
import_cordis.Context.service("http", Quester);
var src_default = Quester;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Quester,
  base64ToArrayBuffer
});
//# sourceMappingURL=index.js.map
