{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["import { Context } from 'cordis'\nimport { Dict, pick, trimSlash } from 'cosmokit'\nimport { ClientRequestArgs } from 'http'\nimport { fromBuffer } from 'file-type'\nimport mimedb from 'mime-db'\nimport axios, { AxiosRequestConfig, AxiosResponse, Method } from 'axios'\nimport * as types from 'axios'\nimport Schema from 'schemastery'\n\ndeclare module 'cordis' {\n  interface Context {\n    http: Quester\n  }\n\n  namespace Context {\n    interface Config {\n      request?: Quester.Config\n    }\n  }\n}\n\nexport function base64ToArrayBuffer(base64: string) {\n  if (typeof Buffer !== 'undefined') {\n    return Buffer.from(base64, 'base64').buffer\n  } else {\n    const binary = atob(base64.replace(/\\s/g, ''))\n    const buffer = new Uint8Array(binary.length)\n    for (let i = 0; i < binary.length; i++) {\n      buffer[i] = binary.charCodeAt(i)\n    }\n    return buffer\n  }\n}\n\nexport interface Quester {\n  <T = any>(method: Method, url: string, config?: AxiosRequestConfig): Promise<T>\n  axios<T = any>(url: string, config?: AxiosRequestConfig): Promise<AxiosResponse<T>>\n  config: Quester.Config\n}\n\nexport class Quester {\n  constructor(ctx: Context, config: Context.Config) {\n    return Quester.create(config.request)\n  }\n\n  extend(newConfig: Quester.Config): Quester {\n    return Quester.create({\n      ...this.config,\n      ...newConfig,\n      headers: {\n        ...this.config.headers,\n        ...newConfig.headers,\n      },\n    })\n  }\n\n  get<T = any>(url: string, config?: AxiosRequestConfig): Promise<T> {\n    return this('GET', url, config)\n  }\n\n  delete<T = any>(url: string, config?: AxiosRequestConfig): Promise<T> {\n    return this('DELETE', url, config)\n  }\n\n  post<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {\n    return this('POST', url, { ...config, data })\n  }\n\n  put<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {\n    return this('PUT', url, { ...config, data })\n  }\n\n  patch<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {\n    return this('PATCH', url, { ...config, data })\n  }\n\n  async head(url: string, config?: AxiosRequestConfig): Promise<Dict<string>> {\n    const response = await this.axios(url, { ...config, method: 'HEAD' })\n    return response.headers\n  }\n\n  ws(url: string, options?: ClientRequestArgs) {\n    return new WebSocket(url) as any as import('ws').WebSocket\n  }\n\n  prepare(): AxiosRequestConfig {\n    return pick(this.config, ['timeout', 'headers'])\n  }\n\n  async file(url: string): Promise<Quester.File> {\n    // for backward compatibility\n    if (url.startsWith('base64://')) {\n      const data = base64ToArrayBuffer(url.slice(9))\n      const result = await fromBuffer(data)\n      const name = 'file' + (result ? '.' + result.ext : '')\n      return { mime: result?.mime, filename: name, data }\n    }\n    const capture = /^data:([\\w/-]+);base64,(.*)$/.exec(url)\n    if (capture) {\n      const [, mime, base64] = capture\n      const ext = mimedb[mime]?.extensions?.[0]\n      const name = 'file' + (ext ? '.' + ext : '')\n      return { mime, filename: name, data: base64ToArrayBuffer(base64) }\n    }\n    const [_, name] = new URL(url).pathname.match(/.+\\/([^/]*)/)\n    const { headers, data } = await this.axios(url, { method: 'GET', responseType: 'arraybuffer' })\n    const mime = headers['content-type']\n    return { mime, filename: name, data }\n  }\n}\n\nexport namespace Quester {\n  export type Method = types.Method\n  export type AxiosResponse = types.AxiosResponse\n  export type AxiosRequestConfig = types.AxiosRequestConfig\n\n  export interface File {\n    mime?: string\n    filename: string\n    data: ArrayBuffer\n  }\n\n  export const isAxiosError = axios.isAxiosError\n\n  export interface Config {\n    headers?: Dict\n    endpoint?: string\n    timeout?: number\n    proxyAgent?: string\n  }\n\n  export const Config: Schema<Config> = Schema.object({\n    timeout: Schema.natural().role('ms').description('等待连接建立的最长时间。'),\n  }).description('请求设置')\n\n  export function createConfig(this: typeof Quester, endpoint: string | boolean): Schema<Config> {\n    return Schema.object({\n      endpoint: Schema.string().role('link').description('要连接的服务器地址。')\n        .default(typeof endpoint === 'string' ? endpoint : null)\n        .required(typeof endpoint === 'boolean' ? endpoint : false),\n      headers: Schema.dict(String).description('要附加的额外请求头。'),\n      ...this.Config.dict,\n    }).description('请求设置')\n  }\n\n  export function create(this: typeof Quester, config: Quester.Config = {}) {\n    const endpoint = trimSlash(config.endpoint || '')\n\n    const request = async (url: string, config: AxiosRequestConfig = {}) => {\n      const options = http.prepare()\n      return axios({\n        ...options,\n        ...config,\n        url: endpoint + url,\n        headers: {\n          ...options.headers,\n          ...config.headers,\n        },\n      })\n    }\n\n    const http = (async (method, url, config) => {\n      const response = await request(url, { ...config, method })\n      return response.data\n    }) as Quester\n\n    Object.setPrototypeOf(http, this.prototype)\n    for (const key of ['extend', 'get', 'delete', 'post', 'put', 'patch', 'head', 'ws']) {\n      http[key] = this.prototype[key].bind(http)\n    }\n\n    http.config = config\n    http.axios = request\n    return http\n  }\n}\n\nContext.service('http', Quester)\n\nexport default Quester\n"],
  "mappings": "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",
  "names": ["data", "name", "mime", "mimedb", "Quester", "axios", "Schema", "config"]
}
