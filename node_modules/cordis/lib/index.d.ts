import { Awaitable, Promisify } from 'cosmokit';
export function isConstructor(func: any): func is new (...args: any) => any;
export function getConstructor(instance: any): any;
export function resolveConfig(plugin: any, config: any): any;
export function isApplicable(object: Plugin): boolean;
export type Plugin<C extends Context = Context> = Plugin.Function<any, C> | Plugin.Constructor<any, C> | Plugin.Object<any, any, C>;
export namespace Plugin {
    type Function<T = any, C extends Context = any> = (ctx: C, options: T) => void;
    type Constructor<T = any, C extends Context = any> = new (ctx: C, options: T) => void;
    interface Object<S = any, T = any, C extends Context = any> {
        name?: string;
        apply: Function<T, C>;
        reactive?: boolean;
        reusable?: boolean;
        Config?: (config?: S) => T;
        schema?: (config?: S) => T;
        using?: readonly string[];
    }
    type Config<T extends Plugin<any>> = T extends Constructor<infer U> ? U : T extends Function<infer U> ? U : T extends Object<infer U> ? U : never;
}
export interface Context {
    using(using: readonly string[], callback: Plugin.Function<void, Context.Parameterized<this>>): ForkScope<Context.Parameterized<this>>;
    plugin<S extends Plugin<Context.Parameterized<this>>, T extends Plugin.Config<S>>(plugin: S, config?: boolean | T): ForkScope<Context.Parameterized<this, T>>;
    /** @deprecated use `ctx.registry.delete()` instead */
    dispose(plugin?: Plugin<Context.Parameterized<this>>): boolean;
}
export namespace Registry {
    interface Config {
    }
}
export class Registry<C extends Context = Context> extends Map<Plugin<C>, MainScope<C>> {
    private root;
    static readonly methods: string[];
    private _counter;
    constructor(root: Context, config: Registry.Config);
    get counter(): number;
    private resolve;
    get(plugin: Plugin<C>): MainScope<C> | undefined;
    has(plugin: Plugin<C>): boolean;
    set(plugin: Plugin<C>, state: MainScope<C>): this;
    delete(plugin: Plugin<C>): boolean;
    using(using: readonly string[], callback: Plugin.Function<void, C>): ForkScope<C> | undefined;
    plugin(plugin: Plugin<C>, config?: any): ForkScope<C> | undefined;
    dispose(plugin: Plugin<C>): boolean;
}
export interface Context<T> {
    config: T;
    state: EffectScope<this>;
    runtime: MainScope<this>;
    collect(label: string, callback: () => boolean): () => boolean;
    accept(callback?: (config: this['config']) => void | boolean, options?: AcceptOptions): () => boolean;
    accept(keys: (keyof this['config'])[], callback?: (config: this['config']) => void | boolean, options?: AcceptOptions): () => boolean;
    decline(keys: (keyof this['config'])[]): () => boolean;
}
export type Disposable = () => void;
export interface AcceptOptions {
    passive?: boolean;
    immediate?: boolean;
}
export interface Acceptor extends AcceptOptions {
    keys?: string[];
    callback?: (config: any) => void | boolean;
}
export abstract class EffectScope<C extends Context = Context> {
    parent: C;
    config: C['config'];
    uid: number | null;
    ctx: C;
    disposables: Disposable[];
    protected proxy: any;
    protected context: Context;
    protected acceptors: Acceptor[];
    abstract runtime: MainScope<C>;
    abstract dispose(): boolean;
    abstract start(): void;
    abstract update(config: C['config'], forced?: boolean): void;
    constructor(parent: C, config: C['config']);
    protected get _config(): any;
    collect(label: string, callback: () => boolean): () => boolean;
    restart(): void;
    protected setup(): void;
    protected checkDeps(): boolean;
    clear(preserve?: boolean): void;
    accept(callback?: (config: C['config']) => void | boolean, options?: AcceptOptions): () => boolean;
    accept(keys: string[], callback?: (config: C['config']) => void | boolean, options?: AcceptOptions): () => boolean;
    decline(keys: string[]): () => boolean;
    checkUpdate(resolved: any, forced?: boolean): boolean[];
}
export class ForkScope<C extends Context = Context> extends EffectScope<C> {
    runtime: MainScope<C>;
    dispose: () => boolean;
    constructor(parent: Context, config: C['config'], runtime: MainScope<C>);
    start(): void;
    update(config: any, forced?: boolean): void;
}
export class MainScope<C extends Context = Context> extends EffectScope<C> {
    plugin: Plugin;
    runtime: this;
    schema: any;
    using: readonly string[];
    forkables: Function[];
    children: ForkScope<C>[];
    isReusable: boolean;
    isReactive: boolean;
    constructor(registry: Registry<C>, plugin: Plugin, config: any);
    get isForkable(): boolean;
    get name(): string;
    fork(parent: Context, config: any): ForkScope<C>;
    dispose(): boolean;
    setup(): void;
    private apply;
    clear(preserve?: boolean): void;
    start(): void;
    update(config: C['config'], forced?: boolean): void;
}
export function isBailed(value: any): boolean;
export type Parameters<F> = F extends (...args: infer P) => any ? P : never;
export type ReturnType<F> = F extends (...args: any) => infer R ? R : never;
export type ThisType<F> = F extends (this: infer T, ...args: any) => any ? T : never;
export type GetEvents<C extends Context> = C[typeof Context.events];
export interface Context {
    [Context.events]: Events<this>;
    parallel<K extends keyof GetEvents<this>>(name: K, ...args: Parameters<GetEvents<this>[K]>): Promise<void>;
    parallel<K extends keyof GetEvents<this>>(thisArg: ThisType<GetEvents<this>[K]>, name: K, ...args: Parameters<GetEvents<this>[K]>): Promise<void>;
    emit<K extends keyof GetEvents<this>>(name: K, ...args: Parameters<GetEvents<this>[K]>): void;
    emit<K extends keyof GetEvents<this>>(thisArg: ThisType<GetEvents<this>[K]>, name: K, ...args: Parameters<GetEvents<this>[K]>): void;
    serial<K extends keyof GetEvents<this>>(name: K, ...args: Parameters<GetEvents<this>[K]>): Promisify<ReturnType<GetEvents<this>[K]>>;
    serial<K extends keyof GetEvents<this>>(thisArg: ThisType<GetEvents<this>[K]>, name: K, ...args: Parameters<GetEvents<this>[K]>): Promisify<ReturnType<GetEvents<this>[K]>>;
    bail<K extends keyof GetEvents<this>>(name: K, ...args: Parameters<GetEvents<this>[K]>): ReturnType<GetEvents<this>[K]>;
    bail<K extends keyof GetEvents<this>>(thisArg: ThisType<GetEvents<this>[K]>, name: K, ...args: Parameters<GetEvents<this>[K]>): ReturnType<GetEvents<this>[K]>;
    on<K extends keyof GetEvents<this>>(name: K, listener: GetEvents<this>[K], prepend?: boolean): () => boolean;
    once<K extends keyof GetEvents<this>>(name: K, listener: GetEvents<this>[K], prepend?: boolean): () => boolean;
    off<K extends keyof GetEvents<this>>(name: K, listener: GetEvents<this>[K]): boolean;
    start(): Promise<void>;
    stop(): Promise<void>;
}
export namespace Lifecycle {
    interface Config {
        maxListeners?: number;
    }
}
export class Lifecycle {
    private root;
    static readonly methods: string[];
    isActive: boolean;
    _tasks: Set<Promise<void>>;
    _hooks: Record<keyof any, [Context, (...args: any[]) => any][]>;
    constructor(root: Context);
    queue(value: any): void;
    flush(): Promise<void>;
    getHooks(name: keyof any, thisArg?: object): Generator<(...args: any[]) => any, void, unknown>;
    parallel(...args: any[]): Promise<void>;
    emit(...args: any[]): void;
    serial(...args: any[]): Promise<any>;
    bail(...args: any[]): any;
    register(label: string, hooks: [Context, any][], listener: any, prepend?: boolean): any;
    unregister(hooks: [Context, any][], listener: any): true | undefined;
    on(name: keyof any, listener: (...args: any) => any, prepend?: boolean): any;
    once(name: keyof any, listener: (...args: any) => any, prepend?: boolean): any;
    off(name: keyof any, listener: (...args: any) => any): true | undefined;
    start(): Promise<void>;
    stop(): Promise<void>;
}
export interface Events<C extends Context = Context> {
    'fork': Plugin.Function<C['config'], C>;
    'ready'(): Awaitable<void>;
    'dispose'(): Awaitable<void>;
    'internal/fork'(fork: ForkScope<Context.Parameterized<C>>): void;
    'internal/runtime'(runtime: MainScope<Context.Parameterized<C>>): void;
    'internal/warning'(format: any, ...param: any[]): void;
    'internal/before-service'(name: string, value: any): void;
    'internal/service'(name: string, oldValue: any): void;
    'internal/before-update'(fork: ForkScope<Context.Parameterized<C>>, config: any): void;
    'internal/update'(fork: ForkScope<Context.Parameterized<C>>, oldConfig: any): void;
    'internal/hook'(this: Lifecycle, name: string, listener: Function, prepend: boolean): () => boolean;
}
export interface Context {
    [Context.config]: Context.Config;
    root: Context.Parameterized<this, this[typeof Context.config]>;
    mapping: Record<string | symbol, symbol>;
    lifecycle: Lifecycle;
    registry: Registry<this>;
}
export class Context<T = any> {
    static readonly config: unique symbol;
    static readonly events: unique symbol;
    static readonly static: unique symbol;
    static readonly filter: unique symbol;
    static readonly source: unique symbol;
    static readonly current: unique symbol;
    static readonly internal: unique symbol;
    static readonly immediate: unique symbol;
    constructor(config?: Context.Config);
    get events(): Lifecycle;
    extend(meta?: {}): this;
    isolate(names: string[]): this;
}
export namespace Context {
    type Parameterized<C, T = any> = Omit<C, 'config'> & {
        config: T;
    };
    interface Config extends Lifecycle.Config, Registry.Config {
    }
    interface MixinOptions {
        methods?: string[];
        properties?: string[];
    }
    function mixin(name: keyof any, options: MixinOptions): void;
    interface ServiceOptions extends MixinOptions {
        prototype?: any;
    }
    function service(name: keyof any, options?: ServiceOptions): void;
}
export class Service<C extends Context = Context> {
    protected ctx: C;
    protected start(): Awaitable<void>;
    protected stop(): Awaitable<void>;
    protected fork?(ctx: C, config: any): void;
    constructor(ctx: C, name: string, immediate?: boolean);
    get caller(): C;
}
