"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// packages/cordis/src/index.ts
var src_exports = {};
__export(src_exports, {
  Context: () => Context,
  EffectScope: () => EffectScope,
  ForkScope: () => ForkScope,
  Lifecycle: () => Lifecycle,
  MainScope: () => MainScope,
  Registry: () => Registry,
  Service: () => Service,
  getConstructor: () => getConstructor,
  isApplicable: () => isApplicable,
  isBailed: () => isBailed,
  isConstructor: () => isConstructor,
  resolveConfig: () => resolveConfig
});
module.exports = __toCommonJS(src_exports);

// packages/cordis/src/context.ts
var import_cosmokit4 = require("cosmokit");

// packages/cordis/src/events.ts
var import_cosmokit = require("cosmokit");
function isBailed(value) {
  return value !== null && value !== false && value !== void 0;
}
__name(isBailed, "isBailed");
var Lifecycle = class {
  constructor(root) {
    this.root = root;
    this.isActive = false;
    this._tasks = /* @__PURE__ */ new Set();
    this._hooks = {};
    (0, import_cosmokit.defineProperty)(this, Context.current, root);
    (0, import_cosmokit.defineProperty)(this.on("internal/hook", function(name, listener, prepend) {
      const method = prepend ? "unshift" : "push";
      const { state } = this[Context.current];
      const { runtime, disposables } = state;
      if (name === "ready" && this.isActive) {
        this.queue(listener());
      } else if (name === "dispose") {
        disposables[method](listener);
        (0, import_cosmokit.defineProperty)(listener, "name", "event <dispose>");
        return () => (0, import_cosmokit.remove)(disposables, listener);
      } else if (name === "fork") {
        runtime.forkables[method](listener);
        return state.collect("event <fork>", () => (0, import_cosmokit.remove)(runtime.forkables, listener));
      }
    }), Context.static, root.state);
  }
  queue(value) {
    const task = Promise.resolve(value).catch((reason) => this.root.emit("internal/warning", reason)).then(() => this._tasks.delete(task));
    this._tasks.add(task);
  }
  async flush() {
    while (this._tasks.size) {
      await Promise.all(Array.from(this._tasks));
    }
  }
  *getHooks(name, thisArg) {
    const hooks = this._hooks[name] || [];
    for (const [context, callback] of hooks.slice()) {
      const filter = thisArg == null ? void 0 : thisArg[Context.filter];
      if (filter && !filter.call(thisArg, context))
        continue;
      yield callback;
    }
  }
  async parallel(...args) {
    const thisArg = typeof args[0] === "object" ? args.shift() : null;
    const name = args.shift();
    await Promise.all([...this.getHooks(name, thisArg)].map(async (callback) => {
      await callback.apply(thisArg, args);
    }));
  }
  emit(...args) {
    const thisArg = typeof args[0] === "object" ? args.shift() : null;
    const name = args.shift();
    for (const callback of this.getHooks(name, thisArg)) {
      callback.apply(thisArg, args);
    }
  }
  async serial(...args) {
    const thisArg = typeof args[0] === "object" ? args.shift() : null;
    const name = args.shift();
    for (const callback of this.getHooks(name, thisArg)) {
      const result = await callback.apply(thisArg, args);
      if (isBailed(result))
        return result;
    }
  }
  bail(...args) {
    const thisArg = typeof args[0] === "object" ? args.shift() : null;
    const name = args.shift();
    for (const callback of this.getHooks(name, thisArg)) {
      const result = callback.apply(thisArg, args);
      if (isBailed(result))
        return result;
    }
  }
  register(label, hooks, listener, prepend) {
    const maxListeners = this.root.config.maxListeners;
    if (hooks.length >= maxListeners) {
      this.root.emit("internal/warning", `max listener count (${maxListeners}) for ${label} exceeded, which may be caused by a memory leak`);
    }
    const caller = this[Context.current];
    const method = prepend ? "unshift" : "push";
    hooks[method]([caller, listener]);
    return caller.state.collect(label, () => this.unregister(hooks, listener));
  }
  unregister(hooks, listener) {
    const index = hooks.findIndex(([context, callback]) => callback === listener);
    if (index >= 0) {
      hooks.splice(index, 1);
      return true;
    }
  }
  on(name, listener, prepend = false) {
    var _a;
    const result = this.bail(this, "internal/hook", name, listener, prepend);
    if (result)
      return result;
    const hooks = (_a = this._hooks)[name] || (_a[name] = []);
    const label = typeof name === "string" ? `event <${name}>` : "event (Symbol)";
    return this.register(label, hooks, listener, prepend);
  }
  once(name, listener, prepend = false) {
    const dispose = this.on(name, function(...args) {
      dispose();
      return listener.apply(this, args);
    }, prepend);
    return dispose;
  }
  off(name, listener) {
    return this.unregister(this._hooks[name] || [], listener);
  }
  async start() {
    this.isActive = true;
    for (const callback of this.getHooks("ready")) {
      this.queue(callback());
    }
    delete this._hooks.ready;
    await this.flush();
  }
  async stop() {
    this.isActive = false;
    this.root.state.clear(true);
  }
};
__name(Lifecycle, "Lifecycle");
Lifecycle.methods = ["on", "once", "off", "before", "after", "parallel", "emit", "serial", "bail", "start", "stop"];

// packages/cordis/src/registry.ts
var import_cosmokit3 = require("cosmokit");

// packages/cordis/src/scope.ts
var import_cosmokit2 = require("cosmokit");

// packages/cordis/src/utils.ts
function isConstructor(func) {
  if (!func.prototype)
    return false;
  if (func.prototype.constructor !== func)
    return false;
  return true;
}
__name(isConstructor, "isConstructor");
function getConstructor(instance) {
  return Object.getPrototypeOf(instance).constructor;
}
__name(getConstructor, "getConstructor");
function resolveConfig(plugin, config) {
  if (config === false)
    return;
  if (config === true)
    config = void 0;
  config != null ? config : config = {};
  const schema = plugin["Config"] || plugin["schema"];
  if (schema && plugin["schema"] !== false)
    config = schema(config);
  return config;
}
__name(resolveConfig, "resolveConfig");

// packages/cordis/src/scope.ts
var EffectScope = class {
  constructor(parent, config) {
    this.parent = parent;
    this.config = config;
    this.disposables = [];
    this.acceptors = [];
    this.uid = parent.registry ? parent.registry.counter : 0;
    this.ctx = this.context = parent.extend({ state: this });
    this.proxy = new Proxy({}, {
      get: (target, key) => Reflect.get(this.config, key)
    });
  }
  get _config() {
    return this.runtime.isReactive ? this.proxy : this.config;
  }
  collect(label, callback) {
    const dispose = (0, import_cosmokit2.defineProperty)(() => {
      (0, import_cosmokit2.remove)(this.disposables, dispose);
      return callback();
    }, "name", label);
    this.disposables.push(dispose);
    return dispose;
  }
  restart() {
    this.clear(true);
    this.start();
  }
  setup() {
    if (!this.runtime.using.length)
      return;
    (0, import_cosmokit2.defineProperty)(this.context.on("internal/before-service", (name) => {
      if (!this.runtime.using.includes(name))
        return;
      this.clear(true);
    }), Context.static, this);
    (0, import_cosmokit2.defineProperty)(this.context.on("internal/service", (name) => {
      if (!this.runtime.using.includes(name))
        return;
      this.start();
    }), Context.static, this);
  }
  checkDeps() {
    return this.runtime.using.every((name) => this.ctx[name]);
  }
  clear(preserve = false) {
    this.disposables = this.disposables.splice(0, Infinity).filter((dispose) => {
      if (preserve && dispose[Context.static] === this)
        return true;
      dispose();
    });
  }
  accept(...args) {
    var _a;
    const keys = Array.isArray(args[0]) ? args.shift() : null;
    const acceptor = { keys, callback: args[0], ...args[1] };
    this.acceptors.push(acceptor);
    if (acceptor.immediate)
      (_a = acceptor.callback) == null ? void 0 : _a.call(acceptor, this.config);
    return this.collect(`accept <${(keys == null ? void 0 : keys.join(", ")) || "*"}>`, () => (0, import_cosmokit2.remove)(this.acceptors, acceptor));
  }
  decline(keys) {
    return this.accept(keys, () => true);
  }
  checkUpdate(resolved, forced) {
    if (forced)
      return [true, true];
    const modified = /* @__PURE__ */ Object.create(null);
    const checkPropertyUpdate = /* @__PURE__ */ __name((key) => {
      var _a;
      const result = (_a = modified[key]) != null ? _a : modified[key] = !(0, import_cosmokit2.deepEqual)(this.config[key], resolved[key]);
      hasUpdate || (hasUpdate = result);
      return result;
    }, "checkPropertyUpdate");
    const ignored = /* @__PURE__ */ new Set();
    let hasUpdate = false, shouldRestart = false;
    let fallback = this.runtime.isReactive || null;
    for (const { keys, callback, passive } of this.acceptors) {
      if (!keys) {
        fallback || (fallback = !passive);
      } else if (passive) {
        keys == null ? void 0 : keys.forEach((key) => ignored.add(key));
      } else {
        let hasUpdate2 = false;
        for (const key of keys) {
          hasUpdate2 || (hasUpdate2 = checkPropertyUpdate(key));
        }
        if (!hasUpdate2)
          continue;
      }
      const result = callback == null ? void 0 : callback(resolved);
      if (result)
        shouldRestart = true;
    }
    for (const key in { ...this.config, ...resolved }) {
      if (fallback === false)
        continue;
      if (!(key in modified) && !ignored.has(key)) {
        const hasUpdate2 = checkPropertyUpdate(key);
        if (fallback === null)
          shouldRestart || (shouldRestart = hasUpdate2);
      }
    }
    return [hasUpdate, shouldRestart];
  }
};
__name(EffectScope, "EffectScope");
var ForkScope = class extends EffectScope {
  constructor(parent, config, runtime) {
    super(parent, config);
    this.runtime = runtime;
    this.dispose = (0, import_cosmokit2.defineProperty)(parent.state.collect(`fork <${parent.runtime.name}>`, () => {
      this.uid = null;
      this.clear();
      const result = (0, import_cosmokit2.remove)(runtime.disposables, this.dispose);
      if ((0, import_cosmokit2.remove)(runtime.children, this) && !runtime.children.length) {
        parent.registry.delete(runtime.plugin);
      }
      this.context.emit("internal/fork", this);
      return result;
    }), Context.static, runtime);
    runtime.children.push(this);
    runtime.disposables.push(this.dispose);
    this.context.emit("internal/fork", this);
    if (runtime.isReusable) {
      this.setup();
    }
    this.start();
  }
  start() {
    if (!this.checkDeps())
      return;
    for (const fork of this.runtime.forkables) {
      this.ctx.lifecycle.queue(fork(this.context, this._config));
    }
  }
  update(config, forced) {
    const oldConfig = this.config;
    const state = this.runtime.isForkable ? this : this.runtime;
    if (state.config !== oldConfig)
      return;
    const resolved = resolveConfig(this.runtime.plugin, config);
    const [hasUpdate, shouldRestart] = state.checkUpdate(resolved, forced);
    this.context.emit("internal/before-update", this, config);
    this.config = resolved;
    state.config = resolved;
    if (hasUpdate) {
      this.context.emit("internal/update", this, oldConfig);
    }
    if (shouldRestart)
      state.restart();
  }
};
__name(ForkScope, "ForkScope");
var MainScope = class extends EffectScope {
  constructor(registry, plugin, config) {
    super(registry[Context.current], config);
    this.plugin = plugin;
    this.runtime = this;
    this.using = [];
    this.forkables = [];
    this.children = [];
    this.isReusable = false;
    this.isReactive = false;
    this.apply = (context, config) => {
      if (typeof this.plugin !== "function") {
        const instance = this.plugin.apply(context, config);
        this.ctx.lifecycle.queue(instance);
      } else if (isConstructor(this.plugin)) {
        const instance = new this.plugin(context, config);
        const name = instance[Context.immediate];
        if (name) {
          context[name] = instance;
        }
        if (instance["fork"]) {
          this.forkables.push(instance["fork"].bind(instance));
        }
      } else {
        const instance = this.plugin(context, config);
        this.ctx.lifecycle.queue(instance);
      }
    };
    registry.set(plugin, this);
    if (plugin)
      this.setup();
  }
  get isForkable() {
    return this.forkables.length > 0;
  }
  get name() {
    if (!this.plugin)
      return "root";
    const { name } = this.plugin;
    return !name || name === "apply" ? "anonymous" : name;
  }
  fork(parent, config) {
    return new ForkScope(parent, config, this);
  }
  dispose() {
    this.uid = null;
    this.clear();
    this.context.emit("internal/runtime", this);
    return true;
  }
  setup() {
    this.schema = this.plugin["Config"] || this.plugin["schema"];
    this.using = this.plugin["using"] || [];
    this.isReusable = this.plugin["reusable"];
    this.isReactive = this.plugin["reactive"];
    this.context.emit("internal/runtime", this);
    if (this.isReusable) {
      this.forkables.push(this.apply);
    } else {
      super.setup();
    }
    this.restart();
  }
  clear(preserve) {
    super.clear(preserve);
    for (const fork of this.children) {
      fork.clear(preserve);
    }
  }
  start() {
    if (!this.checkDeps())
      return;
    if (!this.isReusable && this.plugin) {
      this.apply(this.context, this._config);
    }
    for (const fork of this.children) {
      fork.start();
    }
  }
  update(config, forced) {
    if (this.isForkable) {
      this.context.emit("internal/warning", `attempting to update forkable plugin "${this.plugin.name}", which may lead to unexpected behavior`);
    }
    const oldConfig = this.config;
    const resolved = resolveConfig(this.runtime.plugin || getConstructor(this.context), config);
    const [hasUpdate, shouldRestart] = this.checkUpdate(resolved, forced);
    const state = this.children.find((fork) => fork.config === oldConfig);
    this.config = resolved;
    if (state) {
      this.context.emit("internal/before-update", state, config);
      state.config = resolved;
      if (hasUpdate) {
        this.context.emit("internal/update", state, oldConfig);
      }
    }
    if (shouldRestart)
      this.restart();
  }
};
__name(MainScope, "MainScope");

// packages/cordis/src/registry.ts
function isApplicable(object) {
  return object && typeof object === "object" && typeof object.apply === "function";
}
__name(isApplicable, "isApplicable");
var Registry = class extends Map {
  constructor(root, config) {
    super();
    this.root = root;
    this._counter = 0;
    (0, import_cosmokit3.defineProperty)(this, Context.current, root);
    root.state = new MainScope(this, null, config);
    root.state.runtime.isReactive = true;
  }
  get counter() {
    return ++this._counter;
  }
  resolve(plugin) {
    return plugin && (typeof plugin === "function" ? plugin : plugin.apply);
  }
  get(plugin) {
    return super.get(this.resolve(plugin));
  }
  has(plugin) {
    return super.has(this.resolve(plugin));
  }
  set(plugin, state) {
    return super.set(this.resolve(plugin), state);
  }
  delete(plugin) {
    plugin = this.resolve(plugin);
    const runtime = this.get(plugin);
    if (!runtime)
      return false;
    super.delete(plugin);
    return runtime.dispose();
  }
  using(using, callback) {
    return this.plugin({ using, apply: callback, name: callback.name });
  }
  plugin(plugin, config) {
    if (typeof plugin !== "function" && !isApplicable(plugin)) {
      throw new Error('invalid plugin, expect function or object with an "apply" method');
    }
    config = resolveConfig(plugin, config);
    if (!config)
      return;
    const context = this[Context.current];
    let runtime = this.get(plugin);
    if (runtime) {
      if (!runtime.isForkable) {
        this.root.emit("internal/warning", `duplicate plugin detected: ${plugin.name}`);
      }
      return runtime.fork(context, config);
    }
    runtime = new MainScope(this, plugin, config);
    return runtime.fork(context, config);
  }
  dispose(plugin) {
    return this.delete(plugin);
  }
};
__name(Registry, "Registry");
Registry.methods = ["using", "plugin", "dispose"];

// packages/cordis/src/context.ts
var _Context = class {
  constructor(config) {
    const options = resolveConfig(getConstructor(this), config);
    const attach = /* @__PURE__ */ __name((internal) => {
      if (!internal)
        return;
      attach(Object.getPrototypeOf(internal));
      for (const key of Object.getOwnPropertySymbols(internal)) {
        this[key] = new internal[key](this, options);
      }
    }, "attach");
    this.root = this;
    this.mapping = /* @__PURE__ */ Object.create(null);
    attach(this[_Context.internal]);
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Context <${this.runtime.name}>`;
  }
  get events() {
    return this.lifecycle;
  }
  extend(meta = {}) {
    return Object.assign(Object.create(this), meta);
  }
  isolate(names) {
    const mapping = Object.create(this.mapping);
    for (const name of names) {
      mapping[name] = Symbol(name);
    }
    return this.extend({ mapping });
  }
};
var Context = _Context;
__name(Context, "Context");
Context.config = Symbol("config");
Context.events = Symbol("events");
Context.static = Symbol("static");
Context.filter = Symbol("filter");
Context.source = Symbol("source");
Context.current = Symbol("current");
Context.internal = Symbol("internal");
Context.immediate = Symbol("immediate");
((Context2) => {
  function mixin(name, options) {
    for (const key of options.methods || []) {
      (0, import_cosmokit4.defineProperty)(Context2.prototype, key, function(...args) {
        return this[name][key](...args);
      });
    }
    for (const key of options.properties || []) {
      Object.defineProperty(Context2.prototype, key, {
        configurable: true,
        get() {
          return this[name][key];
        },
        set(value) {
          this[name][key] = value;
        }
      });
    }
  }
  Context2.mixin = mixin;
  __name(mixin, "mixin");
  function service(name, options = {}) {
    const privateKey = typeof name === "symbol" ? name : Symbol(name);
    Object.defineProperty(this.prototype, name, {
      configurable: true,
      get() {
        const key = this.mapping[name] || privateKey;
        const value = this.root[key];
        if (!value)
          return;
        (0, import_cosmokit4.defineProperty)(value, Context2.current, this);
        return value;
      },
      set(value) {
        const key = this.mapping[name] || privateKey;
        const oldValue = this.root[key];
        if (oldValue === value)
          return;
        const self = /* @__PURE__ */ Object.create(null);
        self[Context2.filter] = (ctx) => {
          return this.mapping[name] === ctx.mapping[name];
        };
        if (typeof name === "string") {
          this.emit(self, "internal/before-service", name, value);
        }
        this.root[key] = value;
        if (value && typeof value === "object") {
          (0, import_cosmokit4.defineProperty)(value, Context2.source, this);
        }
        if (typeof name === "string") {
          this.emit(self, "internal/service", name, oldValue);
        }
      }
    });
    if (isConstructor(options)) {
      const internal = ensureInternal(this.prototype);
      internal[privateKey] = options;
    }
    mixin(name, options);
  }
  Context2.service = service;
  __name(service, "service");
  function ensureInternal(prototype) {
    if (Object.prototype.hasOwnProperty.call(prototype, Context2.internal)) {
      return prototype[Context2.internal];
    }
    const parent = ensureInternal(Object.getPrototypeOf(prototype));
    return prototype[Context2.internal] = Object.create(parent);
  }
  __name(ensureInternal, "ensureInternal");
})(Context || (Context = {}));
Context.prototype[Context.internal] = /* @__PURE__ */ Object.create(null);
Context.service("registry", Registry);
Context.service("lifecycle", Lifecycle);
Context.mixin("state", {
  properties: ["config", "runtime"],
  methods: ["collect", "accept", "decline"]
});

// packages/cordis/src/service.ts
var import_cosmokit5 = require("cosmokit");
var Service = class {
  constructor(ctx, name, immediate) {
    this.ctx = ctx;
    getConstructor(ctx.root).service(name);
    (0, import_cosmokit5.defineProperty)(this, Context.current, ctx);
    if (immediate) {
      this[Context.immediate] = name;
    }
    ctx.on("ready", async () => {
      await Promise.resolve();
      await this.start();
      ctx[name] = this;
    });
    ctx.on("dispose", async () => {
      ctx[name] = null;
      await this.stop();
    });
  }
  start() {
  }
  stop() {
  }
  get caller() {
    return this[Context.current];
  }
};
__name(Service, "Service");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Context,
  EffectScope,
  ForkScope,
  Lifecycle,
  MainScope,
  Registry,
  Service,
  getConstructor,
  isApplicable,
  isBailed,
  isConstructor,
  resolveConfig
});
//# sourceMappingURL=index.cjs.map
