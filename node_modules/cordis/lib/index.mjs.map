{
  "version": 3,
  "sources": ["../src/context.ts", "../src/events.ts", "../src/registry.ts", "../src/scope.ts", "../src/utils.ts", "../src/service.ts"],
  "sourcesContent": ["import { defineProperty } from 'cosmokit'\nimport { Lifecycle } from './events'\nimport { Registry } from './registry'\nimport { getConstructor, isConstructor, resolveConfig } from './utils'\n\nexport interface Context {\n  [Context.config]: Context.Config\n  root: Context.Parameterized<this, this[typeof Context.config]>\n  mapping: Record<string | symbol, symbol>\n  lifecycle: Lifecycle\n  registry: Registry<this>\n}\n\nexport class Context<T = any> {\n  static readonly config = Symbol('config')\n  static readonly events = Symbol('events')\n  static readonly static = Symbol('static')\n  static readonly filter = Symbol('filter')\n  static readonly source = Symbol('source')\n  static readonly current = Symbol('current')\n  static readonly internal = Symbol('internal')\n  static readonly immediate = Symbol('immediate')\n\n  constructor(config?: Context.Config) {\n    const options = resolveConfig(getConstructor(this), config)\n    const attach = (internal: {}) => {\n      if (!internal) return\n      attach(Object.getPrototypeOf(internal))\n      for (const key of Object.getOwnPropertySymbols(internal)) {\n        this[key] = new internal[key](this, options)\n      }\n    }\n\n    this.root = this as any\n    this.mapping = Object.create(null)\n    attach(this[Context.internal])\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return `Context <${this.runtime.name}>`\n  }\n\n  get events() {\n    return this.lifecycle\n  }\n\n  extend(meta = {}): this {\n    return Object.assign(Object.create(this), meta)\n  }\n\n  isolate(names: string[]) {\n    const mapping = Object.create(this.mapping)\n    for (const name of names) {\n      mapping[name] = Symbol(name)\n    }\n    return this.extend({ mapping })\n  }\n}\n\nexport namespace Context {\n  export type Parameterized<C, T = any> = Omit<C, 'config'> & { config: T }\n\n  export interface Config extends Lifecycle.Config, Registry.Config {}\n\n  export interface MixinOptions {\n    methods?: string[]\n    properties?: string[]\n  }\n\n  export function mixin(name: keyof any, options: MixinOptions) {\n    for (const key of options.methods || []) {\n      defineProperty(Context.prototype, key, function (this: Context, ...args: any[]) {\n        return this[name][key](...args)\n      })\n    }\n\n    for (const key of options.properties || []) {\n      Object.defineProperty(Context.prototype, key, {\n        configurable: true,\n        get(this: Context) {\n          return this[name][key]\n        },\n        set(this: Context, value: any) {\n          this[name][key] = value\n        },\n      })\n    }\n  }\n\n  export interface ServiceOptions extends MixinOptions {\n    prototype?: any\n  }\n\n  export function service(name: keyof any, options: ServiceOptions = {}) {\n    const privateKey = typeof name === 'symbol' ? name : Symbol(name)\n\n    Object.defineProperty(this.prototype, name, {\n      configurable: true,\n      get(this: Context) {\n        const key = this.mapping[name as any] || privateKey\n        const value = this.root[key]\n        if (!value) return\n        defineProperty(value, Context.current, this)\n        return value\n      },\n      set(this: Context, value) {\n        const key = this.mapping[name as any] || privateKey\n        const oldValue = this.root[key]\n        if (oldValue === value) return\n\n        // setup filter for events\n        const self = Object.create(null)\n        self[Context.filter] = (ctx: Context) => {\n          return this.mapping[name] === ctx.mapping[name]\n        }\n\n        if (typeof name === 'string') {\n          this.emit(self, 'internal/before-service', name, value)\n        }\n        this.root[key] = value\n        if (value && typeof value === 'object') {\n          defineProperty(value, Context.source, this)\n        }\n        if (typeof name === 'string') {\n          this.emit(self, 'internal/service', name, oldValue)\n        }\n      },\n    })\n\n    if (isConstructor(options)) {\n      const internal = ensureInternal(this.prototype)\n      internal[privateKey] = options\n    }\n\n    mixin(name, options)\n  }\n\n  function ensureInternal(prototype: {}) {\n    if (Object.prototype.hasOwnProperty.call(prototype, Context.internal)) {\n      return prototype[Context.internal]\n    }\n    const parent = ensureInternal(Object.getPrototypeOf(prototype))\n    return prototype[Context.internal] = Object.create(parent)\n  }\n}\n\nContext.prototype[Context.internal] = Object.create(null)\n\nContext.service('registry', Registry)\nContext.service('lifecycle', Lifecycle)\n\nContext.mixin('state', {\n  properties: ['config', 'runtime'],\n  methods: ['collect', 'accept', 'decline'],\n})\n", "import { Awaitable, defineProperty, Promisify, remove } from 'cosmokit'\nimport { Context } from './context'\nimport { ForkScope, MainScope } from './scope'\nimport { Plugin } from './registry'\n\nexport function isBailed(value: any) {\n  return value !== null && value !== false && value !== undefined\n}\n\nexport type Parameters<F> = F extends (...args: infer P) => any ? P : never\nexport type ReturnType<F> = F extends (...args: any) => infer R ? R : never\nexport type ThisType<F> = F extends (this: infer T, ...args: any) => any ? T : never\nexport type GetEvents<C extends Context> = C[typeof Context.events]\n\ndeclare module './context' {\n  export interface Context {\n    [Context.events]: Events<this>\n    parallel<K extends keyof GetEvents<this>>(name: K, ...args: Parameters<GetEvents<this>[K]>): Promise<void>\n    parallel<K extends keyof GetEvents<this>>(thisArg: ThisType<GetEvents<this>[K]>, name: K, ...args: Parameters<GetEvents<this>[K]>): Promise<void>\n    emit<K extends keyof GetEvents<this>>(name: K, ...args: Parameters<GetEvents<this>[K]>): void\n    emit<K extends keyof GetEvents<this>>(thisArg: ThisType<GetEvents<this>[K]>, name: K, ...args: Parameters<GetEvents<this>[K]>): void\n    serial<K extends keyof GetEvents<this>>(name: K, ...args: Parameters<GetEvents<this>[K]>): Promisify<ReturnType<GetEvents<this>[K]>>\n    serial<K extends keyof GetEvents<this>>(thisArg: ThisType<GetEvents<this>[K]>, name: K, ...args: Parameters<GetEvents<this>[K]>): Promisify<ReturnType<GetEvents<this>[K]>>\n    bail<K extends keyof GetEvents<this>>(name: K, ...args: Parameters<GetEvents<this>[K]>): ReturnType<GetEvents<this>[K]>\n    bail<K extends keyof GetEvents<this>>(thisArg: ThisType<GetEvents<this>[K]>, name: K, ...args: Parameters<GetEvents<this>[K]>): ReturnType<GetEvents<this>[K]>\n    on<K extends keyof GetEvents<this>>(name: K, listener: GetEvents<this>[K], prepend?: boolean): () => boolean\n    once<K extends keyof GetEvents<this>>(name: K, listener: GetEvents<this>[K], prepend?: boolean): () => boolean\n    off<K extends keyof GetEvents<this>>(name: K, listener: GetEvents<this>[K]): boolean\n    start(): Promise<void>\n    stop(): Promise<void>\n  }\n}\n\nexport namespace Lifecycle {\n  export interface Config {\n    maxListeners?: number\n  }\n}\n\nexport class Lifecycle {\n  static readonly methods = ['on', 'once', 'off', 'before', 'after', 'parallel', 'emit', 'serial', 'bail', 'start', 'stop']\n\n  isActive = false\n  _tasks = new Set<Promise<void>>()\n  _hooks: Record<keyof any, [Context, (...args: any[]) => any][]> = {}\n\n  constructor(private root: Context) {\n    defineProperty(this, Context.current, root)\n    defineProperty(this.on('internal/hook', function (name, listener, prepend) {\n      const method = prepend ? 'unshift' : 'push'\n      const { state } = this[Context.current]\n      const { runtime, disposables } = state\n      if (name === 'ready' && this.isActive) {\n        this.queue(listener())\n      } else if (name === 'dispose') {\n        disposables[method](listener as any)\n        defineProperty(listener, 'name', 'event <dispose>')\n        return () => remove(disposables, listener)\n      } else if (name === 'fork') {\n        runtime.forkables[method](listener as any)\n        return state.collect('event <fork>', () => remove(runtime.forkables, listener))\n      }\n    }), Context.static, root.state)\n  }\n\n  queue(value: any) {\n    const task = Promise.resolve(value)\n      .catch(reason => this.root.emit('internal/warning', reason))\n      .then(() => this._tasks.delete(task))\n    this._tasks.add(task)\n  }\n\n  async flush() {\n    while (this._tasks.size) {\n      await Promise.all(Array.from(this._tasks))\n    }\n  }\n\n  * getHooks(name: keyof any, thisArg?: object) {\n    const hooks = this._hooks[name] || []\n    for (const [context, callback] of hooks.slice()) {\n      const filter = thisArg?.[Context.filter]\n      if (filter && !filter.call(thisArg, context)) continue\n      yield callback\n    }\n  }\n\n  async parallel(...args: any[]) {\n    const thisArg = typeof args[0] === 'object' ? args.shift() : null\n    const name = args.shift()\n    await Promise.all([...this.getHooks(name, thisArg)].map(async (callback) => {\n      await callback.apply(thisArg, args)\n    }))\n  }\n\n  emit(...args: any[]) {\n    const thisArg = typeof args[0] === 'object' ? args.shift() : null\n    const name = args.shift()\n    for (const callback of this.getHooks(name, thisArg)) {\n      callback.apply(thisArg, args)\n    }\n  }\n\n  async serial(...args: any[]) {\n    const thisArg = typeof args[0] === 'object' ? args.shift() : null\n    const name = args.shift()\n    for (const callback of this.getHooks(name, thisArg)) {\n      const result = await callback.apply(thisArg, args)\n      if (isBailed(result)) return result\n    }\n  }\n\n  bail(...args: any[]) {\n    const thisArg = typeof args[0] === 'object' ? args.shift() : null\n    const name = args.shift()\n    for (const callback of this.getHooks(name, thisArg)) {\n      const result = callback.apply(thisArg, args)\n      if (isBailed(result)) return result\n    }\n  }\n\n  register(label: string, hooks: [Context, any][], listener: any, prepend?: boolean) {\n    const maxListeners = this.root.config.maxListeners!\n    if (hooks.length >= maxListeners!) {\n      this.root.emit('internal/warning', `max listener count (${maxListeners!}) for ${label} exceeded, which may be caused by a memory leak`)\n    }\n\n    const caller = this[Context.current]\n    const method = prepend ? 'unshift' : 'push'\n    hooks[method]([caller, listener])\n    return caller.state.collect(label, () => this.unregister(hooks, listener))\n  }\n\n  unregister(hooks: [Context, any][], listener: any) {\n    const index = hooks.findIndex(([context, callback]) => callback === listener)\n    if (index >= 0) {\n      hooks.splice(index, 1)\n      return true\n    }\n  }\n\n  on(name: keyof any, listener: (...args: any) => any, prepend = false) {\n    // handle special events\n    const result = this.bail(this, 'internal/hook', name, listener, prepend)\n    if (result) return result\n\n    const hooks = this._hooks[name] ||= []\n    const label = typeof name === 'string' ? `event <${name}>` : 'event (Symbol)'\n    return this.register(label, hooks, listener, prepend)\n  }\n\n  once(name: keyof any, listener: (...args: any) => any, prepend = false) {\n    const dispose = this.on(name, function (...args: any[]) {\n      dispose()\n      return listener.apply(this, args)\n    }, prepend)\n    return dispose\n  }\n\n  off(name: keyof any, listener: (...args: any) => any) {\n    return this.unregister(this._hooks[name] || [], listener)\n  }\n\n  async start() {\n    this.isActive = true\n    for (const callback of this.getHooks('ready')) {\n      this.queue(callback())\n    }\n    delete this._hooks.ready\n    await this.flush()\n  }\n\n  async stop() {\n    this.isActive = false\n    // `dispose` event is handled by state.disposables\n    this.root.state.clear(true)\n  }\n}\n\nexport interface Events<C extends Context = Context> {\n  'fork': Plugin.Function<C['config'], C>\n  'ready'(): Awaitable<void>\n  'dispose'(): Awaitable<void>\n  'internal/fork'(fork: ForkScope<Context.Parameterized<C>>): void\n  'internal/runtime'(runtime: MainScope<Context.Parameterized<C>>): void\n  'internal/warning'(format: any, ...param: any[]): void\n  'internal/before-service'(name: string, value: any): void\n  'internal/service'(name: string, oldValue: any): void\n  'internal/before-update'(fork: ForkScope<Context.Parameterized<C>>, config: any): void\n  'internal/update'(fork: ForkScope<Context.Parameterized<C>>, oldConfig: any): void\n  'internal/hook'(this: Lifecycle, name: string, listener: Function, prepend: boolean): () => boolean\n}\n", "import { defineProperty } from 'cosmokit'\nimport { Context } from './context'\nimport { ForkScope, MainScope } from './scope'\nimport { resolveConfig } from './utils'\n\nexport function isApplicable(object: Plugin) {\n  return object && typeof object === 'object' && typeof object.apply === 'function'\n}\n\nexport type Plugin<C extends Context = Context> =\n  | Plugin.Function<any, C>\n  | Plugin.Constructor<any, C>\n  | Plugin.Object<any, any, C>\n\nexport namespace Plugin {\n  export type Function<T = any, C extends Context = any> = (ctx: C, options: T) => void\n  export type Constructor<T = any, C extends Context = any> = new (ctx: C, options: T) => void\n\n  export interface Object<S = any, T = any, C extends Context = any> {\n    name?: string\n    apply: Function<T, C>\n    reactive?: boolean\n    reusable?: boolean\n    Config?: (config?: S) => T\n    schema?: (config?: S) => T\n    using?: readonly string[]\n  }\n\n  export type Config<T extends Plugin<any>> =\n    | T extends Constructor<infer U> ? U\n    : T extends Function<infer U> ? U\n    : T extends Object<infer U> ? U\n    : never\n}\n\ndeclare module './context' {\n  export interface Context {\n    using(using: readonly string[], callback: Plugin.Function<void, Context.Parameterized<this>>): ForkScope<Context.Parameterized<this>>\n    plugin<S extends Plugin<Context.Parameterized<this>>, T extends Plugin.Config<S>>(plugin: S, config?: boolean | T): ForkScope<Context.Parameterized<this, T>>\n    /** @deprecated use `ctx.registry.delete()` instead */\n    dispose(plugin?: Plugin<Context.Parameterized<this>>): boolean\n  }\n}\n\nexport namespace Registry {\n  export interface Config {}\n}\n\nexport class Registry<C extends Context = Context> extends Map<Plugin<C>, MainScope<C>> {\n  static readonly methods = ['using', 'plugin', 'dispose']\n\n  private _counter = 0\n\n  constructor(private root: Context, config: Registry.Config) {\n    super()\n    defineProperty(this, Context.current, root)\n    root.state = new MainScope(this, null!, config)\n    root.state.runtime.isReactive = true\n  }\n\n  get counter() {\n    return ++this._counter\n  }\n\n  private resolve(plugin: Plugin) {\n    return plugin && (typeof plugin === 'function' ? plugin : plugin.apply)\n  }\n\n  get(plugin: Plugin<C>) {\n    return super.get(this.resolve(plugin))\n  }\n\n  has(plugin: Plugin<C>) {\n    return super.has(this.resolve(plugin))\n  }\n\n  set(plugin: Plugin<C>, state: MainScope<C>) {\n    return super.set(this.resolve(plugin), state)\n  }\n\n  delete(plugin: Plugin<C>) {\n    plugin = this.resolve(plugin)\n    const runtime = this.get(plugin)\n    if (!runtime) return false\n    super.delete(plugin)\n    return runtime.dispose()\n  }\n\n  using(using: readonly string[], callback: Plugin.Function<void, C>) {\n    return this.plugin({ using, apply: callback, name: callback.name })\n  }\n\n  plugin(plugin: Plugin<C>, config?: any) {\n    // check if it's a valid plugin\n    if (typeof plugin !== 'function' && !isApplicable(plugin)) {\n      throw new Error('invalid plugin, expect function or object with an \"apply\" method')\n    }\n\n    // resolve plugin config\n    config = resolveConfig(plugin, config)\n    if (!config) return\n\n    // check duplication\n    const context = this[Context.current]\n    let runtime = this.get(plugin)\n    if (runtime) {\n      if (!runtime.isForkable) {\n        this.root.emit('internal/warning', `duplicate plugin detected: ${plugin.name}`)\n      }\n      return runtime.fork(context, config)\n    }\n\n    runtime = new MainScope(this, plugin, config)\n    return runtime.fork(context, config)\n  }\n\n  dispose(plugin: Plugin<C>) {\n    return this.delete(plugin)\n  }\n}\n", "import { deepEqual, defineProperty, remove } from 'cosmokit'\nimport { Context } from './context'\nimport { Plugin, Registry } from './registry'\nimport { getConstructor, isConstructor, resolveConfig } from './utils'\n\ndeclare module './context' {\n  export interface Context<T> {\n    config: T\n    state: EffectScope<this>\n    runtime: MainScope<this>\n    collect(label: string, callback: () => boolean): () => boolean\n    accept(callback?: (config: this['config']) => void | boolean, options?: AcceptOptions): () => boolean\n    accept(keys: (keyof this['config'])[], callback?: (config: this['config']) => void | boolean, options?: AcceptOptions): () => boolean\n    decline(keys: (keyof this['config'])[]): () => boolean\n  }\n}\n\nexport type Disposable = () => void\n\nexport interface AcceptOptions {\n  passive?: boolean\n  immediate?: boolean\n}\n\nexport interface Acceptor extends AcceptOptions {\n  keys?: string[]\n  callback?: (config: any) => void | boolean\n}\n\nexport abstract class EffectScope<C extends Context = Context> {\n  uid: number | null\n  ctx: C\n  disposables: Disposable[] = []\n\n  protected proxy: any\n  protected context: Context\n  protected acceptors: Acceptor[] = []\n\n  abstract runtime: MainScope<C>\n  abstract dispose(): boolean\n  abstract start(): void\n  abstract update(config: C['config'], forced?: boolean): void\n\n  constructor(public parent: C, public config: C['config']) {\n    this.uid = parent.registry ? parent.registry.counter : 0\n    this.ctx = this.context = parent.extend({ state: this })\n    this.proxy = new Proxy({}, {\n      get: (target, key) => Reflect.get(this.config, key),\n    })\n  }\n\n  protected get _config() {\n    return this.runtime.isReactive ? this.proxy : this.config\n  }\n\n  collect(label: string, callback: () => boolean) {\n    const dispose = defineProperty(() => {\n      remove(this.disposables, dispose)\n      return callback()\n    }, 'name', label)\n    this.disposables.push(dispose)\n    return dispose\n  }\n\n  restart() {\n    this.clear(true)\n    this.start()\n  }\n\n  protected setup() {\n    if (!this.runtime.using.length) return\n    defineProperty(this.context.on('internal/before-service', (name) => {\n      if (!this.runtime.using.includes(name)) return\n      this.clear(true)\n    }), Context.static, this)\n    defineProperty(this.context.on('internal/service', (name) => {\n      if (!this.runtime.using.includes(name)) return\n      this.start()\n    }), Context.static, this)\n  }\n\n  protected checkDeps() {\n    return this.runtime.using.every(name => this.ctx[name])\n  }\n\n  clear(preserve = false) {\n    this.disposables = this.disposables.splice(0, Infinity).filter((dispose) => {\n      if (preserve && dispose[Context.static] === this) return true\n      dispose()\n    })\n  }\n\n  accept(callback?: (config: C['config']) => void | boolean, options?: AcceptOptions): () => boolean\n  accept(keys: string[], callback?: (config: C['config']) => void | boolean, options?: AcceptOptions): () => boolean\n  accept(...args: any[]) {\n    const keys = Array.isArray(args[0]) ? args.shift() : null\n    const acceptor: Acceptor = { keys, callback: args[0], ...args[1] }\n    this.acceptors.push(acceptor)\n    if (acceptor.immediate) acceptor.callback?.(this.config)\n    return this.collect(`accept <${keys?.join(', ') || '*'}>`, () => remove(this.acceptors, acceptor))\n  }\n\n  decline(keys: string[]) {\n    return this.accept(keys, () => true)\n  }\n\n  checkUpdate(resolved: any, forced?: boolean) {\n    if (forced) return [true, true]\n\n    const modified: Record<string, boolean> = Object.create(null)\n    const checkPropertyUpdate = (key: string) => {\n      const result = modified[key] ??= !deepEqual(this.config[key], resolved[key])\n      hasUpdate ||= result\n      return result\n    }\n\n    const ignored = new Set<string>()\n    let hasUpdate = false, shouldRestart = false\n    let fallback: boolean | null = this.runtime.isReactive || null\n    for (const { keys, callback, passive } of this.acceptors) {\n      if (!keys) {\n        fallback ||= !passive\n      } else if (passive) {\n        keys?.forEach(key => ignored.add(key))\n      } else {\n        let hasUpdate = false\n        for (const key of keys) {\n          hasUpdate ||= checkPropertyUpdate(key)\n        }\n        if (!hasUpdate) continue\n      }\n      const result = callback?.(resolved)\n      if (result) shouldRestart = true\n    }\n\n    for (const key in { ...this.config, ...resolved }) {\n      if (fallback === false) continue\n      if (!(key in modified) && !ignored.has(key)) {\n        const hasUpdate = checkPropertyUpdate(key)\n        if (fallback === null) shouldRestart ||= hasUpdate\n      }\n    }\n    return [hasUpdate, shouldRestart]\n  }\n}\n\nexport class ForkScope<C extends Context = Context> extends EffectScope<C> {\n  dispose: () => boolean\n\n  constructor(parent: Context, config: C['config'], public runtime: MainScope<C>) {\n    super(parent as C, config)\n\n    this.dispose = defineProperty(parent.state.collect(`fork <${parent.runtime.name}>`, () => {\n      this.uid = null\n      this.clear()\n      const result = remove(runtime.disposables, this.dispose)\n      if (remove(runtime.children, this) && !runtime.children.length) {\n        parent.registry.delete(runtime.plugin)\n      }\n      this.context.emit('internal/fork', this)\n      return result\n    }), Context.static, runtime)\n\n    runtime.children.push(this)\n    runtime.disposables.push(this.dispose)\n    this.context.emit('internal/fork', this)\n    if (runtime.isReusable) {\n      // non-reusable plugin forks are not responsive to isolated service changes\n      this.setup()\n    }\n    this.start()\n  }\n\n  start() {\n    if (!this.checkDeps()) return\n    for (const fork of this.runtime.forkables) {\n      this.ctx.lifecycle.queue(fork(this.context, this._config))\n    }\n  }\n\n  update(config: any, forced?: boolean) {\n    const oldConfig = this.config\n    const state: EffectScope<C> = this.runtime.isForkable ? this : this.runtime\n    if (state.config !== oldConfig) return\n    const resolved = resolveConfig(this.runtime.plugin, config)\n    const [hasUpdate, shouldRestart] = state.checkUpdate(resolved, forced)\n    this.context.emit('internal/before-update', this, config)\n    this.config = resolved\n    state.config = resolved\n    if (hasUpdate) {\n      this.context.emit('internal/update', this, oldConfig)\n    }\n    if (shouldRestart) state.restart()\n  }\n}\n\nexport class MainScope<C extends Context = Context> extends EffectScope<C> {\n  runtime = this\n  schema: any\n  using: readonly string[] = []\n  forkables: Function[] = []\n  children: ForkScope<C>[] = []\n  isReusable = false\n  isReactive = false\n\n  constructor(registry: Registry<C>, public plugin: Plugin, config: any) {\n    super(registry[Context.current] as C, config)\n    registry.set(plugin, this)\n    if (plugin) this.setup()\n  }\n\n  get isForkable() {\n    return this.forkables.length > 0\n  }\n\n  get name() {\n    if (!this.plugin) return 'root'\n    const { name } = this.plugin\n    return !name || name === 'apply' ? 'anonymous' : name\n  }\n\n  fork(parent: Context, config: any) {\n    return new ForkScope(parent, config, this)\n  }\n\n  dispose() {\n    this.uid = null\n    this.clear()\n    this.context.emit('internal/runtime', this)\n    return true\n  }\n\n  setup() {\n    this.schema = this.plugin['Config'] || this.plugin['schema']\n    this.using = this.plugin['using'] || []\n    this.isReusable = this.plugin['reusable']\n    this.isReactive = this.plugin['reactive']\n    this.context.emit('internal/runtime', this)\n\n    if (this.isReusable) {\n      this.forkables.push(this.apply)\n    } else {\n      super.setup()\n    }\n\n    this.restart()\n  }\n\n  private apply = (context: Context, config: any) => {\n    if (typeof this.plugin !== 'function') {\n      const instance = this.plugin.apply(context, config)\n      this.ctx.lifecycle.queue(instance)\n    } else if (isConstructor(this.plugin)) {\n      // eslint-disable-next-line new-cap\n      const instance = new this.plugin(context, config)\n      const name = instance[Context.immediate]\n      if (name) {\n        context[name] = instance\n      }\n      if (instance['fork']) {\n        this.forkables.push(instance['fork'].bind(instance))\n      }\n    } else {\n      const instance = this.plugin(context, config)\n      this.ctx.lifecycle.queue(instance)\n    }\n  }\n\n  clear(preserve?: boolean) {\n    super.clear(preserve)\n    for (const fork of this.children) {\n      fork.clear(preserve)\n    }\n  }\n\n  start() {\n    if (!this.checkDeps()) return\n\n    // execute plugin body\n    if (!this.isReusable && this.plugin) {\n      this.apply(this.context, this._config)\n    }\n\n    for (const fork of this.children) {\n      fork.start()\n    }\n  }\n\n  update(config: C['config'], forced?: boolean) {\n    if (this.isForkable) {\n      this.context.emit('internal/warning', `attempting to update forkable plugin \"${this.plugin.name}\", which may lead to unexpected behavior`)\n    }\n    const oldConfig = this.config\n    const resolved = resolveConfig(this.runtime.plugin || getConstructor(this.context), config)\n    const [hasUpdate, shouldRestart] = this.checkUpdate(resolved, forced)\n    const state = this.children.find(fork => fork.config === oldConfig)\n    this.config = resolved\n    if (state) {\n      this.context.emit('internal/before-update', state, config)\n      state.config = resolved\n      if (hasUpdate) {\n        this.context.emit('internal/update', state, oldConfig)\n      }\n    }\n    if (shouldRestart) this.restart()\n  }\n}\n", "export function isConstructor(func: any): func is new (...args: any) => any {\n  // async function or arrow function\n  if (!func.prototype) return false\n  // generator function or malformed definition\n  if (func.prototype.constructor !== func) return false\n  return true\n}\n\nexport function getConstructor(instance: any) {\n  return Object.getPrototypeOf(instance).constructor\n}\n\nexport function resolveConfig(plugin: any, config: any) {\n  if (config === false) return\n  if (config === true) config = undefined\n  config ??= {}\n\n  const schema = plugin['Config'] || plugin['schema']\n  if (schema && plugin['schema'] !== false) config = schema(config)\n  return config\n}\n", "import { Awaitable, defineProperty } from 'cosmokit'\nimport { Context } from './context'\nimport { getConstructor } from './utils'\n\nexport class Service<C extends Context = Context> {\n  protected start(): Awaitable<void> {}\n  protected stop(): Awaitable<void> {}\n  protected fork?(ctx: C, config: any): void\n\n  constructor(protected ctx: C, name: string, immediate?: boolean) {\n    getConstructor(ctx.root).service(name)\n    defineProperty(this, Context.current, ctx)\n\n    if (immediate) {\n      this[Context.immediate] = name\n    }\n\n    ctx.on('ready', async () => {\n      // await until next tick because derived class has not been initialized yet\n      await Promise.resolve()\n      await this.start()\n      ctx[name] = this\n    })\n\n    ctx.on('dispose', async () => {\n      ctx[name] = null\n      await this.stop()\n    })\n  }\n\n  get caller() {\n    return this[Context.current] as C\n  }\n}\n"],
  "mappings": "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",
  "names": ["defineProperty", "defineProperty", "defineProperty", "remove", "defineProperty", "remove", "hasUpdate", "defineProperty", "Context", "defineProperty", "defineProperty", "defineProperty"]
}
