{
  "version": 3,
  "sources": ["../src/index.ts", "../src/misc.ts", "../src/observe.ts", "../src/string.ts"],
  "sourcesContent": ["import Schema from 'schemastery'\nimport Logger from 'reggol'\nimport Random from 'inaba'\n\nexport { is as isType } from 'cosmokit'\nexport { Schema, Logger, Random }\n\nexport * from 'cosmokit'\nexport * from './misc'\nexport * from './observe'\nexport * from './string'\n", "export function isInteger(source: any) {\n  return typeof source === 'number' && Math.floor(source) === source\n}\n\nexport async function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms))\n}\n\nexport function enumKeys<T extends string>(data: Record<T, string | number>) {\n  return Object.values(data).filter(value => typeof value === 'string') as T[]\n}\n\nexport function defineEnumProperty<T extends object>(object: T, key: keyof T, value: T[keyof T]) {\n  object[key] = value\n  object[value as any] = key\n}\n\nexport function merge<T extends object>(head: T, base: T): T {\n  Object.entries(base).forEach(([key, value]) => {\n    if (typeof head[key] === 'undefined') return head[key] = base[key]\n    if (typeof value === 'object' && typeof head[key] === 'object') {\n      head[key] = merge(head[key], value)\n    }\n  })\n  return head\n}\n\nexport function assertProperty<O, K extends keyof O & string>(config: O, key: K) {\n  if (!config[key]) throw new Error(`missing configuration \"${key}\"`)\n  return config[key]\n}\n\nexport function coerce(val: any) {\n  // resolve error when stack is undefined, e.g. axios error with status code 401\n  const { message, stack } = val instanceof Error && val.stack ? val : new Error(val as any)\n  const lines = stack.split('\\n')\n  const index = lines.findIndex(line => line.endsWith(message))\n  return lines.slice(index).join('\\n')\n}\n\nexport function renameProperty<O extends object, K extends keyof O, T extends string>(config: O, key: K, oldKey: T) {\n  config[key] = Reflect.get(config, oldKey) as any\n  Reflect.deleteProperty(config, oldKey)\n}\n\ntype Methods<T> = {\n  [K in keyof T]?: T[K] extends (...args: infer A) => infer R ? (this: T, ...args: A) => R : T[K]\n}\n\nexport function extend<T>(prototype: T, methods: Methods<T>) {\n  Object.defineProperties(prototype, Object.getOwnPropertyDescriptors(methods))\n}\n", "import { defineProperty, is, noop } from 'cosmokit'\n\nconst immutable = ['number', 'string', 'bigint', 'boolean', 'symbol', 'function']\nconst builtin = ['Date', 'RegExp', 'Set', 'Map', 'WeakSet', 'WeakMap', 'Array']\n\nfunction observeProperty(value: any, update: any) {\n  if (is('Date', value)) {\n    return observeDate(value, update)\n  } else if (Array.isArray(value)) {\n    return observeArray(value, update)\n  } else {\n    return observeObject(value, update)\n  }\n}\n\nfunction untracked(key: string | symbol) {\n  return typeof key === 'symbol' || key.startsWith('$')\n}\n\nfunction observeObject<T extends object>(target: T, notify?: (key: string | symbol) => void): T {\n  const update = notify\n  if (!notify) {\n    const diff = Object.create(null)\n    defineProperty(target, '$diff', diff)\n    notify = (key) => {\n      if (untracked(key)) return\n      diff[key] = target[key]\n    }\n  }\n\n  const proxy = new Proxy(target as Observed<T>, {\n    get(target, key) {\n      const value = Reflect.get(target, key)\n      if (!value || immutable.includes(typeof value) || untracked(key)) return value\n      return observeProperty(value, update || (() => notify(key)))\n    },\n    set(target, key, value) {\n      const unchanged = target[key] === value\n      const result = Reflect.set(target, key, value)\n      if (unchanged || !result) return result\n      notify(key)\n      return true\n    },\n    deleteProperty(target, key) {\n      const unchanged = !(key in target)\n      const result = Reflect.deleteProperty(target, key)\n      if (unchanged || !result) return result\n      notify(key)\n      return true\n    },\n  })\n\n  return proxy\n}\n\nconst arrayProxyMethods = ['pop', 'shift', 'splice', 'sort']\n\nfunction observeArray<T>(target: T[], update: () => void) {\n  const proxy: Record<number, T> = {}\n\n  for (const method of arrayProxyMethods) {\n    defineProperty(target, method, function (...args: any[]) {\n      update()\n      return Array.prototype[method].apply(this, args)\n    })\n  }\n\n  return new Proxy(target, {\n    get(target, key) {\n      if (key in proxy) return proxy[key]\n      const value = target[key]\n      if (!value || immutable.includes(typeof value) || typeof key === 'symbol' || isNaN(key as any)) return value\n      return observeProperty(value, update)\n    },\n    set(target, key, value) {\n      if (typeof key !== 'symbol' && !isNaN(key as any) && target[key] !== value) update()\n      return Reflect.set(target, key, value)\n    },\n  })\n}\n\nfunction observeDate(target: Date, update: () => void) {\n  for (const method of Object.getOwnPropertyNames(Date.prototype)) {\n    if (method === 'valueOf') continue\n    defineProperty(target, method, function (...args: any[]) {\n      const oldValue = target.valueOf()\n      const result = Date.prototype[method].apply(this, args)\n      if (target.valueOf() !== oldValue) update()\n      return result\n    })\n  }\n  return target\n}\n\nexport type Observed<T, R = any> = T & {\n  $diff: Partial<T>\n  $update: () => R\n  $merge: (value: Partial<T>) => Observed<T, R>\n}\n\ntype UpdateFunction<T, R> = (diff: Partial<T>) => R\n\nexport function observe<T extends object>(target: T, label?: string | number): Observed<T, void>\nexport function observe<T extends object, R>(target: T, update: UpdateFunction<T, R>, label?: string | number): Observed<T, R>\nexport function observe<T extends object, R>(target: T, ...args: [(string | number)?] | [UpdateFunction<T, R>, (string | number)?]) {\n  if (immutable.includes(typeof target)) {\n    throw new Error(`cannot observe immutable type \"${typeof target}\"`)\n  } else if (!target) {\n    throw new Error('cannot observe null or undefined')\n  }\n\n  const type = Object.prototype.toString.call(target).slice(8, -1)\n  if (builtin.includes(type)) {\n    throw new Error(`cannot observe instance of type \"${type}\"`)\n  }\n\n  let update: UpdateFunction<T, R> = noop\n  if (typeof args[0] === 'function') update = args.shift() as any\n\n  const observer = observeObject(target, null) as Observed<T>\n\n  defineProperty(observer, '$update', function $update(this: Observed<T>) {\n    const diff = { ...this.$diff }\n    const fields = Object.keys(diff)\n    if (fields.length) {\n      for (const key in this.$diff) {\n        delete this.$diff[key]\n      }\n      return update(diff)\n    }\n  })\n\n  defineProperty(observer, '$merge', function $merge(this: Observed<T>, value: Partial<T>) {\n    for (const key in value) {\n      if (key in this.$diff) {\n        throw new Error(`unresolved diff key \"${key}\"`)\n      }\n      target[key] = value[key]\n    }\n    return this\n  })\n\n  return observer\n}\n", "// eslint-disable-next-line no-new-func\nconst evaluate = new Function('context', 'expr', `\n  try {\n    with (context) {\n      return eval(expr)\n    }\n  } catch {}\n`) as ((context: object, expr: string) => any)\n\nexport function interpolate(template: string, context: object, pattern = /\\{\\{([\\s\\S]+?)\\}\\}/g) {\n  let capture: RegExpExecArray\n  let result = '', lastIndex = 0\n  while ((capture = pattern.exec(template))) {\n    if (capture[0] === template) {\n      return evaluate(context, capture[1])\n    }\n    result += template.slice(lastIndex, capture.index)\n    result += evaluate(context, capture[1]) ?? ''\n    lastIndex = capture.index + capture[0].length\n  }\n  return result + template.slice(lastIndex)\n}\n\nexport function escapeRegExp(source: string) {\n  return source\n    .replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n    .replace(/-/g, '\\\\x2d')\n}\n"],
  "mappings": "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",
  "names": ["Logger", "Random", "Schema", "import_cosmokit", "target"]
}
