var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// koishi/packages/core/src/index.ts
var src_exports = {};
__export(src_exports, {
  App: () => Context,
  Argv: () => Argv,
  Channel: () => Channel,
  Command: () => Command,
  Commander: () => Commander,
  DatabaseService: () => DatabaseService,
  I18n: () => I18n,
  Internal: () => Internal,
  Next: () => Next,
  Service: () => Service2,
  SessionError: () => SessionError,
  SharedCache: () => SharedCache,
  User: () => User,
  defineConfig: () => defineConfig,
  defineDriver: () => defineDriver,
  resolveConfig: () => resolveConfig,
  version: () => version
});
import { version } from "../package.json";
export * from "@koishijs/utils";
export * from "@minatojs/core";

// koishi/packages/core/src/bot.ts
var bot_exports = {};
__reExport(bot_exports, core_star);
import { makeArray, sleep } from "@koishijs/utils";
import { Bot } from "@satorijs/core";
import * as core_star from "@satorijs/core";
Bot.prototype.getGuildMemberMap = /* @__PURE__ */ __name(async function getGuildMemberMap(guildId) {
  const list = await this.getGuildMemberList(guildId);
  return Object.fromEntries(list.map((info) => [info.userId, info.nickname || info.username]));
}, "getGuildMemberMap");
Bot.prototype.broadcast = /* @__PURE__ */ __name(async function broadcast(channels, content, delay = this.ctx.root.config.delay.broadcast) {
  const messageIds = [];
  for (let index = 0; index < channels.length; index++) {
    if (index && delay)
      await sleep(delay);
    try {
      const [channelId, guildId] = makeArray(channels[index]);
      messageIds.push(...await this.sendMessage(channelId, content, guildId));
    } catch (error) {
      this.ctx.logger("bot").warn(error);
    }
  }
  return messageIds;
}, "broadcast");

// koishi/packages/core/src/index.ts
__reExport(src_exports, bot_exports);

// koishi/packages/core/src/context.ts
import { defineProperty, Time } from "cosmokit";
import { Context, Schema } from "@satorijs/core";
import * as cordis from "cordis";
import { resolveConfig } from "cordis";
var Service2 = cordis.Service;
defineProperty(Context.Config, "Basic", Schema.object({
  locale: Schema.string().default("zh").description("默认使用的语言。"),
  prefix: Schema.union([
    Schema.array(String),
    Schema.transform(String, (prefix) => [prefix]),
    Schema.function()
  ]).default([""]).description("指令前缀字符构成的数组。将被用于指令的匹配。"),
  nickname: Schema.union([
    Schema.array(String),
    Schema.transform(String, (nickname) => [nickname])
  ]).description("机器人昵称构成的数组。将被用于指令的匹配。"),
  autoAssign: Schema.union([Boolean, Function]).default(true).description("当获取不到频道数据时，是否使用接受者作为代理者。"),
  autoAuthorize: Schema.union([Schema.natural(), Function]).default(1).description("当获取不到用户数据时默认使用的权限等级。"),
  minSimilarity: Schema.percent().default(0.64).description("用于模糊匹配的相似系数，应该是一个 0 到 1 之间的数值。数值越高，模糊匹配越严格。设置为 1 可以完全禁用模糊匹配。")
}).description("基础设置"));
defineProperty(Context.Config, "Message", Schema.object({
  delay: Schema.object({
    character: Schema.natural().role("ms").default(0).description("调用 `session.sendQueued()` 时消息间发送的最小延迟，按前一条消息的字数计算。"),
    message: Schema.natural().role("ms").default(0.1 * Time.second).description("调用 `session.sendQueued()` 时消息间发送的最小延迟，按固定值计算。"),
    cancel: Schema.natural().role("ms").default(0).description("调用 `session.cancelQueued()` 时默认的延迟。"),
    broadcast: Schema.natural().role("ms").default(0.5 * Time.second).description("调用 `bot.broadcast()` 时默认的延迟。"),
    prompt: Schema.natural().role("ms").default(Time.minute).description("调用 `session.prompt()` 时默认的等待时间。")
  })
}).description("消息设置"));
defineProperty(Context.Config, "Advanced", Schema.object({
  maxListeners: Schema.natural().default(64).description("每种监听器的最大数量。如果超过这个数量，Koishi 会认定为发生了内存泄漏，将产生一个警告。")
}).description("高级设置"));
Context.Config.list.push(Context.Config.Basic, Context.Config.Message, Context.Config.Advanced);
function defineConfig(config) {
  return config;
}
__name(defineConfig, "defineConfig");

// koishi/packages/core/src/database.ts
import { defineProperty as defineProperty2 } from "cosmokit";
import { Database } from "@minatojs/core";
import { Context as Context2 } from "@satorijs/core";
var User;
((User2) => {
  let Flag;
  ((Flag2) => {
    Flag2[Flag2["ignore"] = 1] = "ignore";
  })(Flag = User2.Flag || (User2.Flag = {}));
  User2.fields = [];
})(User || (User = {}));
var Channel;
((Channel2) => {
  let Flag;
  ((Flag2) => {
    Flag2[Flag2["ignore"] = 1] = "ignore";
    Flag2[Flag2["silent"] = 4] = "silent";
  })(Flag = Channel2.Flag || (Channel2.Flag = {}));
  Channel2.fields = [];
})(Channel || (Channel = {}));
var DatabaseService = class extends Database {
  constructor(app) {
    super();
    this.app = app;
    defineProperty2(this, Context2.current, app);
    this.extend("user", {
      id: "unsigned(20)",
      name: { type: "string", length: 63 },
      flag: "unsigned(20)",
      authority: "unsigned(4)",
      locale: "string(63)"
    }, {
      autoInc: true
    });
    this.extend("channel", {
      id: "string(63)",
      platform: "string(63)",
      flag: "unsigned(20)",
      assignee: "string(63)",
      guildId: "string(63)",
      locale: "string(63)"
    }, {
      primary: ["id", "platform"]
    });
    app.on("bot-added", (bot) => {
      if (bot.platform in this.tables.user.fields)
        return;
      this.extend("user", {
        [bot.platform]: { type: "string", length: 63 }
      }, {
        unique: [bot.platform]
      });
    });
  }
  async getUser(platform, id, modifier) {
    const data = await this.get("user", { [platform]: id }, modifier);
    if (Array.isArray(id))
      return data;
    if (data[0])
      Object.assign(data[0], { [platform]: id });
    return data[0];
  }
  setUser(platform, id, data) {
    return this.set("user", { [platform]: id }, data);
  }
  createUser(platform, id, data) {
    return this.create("user", { [platform]: id, ...data });
  }
  async getChannel(platform, id, modifier) {
    const data = await this.get("channel", { platform, id }, modifier);
    if (Array.isArray(id))
      return data;
    if (data[0])
      Object.assign(data[0], { platform, id });
    return data[0];
  }
  getSelfIds(type, assignees) {
    if (type) {
      assignees ||= this.app.bots.filter((bot) => bot.platform === type).map((bot) => bot.selfId);
      return { [type]: assignees };
    }
    const platforms = {};
    for (const bot of this.app.bots) {
      (platforms[bot.platform] ||= []).push(bot.selfId);
    }
    return platforms;
  }
  async getAssignedChannels(fields, assignMap = this.getSelfIds()) {
    return this.get("channel", {
      $or: Object.entries(assignMap).map(([platform, assignee]) => ({ platform, assignee }))
    }, fields);
  }
  setChannel(platform, id, data) {
    return this.set("channel", { platform, id }, data);
  }
  createChannel(platform, id, data) {
    return this.create("channel", { platform, id, ...data });
  }
  async broadcast(...args) {
    let channels;
    if (Array.isArray(args[0]))
      channels = args.shift();
    const [content, forced] = args;
    if (!content)
      return [];
    const data = await this.getAssignedChannels(["id", "assignee", "flag", "platform", "guildId"]);
    const assignMap = {};
    for (const { id, assignee, flag, platform, guildId } of data) {
      if (channels && !channels.includes(`${platform}:${id}`))
        continue;
      if (!forced && flag & 4 /* silent */)
        continue;
      ((assignMap[platform] ||= {})[assignee] ||= []).push([id, guildId]);
    }
    return (await Promise.all(Object.entries(assignMap).flatMap(([platform, map]) => {
      return this.app.bots.map((bot) => {
        if (bot.platform !== platform)
          return Promise.resolve([]);
        return bot.broadcast(map[bot.selfId] || [], content);
      });
    }))).flat(1);
  }
};
__name(DatabaseService, "DatabaseService");
__publicField(DatabaseService, "methods", ["getSelfIds", "broadcast"]);
DatabaseService.prototype.extend = /* @__PURE__ */ __name(function extend(name, fields, config) {
  Database.prototype.extend.call(this, name, fields, {
    ...config
  });
  this.app.emit("model", name);
}, "extend");
Context2.service("database");
Context2.service("model", DatabaseService);
var defineDriver = /* @__PURE__ */ __name((constructor, schema, prepare) => ({
  name: constructor.name,
  reusable: true,
  Config: schema,
  apply(ctx, config) {
    config = { ...config };
    prepare?.(ctx, config);
    const driver = new constructor(ctx.model, config);
    const key = ctx.mapping.database || "default";
    ctx.on("ready", async () => {
      await driver.start();
      ctx.model.drivers[key] = driver;
      ctx.model.refresh();
      const database = Object.create(ctx.model);
      ctx.database = database;
    });
    ctx.on("dispose", async () => {
      ctx.database = null;
      delete ctx.model.drivers[key];
      await driver.stop();
    });
  }
}), "defineDriver");

// koishi/packages/core/src/i18n.ts
import { Random } from "@koishijs/utils";
import { distance } from "fastest-levenshtein";
import { isNullable } from "cosmokit";
import { Context as Context3, Logger, segment } from "@satorijs/core";

// koishi/packages/core/src/locales/zh-CN.yml
var zh_CN_default = { general: { name: "中文", paren: "（{0}）", quote: "“{0}”", comma: "，", and: "和", or: "或", day: "天", hour: "小时", minute: "分钟", second: "秒" }, internal: { "low-authority": "权限不足。", "insufficient-arguments": "缺少参数，输入帮助以查看用法。", "redunant-arguments": "存在多余参数，输入帮助以查看用法。", "invalid-argument": "参数 {0} 输入无效，{1}", "unknown-option": "存在未知选项 {0}，输入帮助以查看用法。", "invalid-option": "选项 {0} 输入无效，{1}", "check-syntax": "输入帮助以查看用法。", "invalid-number": "请提供一个数字。", "invalid-integer": "请提供一个整数。", "invalid-posint": "请提供一个正整数。", "invalid-natural": "请提供一个非负整数。", "invalid-date": "请输入合法的时间。", "invalid-user": "请指定正确的用户。", "invalid-channel": "请指定正确的频道。", "suggest-hint": "您要找的是不是{0}？", "suggest-command": "发送句号以使用推测的指令。" } };

// koishi/packages/core/src/locales/en-US.yml
var en_US_default = { general: { name: "English", paren: " ({0}) ", quote: '"{0}"', comma: ", ", and: "and", or: "or", day: "day", hour: "hour", minute: "minute", second: "second" }, internal: { "low-authority": "Low authority.", "insufficient-arguments": "Insufficient arguments, type help to see usage.", "redunant-arguments": "Redunant arguments, type help to see usage.", "invalid-argument": "Invalid argument {0}, {1}", "unknown-option": "Unknown option {0}, type help to see usage.", "invalid-option": "Invalid option {0}, {1}", "check-syntax": "Type help to see usage.", "invalid-number": "Expect a number.", "invalid-integer": "Expect an integer.", "invalid-posint": "Expect a positive integer.", "invalid-natural": "Expect a non-negative integer.", "invalid-date": "Expect a valid date.", "invalid-user": "Expect a valid user.", "invalid-channel": "Expect a valid channel.", "suggest-hint": "Do you mean {0}?", "suggest-command": "Send a period to apply the suggestion." } };

// koishi/packages/core/src/locales/ja-JP.yml
var ja_JP_default = { general: { name: "日本語", paren: "（{0}）", quote: "「{0}」", comma: "、", and: "と", or: "や", day: "日", hour: "時間", minute: "分", second: "秒" }, internal: { "low-authority": "実行できる権限が付与されていません", "insufficient-arguments": "パラメータが不足しています、「help」を送信して使い方を確認してください。", "redunant-arguments": "パラメータ数が多すぎます、「help」を送信して使い方を確認してください。", "invalid-argument": "無効なパラメータ「{0}」、{1}", "unknown-option": "未知なオプション「{0}」、「help」を送信して使い方を確認してください。", "invalid-option": "無効なオプション「{0}」、{1}", "check-syntax": "「help」を送信して使い方を検索してください。", "invalid-number": "数字を指定してください。", "invalid-integer": "整数を指定してください。", "invalid-posint": "正の整数を指定してください。", "invalid-natural": "自然数を指定してください。", "invalid-date": "日付を指定してください。", "invalid-user": "ユーザー名を指定してください。", "invalid-channel": "チャンネル名を指定してください。", "suggest-hint": "「{0}」を実行したいですか？", "suggest-command": "句点を送信してコマンドを実行します。" } };

// koishi/packages/core/src/locales/fr-FR.yml
var fr_FR_default = { general: { name: "francais", paren: " ({0}) ", quote: '"{0}"', comma: ", ", and: "et", or: "ou", day: "jour", hour: "heure", minute: "minute", second: "seconde" }, internal: { "low-authority": "Droits insuffisants.", "insufficient-arguments": `Arguments insuffisants, tapez "help" pour afficher l'aide`, "redunant-arguments": `Arguments redondants, tapez "help" pour afficher l'aide`, "invalid-argument": "Arguments {0} invalides, {1}", "unknown-option": `Option {0} inconnue, tapez "help" pour afficher l'aide`, "invalid-option": "Option {0} invalide, {1}", "check-syntax": `Tapez "help" pour afficher l'aide`, "invalid-number": "Entrez un nombre.", "invalid-integer": "Entrez un entier.", "invalid-posint": "Entrez un entier positif.", "invalid-natural": "Entrez un entier non négatif.", "invalid-date": "Entrez une date valide.", "invalid-user": "Entrez un nom d'utilisateur valide.", "invalid-channel": "Entrez un nom de canal valide.", "suggest-hint": "Voulez-vous dire {0} ?", "suggest-command": "Tapez un point pour appliquer la suggestion." } };

// koishi/packages/core/src/locales/zh-TW.yml
var zh_TW_default = { general: { name: "中文", paren: "（{0}）", quote: "「{0}」", comma: "，", and: "和", or: "或", day: "天", hour: "小時", minute: "分鐘", second: "秒" }, internal: { "low-authority": "權限不足。", "insufficient-arguments": "參數個數不足，輸入「help」檢視用法。", "redunant-arguments": "參數個數冗餘，輸入「help」檢視用法。", "invalid-argument": "參數 {0} 無效，{1}", "unknown-option": "存在未知選項 {0}，輸入「help」檢視用法。", "invalid-option": "選項 {0} 無效，{1}", "check-syntax": "輸入「help」檢視用法。", "invalid-number": "請輸入有效數字。", "invalid-integer": "請輸入有效整數。", "invalid-posint": "請輸入有效正整數。", "invalid-natural": "請輸入有效非負整數。", "invalid-date": "請輸入有效時間。", "invalid-user": "請指定有效用戶。", "invalid-channel": "請指定有效頻道。", "suggest-hint": "你想輸入的是{0}嗎？", "suggest-command": "發送句號可使用推測的指令。" } };

// koishi/packages/core/src/i18n.ts
var logger = new Logger("i18n");
var kTemplate = Symbol("template");
var I18n = class {
  constructor(ctx) {
    this.ctx = ctx;
    this.define("", { "": "" });
    this.define("zh", zh_CN_default);
    this.define("en", en_US_default);
    this.define("ja", ja_JP_default);
    this.define("fr", fr_FR_default);
    this.define("zh-TW", zh_TW_default);
    this.registerBuiltins();
  }
  _data = {};
  _presets = {};
  compare(expect, actual, options = {}) {
    const value = 1 - distance(expect, actual) / expect.length;
    const threshold = options.minSimilarity ?? this.ctx.root.config.minSimilarity;
    return value >= threshold ? value : 0;
  }
  set(locale, prefix, value) {
    if (prefix.includes("@") || typeof value === "string") {
      const dict = this._data[locale];
      const [path, preset] = prefix.slice(0, -1).split("@");
      if (preset) {
        value[kTemplate] = preset;
        logger.warn("preset is deprecated and will be removed in the future");
      }
      if (!isNullable(dict[path]) && !locale.startsWith("$")) {
        logger.warn("override", locale, path);
      }
      dict[path] = value;
      this[Context3.current]?.on("dispose", () => {
        delete dict[path];
      });
    } else {
      for (const key in value) {
        this.set(locale, prefix + key + ".", value[key]);
      }
    }
  }
  define(locale, ...args) {
    this._data[locale] ||= {};
    if (typeof args[0] === "string") {
      this.set(locale, args[0] + ".", args[1]);
    } else {
      this.set(locale, "", args[0]);
    }
    this.ctx.emit("internal/i18n");
  }
  formatter(name, callback) {
    logger.warn("formatter is deprecated and will be removed in the future");
  }
  preset(name, callback) {
    this._presets[name] = callback;
  }
  find(path, actual, options = {}) {
    if (!actual)
      return [];
    const groups = [];
    path = path.replace(/\(([^)]+)\)/g, (_, name) => {
      groups.push(name);
      return "([^.]+)";
    });
    const pattern = new RegExp(`^${path}$`);
    const results = [];
    for (const locale in this._data) {
      for (const path2 in this._data[locale]) {
        const capture = pattern.exec(path2);
        if (!capture)
          continue;
        const expect = this._data[locale][path2];
        if (typeof expect !== "string")
          continue;
        const similarity = this.compare(expect, actual, options);
        if (!similarity)
          continue;
        const data = {};
        for (let i = 0; i < groups.length; i++) {
          data[groups[i]] = capture[i + 1];
        }
        results.push({ locale, data, similarity });
      }
    }
    return results;
  }
  render(value, params, locale) {
    if (value === void 0)
      return;
    if (typeof value !== "string") {
      const preset = value[kTemplate];
      const render = this._presets[preset];
      if (!render)
        throw new Error(`Preset "${preset}" not found`);
      return render(value, params, locale);
    }
    return segment.parse(value, params).join("");
  }
  text(locales, paths, params) {
    const queue = /* @__PURE__ */ new Set();
    for (const locale of locales) {
      if (!locale)
        continue;
      queue.add(locale);
    }
    for (const locale in this._data) {
      if (locale.startsWith("$"))
        continue;
      queue.add(locale);
    }
    for (const path of paths) {
      for (const locale of queue) {
        for (const key of ["$" + locale, locale]) {
          const value = this._data[key]?.[path];
          if (value === void 0)
            continue;
          return this.render(value, params, locale);
        }
      }
    }
    logger.warn("missing", paths[0]);
    return paths[0];
  }
  registerBuiltins() {
    this.preset("plural", (data, params, locale) => {
      const path = params.length in data ? params.length : data.length - 1;
      return this.render(data[path], params, locale);
    });
    this.preset("random", (data, params, locale) => {
      return this.render(Random.pick(data), params, locale);
    });
    this.preset("list", (data, params, locale) => {
      const list = Object.entries(params).map(([key, value]) => {
        return this.render(data.item, { key, value }, locale);
      });
      list.unshift(this.render(data.header, params, locale));
      list.push(this.render(data.footer, params, locale));
      return list.join("\n").trim();
    });
  }
};
__name(I18n, "I18n");
Context3.service("i18n", I18n);

// koishi/packages/core/src/internal.ts
import { coerce, escapeRegExp, makeArray as makeArray2, Random as Random2 } from "@koishijs/utils";
import { defineProperty as defineProperty3, Time as Time2 } from "cosmokit";
import { Context as Context4, segment as segment2 } from "@satorijs/core";
var SessionError = class extends Error {
  constructor(path, param) {
    super(makeArray2(path)[0]);
    this.path = path;
    this.param = param;
  }
};
__name(SessionError, "SessionError");
function createLeadingRE(patterns, prefix = "", suffix = "") {
  return patterns.length ? new RegExp(`^${prefix}(${patterns.map(escapeRegExp).join("|")})${suffix}`) : /$^/;
}
__name(createLeadingRE, "createLeadingRE");
var Next;
((Next2) => {
  Next2.MAX_DEPTH = 64;
  async function compose(callback, next) {
    return typeof callback === "function" ? callback(next) : callback;
  }
  Next2.compose = compose;
  __name(compose, "compose");
})(Next || (Next = {}));
var Internal = class {
  constructor(ctx, config) {
    this.ctx = ctx;
    this.config = config;
    defineProperty3(this, Context4.current, ctx);
    this.prepare();
    this.middleware(this._process.bind(this), true);
    ctx.on("message", this._handleMessage.bind(this));
    ctx.before("attach-user", (session, fields) => {
      session.collect("user", session.argv, fields);
    });
    ctx.before("attach-channel", (session, fields) => {
      session.collect("channel", session.argv, fields);
    });
    this.component("execute", async (attrs, children, session) => {
      return session.execute(children.join(""), true);
    });
    this.component("prompt", async (attrs, children, session) => {
      await session.send(children);
      return session.prompt();
    });
    this.component("i18n", async (attrs, children, session) => {
      return session.text(attrs.path);
    });
    this.component("random", async (attrs, children, session) => {
      return Random2.pick(children);
    });
    this.component("plural", async (attrs, children, session) => {
      const path = attrs.count in children ? attrs.count : children.length - 1;
      return children[path];
    });
    const units = ["day", "hour", "minute", "second"];
    this.component("i18n:time", (attrs, children, session) => {
      let ms = +attrs.value;
      for (let index = 0; index < 3; index++) {
        const major = Time2[units[index]];
        const minor = Time2[units[index + 1]];
        if (ms >= major - minor / 2) {
          ms += minor / 2;
          let result = Math.floor(ms / major) + " " + session.text("general." + units[index]);
          if (ms % major > minor) {
            result += ` ${Math.floor(ms % major / minor)} ` + session.text("general." + units[index + 1]);
          }
          return result;
        }
      }
      return Math.round(ms / Time2.second) + " " + session.text("general.second");
    });
    ctx.before("attach", (session) => {
      if (session.parsed.prefix)
        return;
      for (const matcher of this._matchers) {
        this._executeMatcher(session, matcher);
        if (session.response)
          return;
      }
    });
  }
  _hooks = [];
  _nameRE;
  _sessions = /* @__PURE__ */ Object.create(null);
  _userCache = new SharedCache();
  _channelCache = new SharedCache();
  _components = /* @__PURE__ */ Object.create(null);
  _matchers = /* @__PURE__ */ new Set();
  get caller() {
    return this[Context4.current];
  }
  middleware(middleware, prepend = false) {
    return this.caller.lifecycle.register("middleware", this._hooks, middleware, prepend);
  }
  component(name, component, options = {}) {
    const render = /* @__PURE__ */ __name(async (attrs, children, session) => {
      if (!options.passive) {
        children = await session.transform(children);
      }
      return component(attrs, children, session);
    }, "render");
    this._components[name] = render;
    return this.caller.collect("component", () => {
      const shouldDelete = this._components[name] === render;
      if (shouldDelete)
        delete this._components[name];
      return shouldDelete;
    });
  }
  match(pattern, response, options) {
    const matcher = { ...options, context: this.caller, pattern, response };
    this._matchers.add(matcher);
    return this.caller.collect("shortcut", () => {
      return this._matchers.delete(matcher);
    });
  }
  _executeMatcher(session, matcher) {
    const { parsed, quote } = session;
    const { appel, context, i18n, fuzzy, pattern, response } = matcher;
    if (appel && !parsed.appel)
      return;
    if (!context.filter(session))
      return;
    let content = parsed.content;
    if (quote)
      content += " " + quote.content;
    let params = null;
    const match = /* @__PURE__ */ __name((pattern2) => {
      if (!pattern2)
        return;
      if (typeof pattern2 === "string") {
        if (!fuzzy && content !== pattern2 || !content.startsWith(pattern2))
          return;
        params = [content.slice(pattern2.length)];
        if (fuzzy && !parsed.appel && params[0].match(/^\S/)) {
          params = null;
        }
      } else {
        params = pattern2.exec(content);
      }
    }, "match");
    if (!i18n) {
      match(pattern);
    } else {
      for (const locale in this.ctx.i18n._data) {
        const store = this.ctx.i18n._data[locale];
        match(store[pattern]);
        if (!params)
          continue;
        session.locale = locale;
        break;
      }
    }
    if (!params)
      return;
    session.response = async () => {
      const output = await session.resolveValue(response, params);
      return segment2.normalize(output, params.map((source) => segment2.parse(source)));
    };
  }
  prepare() {
    this._nameRE = createLeadingRE(makeArray2(this.config.nickname), "@?", "([,，]\\s*|\\s+)");
  }
  _resolvePrefixes(session) {
    const value = session.resolveValue(this.config.prefix);
    const result = Array.isArray(value) ? value : [value || ""];
    return result.map((source) => segment2.escape(source));
  }
  _stripNickname(content) {
    if (content.startsWith("@"))
      content = content.slice(1);
    for (const nickname of makeArray2(this.config.nickname)) {
      if (!content.startsWith(nickname))
        continue;
      const rest = content.slice(nickname.length);
      const capture = /^([,，]\s*|\s+)/.exec(rest);
      if (!capture)
        continue;
      return rest.slice(capture[0].length);
    }
  }
  async _process(session, next) {
    let atSelf = false, appel = false, prefix = null;
    let content = session.content.trim();
    session.elements ??= segment2.parse(content);
    let hasMention = false;
    const elements = session.elements.slice();
    while (elements[0]?.type === "at") {
      const { attrs } = elements.shift();
      if (attrs.id === session.selfId) {
        atSelf = appel = true;
      }
      hasMention = true;
      content = elements.join("").trimStart();
      if (elements[0]?.type === "text" && !elements[0].attrs.content.trim()) {
        elements.shift();
      }
    }
    if (!hasMention || atSelf) {
      const result = this._stripNickname(content);
      if (result) {
        appel = true;
        content = result;
      }
      for (const _prefix of this._resolvePrefixes(session)) {
        if (!content.startsWith(_prefix))
          continue;
        prefix = _prefix;
        content = content.slice(_prefix.length);
      }
    }
    defineProperty3(session, "parsed", { content, appel, prefix });
    this.ctx.emit(session, "before-attach", session);
    if (this.ctx.database) {
      if (session.subtype === "group") {
        const channelFields = /* @__PURE__ */ new Set(["flag", "assignee", "guildId", "locale"]);
        this.ctx.emit("before-attach-channel", session, channelFields);
        const channel = await session.observeChannel(channelFields);
        channel.guildId = session.guildId;
        if (await this.ctx.serial(session, "attach-channel", session))
          return;
        if (channel.flag & Channel.Flag.ignore)
          return;
        if (channel.assignee !== session.selfId && !atSelf)
          return;
      }
      const userFields = /* @__PURE__ */ new Set(["flag", "authority", "locale"]);
      this.ctx.emit("before-attach-user", session, userFields);
      const user = await session.observeUser(userFields);
      if (await this.ctx.serial(session, "attach-user", session))
        return;
      if (user.flag & User.Flag.ignore)
        return;
    }
    this.ctx.emit(session, "attach", session);
    if (session.response)
      return session.response();
    return next();
  }
  async _handleMessage(session) {
    if (session.selfId === session.userId)
      return;
    this._sessions[session.id] = session;
    const queue = this._hooks.filter(([context]) => context.filter(session)).map(([, middleware]) => middleware.bind(null, session));
    let index = 0;
    const next = /* @__PURE__ */ __name(async (callback) => {
      try {
        if (!this._sessions[session.id]) {
          throw new Error("isolated next function detected");
        }
        if (callback !== void 0) {
          queue.push((next2) => Next.compose(callback, next2));
          if (queue.length > Next.MAX_DEPTH) {
            throw new Error(`middleware stack exceeded ${Next.MAX_DEPTH}`);
          }
        }
        return await queue[index++]?.(next);
      } catch (error) {
        if (error instanceof SessionError) {
          return session.text(error.path, error.param);
        }
        const stack = coerce(error);
        this.ctx.logger("session").warn(`${session.content}
${stack}`);
      }
    }, "next");
    try {
      const result = await next();
      if (result)
        await session.send(result);
    } finally {
      delete this._sessions[session.id];
      this._userCache.delete(session.id);
      this._channelCache.delete(session.id);
      await session.user?.$update();
      await session.channel?.$update();
      await session.guild?.$update();
      this.ctx.emit(session, "middleware", session);
    }
  }
};
__name(Internal, "Internal");
__publicField(Internal, "methods", ["middleware", "component", "match"]);
Context4.service("$internal", Internal);
var SharedCache = class {
  #keyMap = /* @__PURE__ */ Object.create(null);
  get(ref, key) {
    const entry = this.#keyMap[key];
    if (!entry)
      return;
    entry.refs.add(ref);
    return entry.value;
  }
  set(ref, key, value) {
    let entry = this.#keyMap[key];
    if (entry) {
      entry.value = value;
    } else {
      entry = this.#keyMap[key] = { value, key, refs: /* @__PURE__ */ new Set() };
    }
    entry.refs.add(ref);
  }
  delete(ref) {
    for (const key in this.#keyMap) {
      const { refs } = this.#keyMap[key];
      refs.delete(ref);
      if (!refs.size) {
        delete this.#keyMap[key];
      }
    }
  }
};
__name(SharedCache, "SharedCache");

// koishi/packages/core/src/lifecycle.ts
import { remove } from "cosmokit";
import { Context as Context5 } from "@satorijs/core";
import { extend as extend2 } from "@koishijs/utils";
extend2(Context5.prototype, {
  get app() {
    return this.root;
  },
  get options() {
    return this.root.config;
  },
  async waterfall(...args) {
    const thisArg = typeof args[0] === "object" ? args.shift() : null;
    const name = args.shift();
    for (const callback of this.lifecycle.getHooks(name, thisArg)) {
      const result = await callback.apply(thisArg, args);
      args[0] = result;
    }
    return args[0];
  },
  chain(...args) {
    const thisArg = typeof args[0] === "object" ? args.shift() : null;
    const name = args.shift();
    for (const callback of this.lifecycle.getHooks(name, thisArg)) {
      const result = callback.apply(thisArg, args);
      args[0] = result;
    }
    return args[0];
  },
  before(name, listener, append = false) {
    const seg = name.split("/");
    seg[seg.length - 1] = "before-" + seg[seg.length - 1];
    return this.on(seg.join("/"), listener, !append);
  },
  createTimerDispose(timer) {
    const dispose = /* @__PURE__ */ __name(() => {
      clearTimeout(timer);
      if (!this.state)
        return;
      return remove(this.state.disposables, dispose);
    }, "dispose");
    this.state.disposables.push(dispose);
    return dispose;
  },
  setTimeout(callback, ms, ...args) {
    const dispose = this.createTimerDispose(setTimeout(() => {
      dispose();
      callback();
    }, ms, ...args));
    return dispose;
  },
  setInterval(callback, ms, ...args) {
    return this.createTimerDispose(setInterval(callback, ms, ...args));
  }
});

// koishi/packages/core/src/session.ts
import { extend as extend3, observe } from "@koishijs/utils";
import { defineProperty as defineProperty5, isNullable as isNullable3, makeArray as makeArray3 } from "cosmokit";
import { Logger as Logger4, segment as segment4, Session as Session5 } from "@satorijs/core";

// koishi/packages/core/src/command/index.ts
import { defineProperty as defineProperty4 } from "cosmokit";
import { Context as Context8 } from "@satorijs/core";

// koishi/packages/core/src/command/command.ts
import { camelize, isNullable as isNullable2, remove as remove2 } from "cosmokit";
import { coerce as coerce2 } from "@koishijs/utils";
import { Logger as Logger3, Schema as Schema2 } from "@satorijs/core";

// koishi/packages/core/src/command/parser.ts
import { camelCase, paramCase, Time as Time3 } from "cosmokit";
import { escapeRegExp as escapeRegExp2 } from "@koishijs/utils";
import { segment as segment3 } from "@satorijs/core";
var leftQuotes = `"'“‘`;
var rightQuotes = `"'”’`;
var Argv;
((Argv2) => {
  const bracs = {};
  function interpolate(initiator, terminator, parse2) {
    bracs[initiator] = { terminator, parse: parse2 };
  }
  Argv2.interpolate = interpolate;
  __name(interpolate, "interpolate");
  interpolate("$(", ")");
  let whitespace;
  ((whitespace2) => {
    whitespace2.unescape = /* @__PURE__ */ __name((source) => source.replace(/@__KOISHI_SPACE__@/g, " ").replace(/@__KOISHI_NEWLINE__@/g, "\n").replace(/@__KOISHI_RETURN__@/g, "\r").replace(/@__KOISHI_TAB__@/g, "	"), "unescape");
    whitespace2.escape = /* @__PURE__ */ __name((source) => source.replace(/ /g, "@__KOISHI_SPACE__@").replace(/\n/g, "@__KOISHI_NEWLINE__@").replace(/\r/g, "@__KOISHI_RETURN__@").replace(/\t/g, "@__KOISHI_TAB__@"), "escape");
  })(whitespace = Argv2.whitespace || (Argv2.whitespace = {}));
  class Tokenizer {
    bracs;
    constructor() {
      this.bracs = Object.create(bracs);
    }
    interpolate(initiator, terminator, parse2) {
      this.bracs[initiator] = { terminator, parse: parse2 };
    }
    parseToken(source, stopReg = "$") {
      const parent = { inters: [] };
      const index = leftQuotes.indexOf(source[0]);
      const quote = rightQuotes[index];
      let content = "";
      if (quote) {
        source = source.slice(1);
        stopReg = `${quote}(?=${stopReg})|$`;
      }
      stopReg += `|${Object.keys({ ...this.bracs, ...bracs }).map(escapeRegExp2).join("|")}`;
      const regExp = new RegExp(stopReg);
      while (true) {
        const capture = regExp.exec(source);
        content += whitespace.unescape(source.slice(0, capture.index));
        if (capture[0] in this.bracs) {
          source = source.slice(capture.index + capture[0].length).trimStart();
          const { parse: parse2, terminator } = this.bracs[capture[0]];
          const argv = parse2?.(source) || this.parse(source, terminator);
          source = argv.rest;
          parent.inters.push({ ...argv, pos: content.length, initiator: capture[0] });
        } else {
          const quoted = capture[0] === quote;
          const rest = source.slice(capture.index + +quoted);
          parent.rest = rest.trimStart();
          parent.quoted = quoted;
          parent.terminator = capture[0];
          if (quoted) {
            parent.terminator += rest.slice(0, -parent.rest.length);
          } else if (quote) {
            content = leftQuotes[index] + content;
            parent.inters.forEach((inter) => inter.pos += 1);
          }
          parent.content = content;
          if (quote === "'")
            Argv2.revert(parent);
          return parent;
        }
      }
    }
    parse(source, terminator = "") {
      const tokens = [];
      source = segment3.parse(source).map((el) => {
        return el.type === "text" ? el.toString() : whitespace.escape(el.toString());
      }).join("");
      let rest = source, term = "";
      const stopReg = `\\s+|[${escapeRegExp2(terminator)}]|$`;
      while (rest && !(terminator && rest.startsWith(terminator))) {
        const token = this.parseToken(rest, stopReg);
        tokens.push(token);
        rest = token.rest;
        term = token.terminator;
        delete token.rest;
      }
      if (rest.startsWith(terminator))
        rest = rest.slice(1);
      source = source.slice(0, -(rest + term).length);
      rest = whitespace.unescape(rest);
      source = whitespace.unescape(source);
      return { tokens, rest, source };
    }
    stringify(argv) {
      const output = argv.tokens.reduce((prev, token) => {
        if (token.quoted)
          prev += leftQuotes[rightQuotes.indexOf(token.terminator[0])] || "";
        return prev + token.content + token.terminator;
      }, "");
      if (argv.rest && !rightQuotes.includes(output[output.length - 1]) || argv.initiator) {
        return output.slice(0, -1);
      }
      return output;
    }
  }
  __name(Tokenizer, "Tokenizer");
  Argv2.Tokenizer = Tokenizer;
  const defaultTokenizer = new Tokenizer();
  function parse(source, terminator = "") {
    return defaultTokenizer.parse(source, terminator);
  }
  Argv2.parse = parse;
  __name(parse, "parse");
  function stringify(argv) {
    return defaultTokenizer.stringify(argv);
  }
  Argv2.stringify = stringify;
  __name(stringify, "stringify");
  function revert(token) {
    while (token.inters.length) {
      const { pos, source, initiator } = token.inters.pop();
      token.content = token.content.slice(0, pos) + initiator + source + bracs[initiator].terminator + token.content.slice(pos);
    }
  }
  Argv2.revert = revert;
  __name(revert, "revert");
  function resolveConfig2(type) {
    return typeof type === "string" ? builtin[type] || {} : {};
  }
  __name(resolveConfig2, "resolveConfig");
  const isArray = Array.isArray;
  function resolveType(type) {
    if (typeof type === "function") {
      return type;
    } else if (type instanceof RegExp) {
      return (source) => {
        if (type.test(source))
          return source;
        throw new Error();
      };
    } else if (isArray(type)) {
      return (source) => {
        if (type.includes(source))
          return source;
        throw new Error();
      };
    }
    return builtin[type]?.transform;
  }
  __name(resolveType, "resolveType");
  const builtin = {};
  function createDomain(name, transform, options) {
    builtin[name] = { ...options, transform };
  }
  Argv2.createDomain = createDomain;
  __name(createDomain, "createDomain");
  createDomain("string", (source) => source);
  createDomain("text", (source) => source, { greedy: true });
  createDomain("rawtext", (source) => segment3.unescape(source), { greedy: true });
  createDomain("boolean", () => true);
  createDomain("number", (source, session) => {
    const value = +source;
    if (Number.isFinite(value))
      return value;
    throw new Error("internal.invalid-number");
  });
  createDomain("integer", (source, session) => {
    const value = +source;
    if (value * 0 === 0 && Math.floor(value) === value)
      return value;
    throw new Error("internal.invalid-integer");
  });
  createDomain("posint", (source, session) => {
    const value = +source;
    if (value * 0 === 0 && Math.floor(value) === value && value > 0)
      return value;
    throw new Error("internal.invalid-posint");
  });
  createDomain("natural", (source, session) => {
    const value = +source;
    if (value * 0 === 0 && Math.floor(value) === value && value >= 0)
      return value;
    throw new Error("internal.invalid-natural");
  });
  createDomain("date", (source, session) => {
    const timestamp = Time3.parseDate(source);
    if (+timestamp)
      return timestamp;
    throw new Error("internal.invalid-date");
  });
  createDomain("user", (source, session) => {
    if (source.startsWith("@")) {
      source = source.slice(1);
      if (source.includes(":"))
        return source;
      return `${session.platform}:${source}`;
    }
    const code = segment3.from(source);
    if (code && code.type === "at") {
      return `${session.platform}:${code.data.id}`;
    }
    throw new Error("internal.invalid-user");
  });
  createDomain("channel", (source, session) => {
    if (source.startsWith("#")) {
      source = source.slice(1);
      if (source.includes(":"))
        return source;
      return `${session.platform}:${source}`;
    }
    const code = segment3.from(source);
    if (code && code.type === "sharp") {
      return `${session.platform}:${code.data.id}`;
    }
    throw new Error("internal.invalid-channel");
  });
  const BRACKET_REGEXP = /<[^>]+>|\[[^\]]+\]/g;
  function parseDecl(source) {
    let cap;
    const result = [];
    while (cap = BRACKET_REGEXP.exec(source)) {
      let rawName = cap[0].slice(1, -1);
      let variadic = false;
      if (rawName.startsWith("...")) {
        rawName = rawName.slice(3);
        variadic = true;
      }
      const [name, rawType] = rawName.split(":");
      const type = rawType ? rawType.trim() : void 0;
      result.push({
        name,
        variadic,
        type,
        required: cap[0][0] === "<"
      });
    }
    result.stripped = source.replace(/:[\w-]+[>\]]/g, (str) => str.slice(-1)).trimEnd();
    return result;
  }
  __name(parseDecl, "parseDecl");
  function parseValue(source, quoted, kind, argv, decl = {}) {
    const { name, type } = decl;
    const transform = resolveType(type);
    if (transform) {
      try {
        return transform(source, argv.session);
      } catch (err) {
        if (!argv.session) {
          argv.error = `internal.invalid-${kind}`;
        } else {
          const message = argv.session.text(err["message"] || "internal.check-syntax");
          argv.error = argv.session.text(`internal.invalid-${kind}`, [name, message]);
        }
        return;
      }
    }
    if (source === "" && !quoted)
      return true;
    if (quoted)
      return source;
    const n = +source;
    return n * 0 === 0 ? n : source;
  }
  Argv2.parseValue = parseValue;
  __name(parseValue, "parseValue");
  class CommandBase {
    constructor(name, declaration, ctx) {
      this.name = name;
      this.ctx = ctx;
      if (!name)
        throw new Error("expect a command name");
      const decl = this._arguments = parseDecl(declaration);
      this.declaration = decl.stripped;
    }
    declaration;
    _arguments;
    _options = {};
    _namedOptions = {};
    _symbolicOptions = {};
    _createOption(name, def, config) {
      const cap = /^((?:-[\w-]*|[^,\s\w\x80-\uffff]+)(?:,\s*(?:-[\w-]*|[^,\s\w\x80-\uffff]+))*(?=\s|$))?((?:\s*\[[^\]]+?\]|\s*<[^>]+?>)*)(.*)$/.exec(def);
      const param = paramCase(name);
      let syntax = cap[1] || "--" + param;
      const bracket = cap[2] || "";
      const desc = cap[3].trim();
      const names = [];
      const symbols = [];
      for (let param2 of syntax.trim().split(",")) {
        param2 = param2.trimStart();
        const name2 = param2.replace(/^-+/, "");
        if (!name2 || !param2.startsWith("-")) {
          symbols.push(segment3.escape(param2));
        } else {
          names.push(name2);
        }
      }
      if (!("value" in config) && !names.includes(param)) {
        syntax += ", --" + param;
      }
      const declList = parseDecl(bracket.trimStart());
      if (declList.stripped)
        syntax += " " + declList.stripped;
      const option = this._options[name] ||= {
        ...Command.defaultOptionConfig,
        ...declList[0],
        ...config,
        name,
        values: {},
        valuesSyntax: {},
        variants: {},
        syntax
      };
      let path = `commands.${this.name}.options.${name}`;
      const fallbackType = typeof option.fallback;
      if ("value" in config) {
        path += "." + config.value;
        option.variants[config.value] = { ...config, syntax };
        option.valuesSyntax[config.value] = syntax;
        names.forEach((name2) => option.values[name2] = config.value);
      } else if (!bracket.trim()) {
        option.type = "boolean";
      } else if (!option.type && (fallbackType === "string" || fallbackType === "number")) {
        option.type = fallbackType;
      }
      if (desc) {
        this.ctx.i18n.define("", path, desc);
      }
      this._assignOption(option, names, this._namedOptions);
      this._assignOption(option, symbols, this._symbolicOptions);
      if (!this._namedOptions[param]) {
        this._namedOptions[param] = option;
      }
    }
    _assignOption(option, names, optionMap) {
      for (const name of names) {
        if (name in optionMap) {
          throw new Error(`duplicate option name "${name}" for command "${this.name}"`);
        }
        optionMap[name] = option;
      }
    }
    removeOption(name) {
      if (!this._options[name])
        return false;
      const option = this._options[name];
      delete this._options[name];
      for (const key in this._namedOptions) {
        if (this._namedOptions[key] === option) {
          delete this._namedOptions[key];
        }
      }
      for (const key in this._symbolicOptions) {
        if (this._symbolicOptions[key] === option) {
          delete this._symbolicOptions[key];
        }
      }
      return true;
    }
    parse(argv, terminator, args = [], options = {}) {
      if (typeof argv === "string")
        argv = Argv2.parse(argv, terminator);
      if (!argv.source && argv.tokens) {
        argv.source = this.name + " " + Argv2.stringify(argv);
      }
      while (!argv.error && argv.tokens?.length) {
        const token = argv.tokens[0];
        let { content, quoted } = token;
        const argDecl = this._arguments[args.length];
        if (content[0] !== "-" && resolveConfig2(argDecl?.type).greedy) {
          args.push(Argv2.parseValue(Argv2.stringify(argv), true, "argument", argv, argDecl));
          break;
        }
        argv.tokens.shift();
        let option;
        let names;
        let param;
        if (!quoted && (option = this._symbolicOptions[content])) {
          names = [paramCase(option.name)];
        } else {
          if (content[0] !== "-" || quoted) {
            args.push(Argv2.parseValue(content, quoted, "argument", argv, argDecl || { type: "string" }));
            continue;
          }
          let i = 0;
          let name;
          for (; i < content.length; ++i) {
            if (content.charCodeAt(i) !== 45)
              break;
          }
          if (content.slice(i, i + 3) === "no-" && !this._namedOptions[content.slice(i)]) {
            name = content.slice(i + 3);
            options[camelCase(name)] = false;
            continue;
          }
          let j = i + 1;
          for (; j < content.length; j++) {
            if (content.charCodeAt(j) === 61)
              break;
          }
          name = content.slice(i, j);
          names = i > 1 ? [name] : name;
          param = content.slice(++j);
          option = this._namedOptions[names[names.length - 1]];
        }
        quoted = false;
        if (!param) {
          const { type } = option || {};
          if (resolveConfig2(type).greedy) {
            param = Argv2.stringify(argv);
            quoted = true;
            argv.tokens = [];
          } else if (type !== "boolean" && argv.tokens.length && (type || argv.tokens[0]?.content !== "-")) {
            const token2 = argv.tokens.shift();
            param = token2.content;
            quoted = token2.quoted;
          }
        }
        for (let j = 0; j < names.length; j++) {
          const name = names[j];
          const optDecl = this._namedOptions[name];
          const key = optDecl ? optDecl.name : camelCase(name);
          if (optDecl && name in optDecl.values) {
            options[key] = optDecl.values[name];
          } else {
            const source = j + 1 < names.length ? "" : param;
            options[key] = Argv2.parseValue(source, quoted, "option", argv, optDecl);
          }
          if (argv.error)
            break;
        }
      }
      for (const { name, fallback } of Object.values(this._options)) {
        if (fallback !== void 0 && !(name in options)) {
          options[name] = fallback;
        }
      }
      delete argv.tokens;
      return { ...argv, options, args, error: argv.error || "", command: this };
    }
    stringifyArg(value) {
      value = "" + value;
      return value.includes(" ") ? `"${value}"` : value;
    }
    stringify(args, options) {
      let output = this.name;
      for (const key in options) {
        const value = options[key];
        if (value === true) {
          output += ` --${key}`;
        } else if (value === false) {
          output += ` --no-${key}`;
        } else {
          output += ` --${key} ${this.stringifyArg(value)}`;
        }
      }
      for (const arg of args) {
        output += " " + this.stringifyArg(arg);
      }
      return output;
    }
  }
  __name(CommandBase, "CommandBase");
  Argv2.CommandBase = CommandBase;
})(Argv || (Argv = {}));

// koishi/packages/core/src/command/command.ts
var logger2 = new Logger3("command");
var _Command = class extends Argv.CommandBase {
  config;
  children = [];
  parent = null;
  _aliases = [];
  _examples = [];
  _usage;
  _disposed;
  _disposables;
  _disposables2 = [];
  _userFields = [["locale"]];
  _channelFields = [["locale"]];
  _actions = [];
  _checkers = [async (argv) => {
    return this.ctx.serial(argv.session, "command/before-execute", argv);
  }];
  static userFields(fields) {
    this._userFields.push(fields);
    return this;
  }
  static channelFields(fields) {
    this._channelFields.push(fields);
    return this;
  }
  constructor(name, decl, ctx) {
    super(name, decl, ctx);
    this.config = { ..._Command.defaultConfig };
    this._registerAlias(name);
    ctx.$commander._commandList.push(this);
  }
  get displayName() {
    return this._aliases[0];
  }
  set displayName(name) {
    this._registerAlias(name, true);
  }
  _registerAlias(name, prepend = false) {
    name = name.toLowerCase();
    const done = this._aliases.includes(name);
    if (done) {
      if (prepend) {
        remove2(this._aliases, name);
        this._aliases.unshift(name);
      }
      return;
    } else if (prepend) {
      this._aliases.unshift(name);
    } else {
      this._aliases.push(name);
    }
    const previous = this.ctx.$commander.getCommand(name);
    if (!previous) {
      this.ctx.$commander._commands.set(name, this);
    } else if (previous !== this) {
      throw new Error(`duplicate command names: "${name}"`);
    }
    this._disposables?.push(() => {
      remove2(this._aliases, name);
      this.ctx.$commander._commands.delete(name);
    });
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Command <${this.name}>`;
  }
  userFields(fields) {
    this._userFields.push(fields);
    return this;
  }
  channelFields(fields) {
    this._channelFields.push(fields);
    return this;
  }
  alias(...names) {
    if (this._disposed)
      return this;
    for (const name of names) {
      this._registerAlias(name);
    }
    return this;
  }
  _escape(source) {
    if (typeof source !== "string")
      return source;
    return source.replace(/\$\$/g, "@@__PLACEHOLDER__@@").replace(/\$\d/g, (s) => `{${s[1]}}`).replace(/@@__PLACEHOLDER__@@/g, "$");
  }
  shortcut(pattern, config = {}) {
    if (this._disposed)
      return this;
    let content = this.displayName;
    for (const arg of config.args || []) {
      content += " " + this._escape(arg);
    }
    for (const key in config.options || {}) {
      content += ` --${camelize(key)}`;
      const value = config.options[key];
      if (value !== true) {
        content += " " + this._escape(value);
      }
    }
    if (config.fuzzy)
      content += " {0}";
    if (typeof pattern === "string") {
      if (config.i18n) {
        pattern = `commands.${this.name}.shortcuts.${pattern}`;
      } else {
        config.i18n = true;
        const key = `commands.${this.name}.shortcuts._${Math.random().toString(36).slice(2)}`;
        this.ctx.i18n.define("", key, pattern);
        pattern = key;
      }
    }
    const dispose = this.ctx.match(pattern, `<execute>${content}</execute>`, {
      appel: config.prefix,
      fuzzy: config.fuzzy,
      i18n: config.i18n
    });
    this._disposables2.push(dispose);
    return this;
  }
  subcommand(def, ...args) {
    def = this.name + (def.charCodeAt(0) === 46 ? "" : "/") + def;
    const desc = typeof args[0] === "string" ? args.shift() : "";
    const config = args[0] || {};
    if (this._disposed)
      config.patch = true;
    return this.ctx.command(def, desc, config);
  }
  usage(text) {
    this._usage = text;
    return this;
  }
  example(example) {
    this._examples.push(example);
    return this;
  }
  option(name, ...args) {
    let desc = "";
    if (typeof args[0] === "string") {
      desc = args.shift();
    }
    const config = args[0];
    this._createOption(name, desc, config || {});
    this._disposables?.push(() => this.removeOption(name));
    return this;
  }
  match(session) {
    const { authority = Infinity } = session.user || {};
    return this.ctx.filter(session) && this.config.authority <= authority;
  }
  getConfig(key, session) {
    const value = this.config[key];
    return typeof value === "function" ? value(session) : value;
  }
  check(callback, append = false) {
    return this.before(callback, append);
  }
  before(callback, append = false) {
    if (append) {
      this._checkers.push(callback);
    } else {
      this._checkers.unshift(callback);
    }
    this._disposables?.push(() => remove2(this._checkers, callback));
    return this;
  }
  action(callback, prepend = false) {
    if (prepend) {
      this._actions.unshift(callback);
    } else {
      this._actions.push(callback);
    }
    this._disposables?.push(() => remove2(this._actions, callback));
    return this;
  }
  use(callback, ...args) {
    return callback(this, ...args);
  }
  async execute(argv, fallback = Next.compose) {
    argv.command ??= this;
    argv.args ??= [];
    argv.options ??= {};
    const { args, options, error } = argv;
    if (error)
      return error;
    if (logger2.level >= 3)
      logger2.debug(argv.source ||= this.stringify(args, options));
    for (const validator of this._checkers) {
      const result = await validator.call(this, argv, ...args);
      if (typeof result === "string")
        return result;
    }
    if (!this._actions.length)
      return "";
    let index = 0;
    const queue = this._actions.map((action) => async () => {
      return await action.call(this, argv, ...args);
    });
    queue.push(fallback);
    const length = queue.length;
    argv.next = async (callback) => {
      if (callback !== void 0) {
        queue.push((next) => Next.compose(callback, next));
        if (queue.length > Next.MAX_DEPTH) {
          throw new Error(`middleware stack exceeded ${Next.MAX_DEPTH}`);
        }
      }
      return queue[index++]?.(argv.next);
    };
    try {
      const result = await argv.next();
      if (!isNullable2(result))
        return result;
    } catch (error2) {
      if (index === length)
        throw error2;
      if (error2 instanceof SessionError) {
        return argv.session.text(error2.path, error2.param);
      }
      const stack = coerce2(error2);
      logger2.warn(`${argv.source ||= this.stringify(args, options)}
${stack}`);
      this.ctx.emit(argv.session, "command-error", argv, error2);
    }
    return "";
  }
  dispose() {
    this._disposed = true;
    this._disposables2.forEach((dispose) => dispose());
    this.ctx.emit("command-removed", this);
    for (const cmd of this.children.slice()) {
      cmd.dispose();
    }
    this._aliases.forEach((name) => this.ctx.$commander._commands.delete(name));
    remove2(this.ctx.$commander._commandList, this);
    if (this.parent) {
      remove2(this.parent.children, this);
    }
  }
};
var Command = _Command;
__name(Command, "Command");
__publicField(Command, "defaultConfig", {
  authority: 1,
  showWarning: true
});
__publicField(Command, "defaultOptionConfig", {
  authority: 0
});
__publicField(Command, "_userFields", []);
__publicField(Command, "_channelFields", []);
((Command2) => {
  Command2.Config = Schema2.object({
    authority: Schema2.union([
      Schema2.natural(),
      Schema2.function()
    ]).default(1),
    hidden: Schema2.boolean().default(false),
    checkArgCount: Schema2.boolean().default(false),
    checkUnknown: Schema2.boolean().default(false)
  });
})(Command || (Command = {}));

// koishi/packages/core/src/command/validate.ts
function validate(ctx) {
  ctx.on("command-added", (cmd) => {
    cmd.userFields(({ tokens, command, options = {} }, fields) => {
      if (!command)
        return;
      const { authority } = command.config;
      let shouldFetchAuthority = authority > 0;
      for (const { name, authority: authority2 } of Object.values(command._options)) {
        if (name in options) {
          if (authority2 > 0)
            shouldFetchAuthority = true;
        } else if (tokens) {
          if (authority2 > 0)
            shouldFetchAuthority = true;
        }
      }
      if (shouldFetchAuthority)
        fields.add("authority");
    });
  });
  ctx.before("command/execute", (argv) => {
    const { session, options, command } = argv;
    if (!session.user)
      return;
    function sendHint(message, ...param) {
      return command.config.showWarning ? session.text(message, param) : "";
    }
    __name(sendHint, "sendHint");
    if (typeof session.user.authority === "number") {
      const authority = command.getConfig("authority", session);
      if (authority > session.user.authority) {
        return sendHint("internal.low-authority");
      }
    }
    for (const option of Object.values(command._options)) {
      if (option.name in options) {
        if (option.authority > session.user.authority) {
          return sendHint("internal.low-authority");
        }
      }
    }
  }, true);
  ctx.before("command/execute", (argv) => {
    const { args, options, command, session } = argv;
    function sendHint(message, ...param) {
      return command.config.showWarning ? session.text(message, param) : "";
    }
    __name(sendHint, "sendHint");
    if (command.config.checkArgCount) {
      const nextArg = command._arguments[args.length] || {};
      if (nextArg.required) {
        return sendHint("internal.insufficient-arguments");
      }
      const finalArg = command._arguments[command._arguments.length - 1] || {};
      if (args.length > command._arguments.length && finalArg.type !== "text" && !finalArg.variadic) {
        return sendHint("internal.redunant-arguments");
      }
    }
    if (command.config.checkUnknown) {
      const unknown = Object.keys(options).filter((key) => !command._options[key]);
      if (unknown.length) {
        return sendHint("internal.unknown-option", unknown.join(", "));
      }
    }
  }, true);
}
__name(validate, "validate");

// koishi/packages/core/src/command/index.ts
var Commander = class {
  constructor(ctx, config = {}) {
    this.ctx = ctx;
    this.config = config;
    defineProperty4(this, Context8.current, ctx);
    ctx.plugin(validate);
    ctx.before("parse", (content, session) => {
      const argv = Argv.parse(content);
      if (session.quote) {
        argv.tokens.push({
          content: session.quote.content,
          quoted: true,
          inters: [],
          terminator: ""
        });
      }
      return argv;
    });
    ctx.before("attach", (session) => {
      defineProperty4(session, "argv", ctx.bail("before-parse", session.parsed.content, session));
      session.argv.root = true;
      session.argv.session = session;
    });
    ctx.middleware((session, next) => {
      if (!session.resolve(session.argv))
        return next();
      return session.execute(session.argv, next);
    });
    ctx.middleware((session, next) => {
      const { argv, quote, subtype, parsed: { content, prefix, appel } } = session;
      if (argv.command || subtype !== "private" && !prefix && !appel)
        return next();
      const actual = content.split(/\s/, 1)[0].toLowerCase();
      if (!actual)
        return next();
      return next(async (next2) => {
        const name = await session.suggest({
          actual,
          expect: this.available(session),
          suffix: session.text("internal.suggest-command")
        });
        if (!name)
          return next2();
        const message = name + content.slice(actual.length) + (quote ? " " + quote.content : "");
        return session.execute(message, next2);
      });
    });
  }
  _commandList = [];
  _commands = /* @__PURE__ */ new Map();
  _shortcuts = [];
  available(session) {
    return this._commandList.filter((cmd) => cmd.match(session)).flatMap((cmd) => cmd._aliases);
  }
  get caller() {
    return this[Context8.current];
  }
  resolve(key) {
    if (!key)
      return;
    const segments = key.split(".");
    let i = 1, name = segments[0], cmd;
    while ((cmd = this.getCommand(name)) && i < segments.length) {
      name = cmd.name + "." + segments[i++];
    }
    return cmd;
  }
  getCommand(name) {
    return this._commands.get(name);
  }
  command(def, ...args) {
    const desc = typeof args[0] === "string" ? args.shift() : "";
    const config = args[0];
    const path = def.split(" ", 1)[0].toLowerCase();
    const decl = def.slice(path.length);
    const segments = path.split(/(?=[./])/g);
    let parent, root;
    const list = [];
    segments.forEach((segment5, index) => {
      const code = segment5.charCodeAt(0);
      const name = code === 46 ? parent.name + segment5 : code === 47 ? segment5.slice(1) : segment5;
      let command2 = this.getCommand(name);
      if (command2) {
        if (parent) {
          if (command2 === parent) {
            throw new Error(`cannot set a command (${command2.name}) as its own subcommand`);
          }
          if (command2.parent) {
            if (command2.parent !== parent) {
              throw new Error(`cannot create subcommand ${path}: ${command2.parent.name}/${command2.name} already exists`);
            }
          } else {
            command2.parent = parent;
            parent.children.push(command2);
          }
        }
        return parent = command2;
      }
      command2 = new Command(name, decl, this.caller);
      list.push(command2);
      if (!root)
        root = command2;
      if (parent) {
        command2.parent = parent;
        command2.config.authority = parent.config.authority;
        parent.children.push(command2);
      }
      parent = command2;
    });
    if (desc)
      this.caller.i18n.define("", `commands.${parent.name}.description`, desc);
    Object.assign(parent.config, config);
    list.forEach((command2) => this.caller.emit("command-added", command2));
    if (!config?.patch) {
      if (root)
        this.caller.state.disposables.unshift(() => root.dispose());
      return parent;
    }
    if (root)
      root.dispose();
    const command = Object.create(parent);
    command._disposables = this.caller.state.disposables;
    return command;
  }
};
__name(Commander, "Commander");
__publicField(Commander, "key", "$commander");
__publicField(Commander, "methods", ["command"]);
Context8.service(Commander.key, Commander);

// koishi/packages/core/src/session.ts
var logger3 = new Logger4("session");
var { initialize } = Session5.prototype;
extend3(Session5.prototype, {
  initialize() {
    initialize.call(this);
    defineProperty5(this, "scope", null);
    defineProperty5(this, "user", null);
    defineProperty5(this, "channel", null);
    defineProperty5(this, "guild", null);
    defineProperty5(this, "_queuedTasks", []);
    defineProperty5(this, "_queuedTimeout", null);
  },
  get username() {
    const defaultName = this.user && this.user["name"] ? this.user["name"] : this.author ? this.author.nickname || this.author.username : this.userId;
    return this.app.chain("appellation", defaultName, this);
  },
  async send(fragment, options = {}) {
    if (!fragment)
      return;
    options.session = this;
    const children = await this.transform(segment4.normalize(fragment));
    return this.bot.sendMessage(this.channelId, children, this.guildId, options).catch((error) => {
      logger3.warn(error);
      return [];
    });
  },
  cancelQueued(delay = this.app.config.delay.cancel) {
    clearTimeout(this._queuedTimeout);
    this._queuedTasks = [];
    this._queuedTimeout = setTimeout(() => this._next(), delay);
  },
  _next() {
    const task = this._queuedTasks.shift();
    if (!task) {
      this._queuedTimeout = null;
      return;
    }
    this.send(task.content).then(task.resolve, task.reject);
    this._queuedTimeout = setTimeout(() => this._next(), task.delay);
  },
  async sendQueued(content, delay) {
    const text = segment4.normalize(content).join("");
    if (!text)
      return;
    if (isNullable3(delay)) {
      const { message, character } = this.app.config.delay;
      delay = Math.max(message, character * text.length);
    }
    return new Promise((resolve, reject) => {
      this._queuedTasks.push({ content, delay, resolve, reject });
      if (!this._queuedTimeout)
        this._next();
    });
  },
  resolveValue(source) {
    return typeof source === "function" ? Reflect.apply(source, null, [this]) : source;
  },
  async getChannel(id = this.channelId, fields = []) {
    const { app, platform, guildId } = this;
    if (!fields.length)
      return { platform, id, guildId };
    const channel = await app.database.getChannel(platform, id, fields);
    if (channel)
      return channel;
    const assignee = await this.resolveValue(app.config.autoAssign) ? this.selfId : "";
    if (assignee) {
      return app.database.createChannel(platform, id, { assignee, guildId });
    } else {
      const channel2 = app.model.tables.channel.create();
      Object.assign(channel2, { platform, id, guildId, $detached: true });
      return channel2;
    }
  },
  async _observeChannelLike(channelId, fields = []) {
    const fieldSet = new Set(fields);
    const { platform } = this;
    const key = `${platform}:${channelId}`;
    let cache = this.app.$internal._channelCache.get(this.id, key);
    if (cache) {
      for (const key2 in cache) {
        fieldSet.delete(key2);
      }
      if (!fieldSet.size)
        return cache;
    }
    const data = await this.getChannel(channelId, [...fieldSet]);
    cache = this.app.$internal._channelCache.get(this.id, key);
    if (cache) {
      cache.$merge(data);
    } else {
      cache = observe(data, (diff) => this.app.database.setChannel(platform, channelId, diff), `channel ${key}`);
      this.app.$internal._channelCache.set(this.id, key, cache);
    }
    return cache;
  },
  async observeChannel(fields = []) {
    const tasks = [this._observeChannelLike(this.channelId, fields)];
    if (this.channelId !== this.guildId) {
      tasks.push(this._observeChannelLike(this.guildId, fields));
    }
    const [channel, guild = channel] = await Promise.all(tasks);
    this.guild = guild;
    this.channel = channel;
    return channel;
  },
  async getUser(id = this.userId, fields = []) {
    const { app, platform } = this;
    if (!fields.length)
      return { [platform]: id };
    const user = await app.database.getUser(platform, id, fields);
    if (user)
      return user;
    const authority = await this.resolveValue(app.config.autoAuthorize);
    if (authority) {
      return app.database.createUser(platform, id, { authority });
    } else {
      const user2 = app.model.tables.user.create();
      Object.assign(user2, { [platform]: id, authority, $detached: true });
      return user2;
    }
  },
  async observeUser(fields = []) {
    const fieldSet = new Set(fields);
    const { userId, platform } = this;
    let cache = this.app.$internal._userCache.get(this.id, this.uid);
    if (cache) {
      for (const key in cache) {
        fieldSet.delete(key);
      }
      if (!fieldSet.size)
        return this.user = cache;
    }
    if (this.author?.anonymous) {
      const fallback = this.app.model.tables.user.create();
      fallback[platform] = userId;
      fallback.authority = await this.resolveValue(this.app.config.autoAuthorize);
      const user = observe(fallback, () => Promise.resolve());
      return this.user = user;
    }
    const data = await this.getUser(userId, [...fieldSet]);
    cache = this.app.$internal._userCache.get(this.id, this.uid);
    if (cache) {
      cache.$merge(data);
    } else {
      cache = observe(data, (diff) => this.app.database.setUser(this.platform, userId, diff), `user ${this.uid}`);
      this.app.$internal._userCache.set(this.id, this.uid, cache);
    }
    return this.user = cache;
  },
  async withScope(scope, callback) {
    const oldScope = this.scope;
    try {
      this.scope = scope;
      return await callback();
    } finally {
      this.scope = oldScope;
    }
  },
  text(path, params = {}) {
    const locales = [this.app.config.locale];
    locales.unshift(this.user?.["locale"]);
    if (this.subtype === "group") {
      locales.unshift(this.guild?.["locale"]);
      locales.unshift(this.channel?.["locale"]);
    }
    locales.unshift(this.locale);
    const paths = makeArray3(path).map((path2) => {
      if (!path2.startsWith("."))
        return path2;
      if (!this.scope) {
        this.app.logger("i18n").warn(new Error("missing scope"));
        return "";
      }
      return this.scope + path2;
    });
    return this.app.i18n.text(locales, paths, params);
  },
  collect(key, argv, fields = /* @__PURE__ */ new Set()) {
    const collect = /* @__PURE__ */ __name((argv2) => {
      argv2.session = this;
      if (argv2.tokens) {
        for (const { inters } of argv2.tokens) {
          inters.forEach(collect);
        }
      }
      if (!this.resolve(argv2))
        return;
      this.app.emit(argv2.session, `command/before-attach-${key}`, argv2, fields);
      collectFields(argv2, Command[`_${key}Fields`], fields);
      collectFields(argv2, argv2.command[`_${key}Fields`], fields);
    }, "collect");
    collect(argv);
    return fields;
  },
  inferCommand(argv) {
    if (argv.command)
      return argv.command;
    if (argv.name)
      return argv.command = this.app.$commander.resolve(argv.name);
    const { parsed, subtype } = this;
    if (argv.root && subtype !== "private" && parsed.prefix === null && !parsed.appel)
      return;
    const segments = [];
    while (argv.tokens.length) {
      const { content } = argv.tokens[0];
      segments.push(content);
      const command = this.app.$commander.resolve(segments.join("."));
      if (!command)
        break;
      argv.tokens.shift();
      argv.command = command;
      if (command["_actions"].length)
        break;
    }
    return argv.command;
  },
  resolve(argv) {
    if (!this.inferCommand(argv))
      return;
    if (argv.tokens?.every((token) => !token.inters.length)) {
      const { options, args, error } = argv.command.parse(argv);
      argv.options = { ...argv.options, ...options };
      argv.args = [...argv.args || [], ...args];
      argv.error = error;
    }
    return argv.command;
  },
  async execute(argv, next) {
    if (typeof argv === "string")
      argv = Argv.parse(argv);
    argv.session = this;
    if (argv.tokens) {
      for (const arg of argv.tokens) {
        const { inters } = arg;
        const output = [];
        for (let i = 0; i < inters.length; ++i) {
          output.push(await this.execute(inters[i], true));
        }
        for (let i = inters.length - 1; i >= 0; --i) {
          const { pos } = inters[i];
          arg.content = arg.content.slice(0, pos) + output[i] + arg.content.slice(pos);
        }
        arg.inters = [];
      }
      if (!this.resolve(argv))
        return "";
    } else {
      argv.command ||= this.app.$commander.getCommand(argv.name);
      if (!argv.command) {
        logger3.warn(new Error(`cannot find command ${argv.name}`));
        return "";
      }
    }
    const { command } = argv;
    if (!command.ctx.filter(this))
      return "";
    if (this.app.database) {
      if (this.subtype === "group") {
        await this.observeChannel(this.collect("channel", argv));
      }
      await this.observeUser(this.collect("user", argv));
    }
    let shouldEmit = true;
    if (next === true) {
      shouldEmit = false;
      next = void 0;
    }
    return this.withScope(`commands.${command.name}.messages`, async () => {
      const result = await command.execute(argv, next);
      if (!shouldEmit) {
        if (typeof result === "string")
          return result;
        return segment4(null, result).toString();
      }
      await this.send(result);
      return "";
    });
  },
  middleware(middleware) {
    const id = getNarrowContextId(this);
    return this.app.middleware(async (session, next) => {
      if (id && getNarrowContextId(session) !== id)
        return next();
      return middleware(session, next);
    }, true);
  },
  prompt(...args) {
    const callback = typeof args[0] === "function" ? args.shift() : (session) => session.content;
    const options = typeof args[0] === "number" ? { timeout: args[0] } : args[0] ?? {};
    return new Promise((resolve) => {
      const dispose = this.middleware(async (session, next) => {
        clearTimeout(timer);
        dispose();
        const value = await callback(session);
        resolve(value);
        if (isNullable3(value))
          return next();
      });
      const timer = setTimeout(() => {
        dispose();
        resolve(void 0);
      }, options.timeout ?? this.app.config.delay.prompt);
    });
  },
  async suggest(options) {
    let { expect, prefix = "" } = options;
    if (options.actual) {
      expect = expect.filter((name) => {
        return name && this.app.i18n.compare(name, options.actual, options);
      });
    }
    if (!expect.length) {
      await this.send(prefix);
      return;
    }
    prefix += this.text("internal.suggest-hint", [expect.map((text) => {
      return this.text("general.quote", [text]);
    }).join(this.text("general.or"))]);
    if (expect.length > 1) {
      await this.send(prefix);
      return;
    }
    await this.send(prefix + options.suffix);
    return this.prompt((session) => {
      const content = session.content.trim();
      if (!content || content === "." || content === "。") {
        return expect[0];
      }
    }, options);
  },
  async transform(elements) {
    return await segment4.transformAsync(elements, this.app.$internal._components, this);
  }
});
function getNarrowContextId(session) {
  return "" + session.userId + session.channelId;
}
__name(getNarrowContextId, "getNarrowContextId");
function collectFields(argv, collectors, fields) {
  for (const collector of collectors) {
    if (typeof collector === "function") {
      collector(argv, fields);
      continue;
    }
    for (const field of collector) {
      fields.add(field);
    }
  }
  return fields;
}
__name(collectFields, "collectFields");
export {
  Context as App,
  Argv,
  Channel,
  Command,
  Commander,
  DatabaseService,
  I18n,
  Internal,
  Next,
  Service2 as Service,
  SessionError,
  SharedCache,
  User,
  defineConfig,
  defineDriver,
  resolveConfig,
  version
};
//# sourceMappingURL=index.mjs.map
