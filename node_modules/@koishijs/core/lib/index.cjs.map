{
  "version": 3,
  "sources": ["../src/index.ts", "../src/bot.ts", "../src/context.ts", "../src/database.ts", "../src/i18n.ts", "../src/internal.ts", "../src/lifecycle.ts", "../src/session.ts", "../src/command/index.ts", "../src/command/command.ts", "../src/command/parser.ts", "../src/command/validate.ts"],
  "sourcesContent": ["// @ts-ignore\nimport { version } from '../package.json'\n\nexport * from '@koishijs/utils'\nexport * from '@minatojs/core'\nexport * from './bot'\nexport * from './context'\nexport * from './database'\nexport * from './i18n'\nexport * from './internal'\nexport * from './lifecycle'\nexport * from './session'\nexport * from './command'\n\nexport { version }\n", "import { makeArray, sleep } from '@koishijs/utils'\nimport { Dict } from 'cosmokit'\nimport { Bot, Fragment } from '@satorijs/core'\n\ndeclare module '@satorijs/core' {\n  interface Bot {\n    getGuildMemberMap(guildId: string): Promise<Dict<string>>\n    broadcast(channels: (string | [string, string])[], content: Fragment, delay?: number): Promise<string[]>\n  }\n\n  interface Events {\n    'appellation'(name: string, session: Session): string\n  }\n}\n\nexport * from '@satorijs/core'\n\nBot.prototype.getGuildMemberMap = async function getGuildMemberMap(this: Bot, guildId) {\n  const list = await this.getGuildMemberList(guildId)\n  return Object.fromEntries(list.map(info => [info.userId, info.nickname || info.username]))\n}\n\nBot.prototype.broadcast = async function broadcast(this: Bot, channels, content, delay = this.ctx.root.config.delay.broadcast) {\n  const messageIds: string[] = []\n  for (let index = 0; index < channels.length; index++) {\n    if (index && delay) await sleep(delay)\n    try {\n      const [channelId, guildId] = makeArray(channels[index])\n      messageIds.push(...await this.sendMessage(channelId, content, guildId))\n    } catch (error) {\n      this.ctx.logger('bot').warn(error)\n    }\n  }\n  return messageIds\n}\n", "import { Awaitable, defineProperty, Time } from 'cosmokit'\nimport { Context, Schema } from '@satorijs/core'\nimport * as cordis from 'cordis'\nimport { Computed } from './session'\n\nexport type Plugin = cordis.Plugin<Context>\n\nexport namespace Plugin {\n  export type Function<T = any> = cordis.Plugin.Function<T, Context>\n  export type Constructor<T = any> = cordis.Plugin.Constructor<T, Context>\n  export type Object<S = any, T = any> = cordis.Plugin.Object<S, T, Context>\n}\n\nexport type EffectScope = cordis.EffectScope<Context>\nexport type ForkScope = cordis.ForkScope<Context>\nexport type MainScope = cordis.MainScope<Context>\nexport type Service = cordis.Service<Context>\n\nexport const Service = cordis.Service<Context>\n\nexport { resolveConfig } from 'cordis'\n\nexport type { Disposable } from 'cordis'\n\ndeclare module '@satorijs/core' {\n  export interface Context {\n  }\n\n  export namespace Context {\n    export interface Config extends Config.Basic, Config.Message, Config.Advanced {}\n\n    export namespace Config {\n      export interface Basic {\n        locale?: string\n        prefix?: Computed<string | string[]>\n        nickname?: string | string[]\n        autoAssign?: Computed<Awaitable<boolean>>\n        autoAuthorize?: Computed<Awaitable<number>>\n        minSimilarity?: number\n      }\n\n      export interface Message {\n        delay?: DelayConfig\n      }\n\n      export interface DelayConfig {\n        character?: number\n        message?: number\n        cancel?: number\n        broadcast?: number\n        prompt?: number\n      }\n\n      export interface Advanced {\n        maxListeners?: number\n      }\n\n      export interface Static extends Schema<Config> {\n        Basic: Schema<Basic>\n        Message: Schema<Message>\n        Advanced: Schema<Advanced>\n      }\n    }\n  }\n}\n\ndefineProperty(Context.Config, 'Basic', Schema.object({\n  locale: Schema.string().default('zh').description('默认使用的语言。'),\n  prefix: Schema.union([\n    Schema.array(String),\n    Schema.transform(String, (prefix) => [prefix]),\n    Schema.function(),\n  ] as const).default(['']).description('指令前缀字符构成的数组。将被用于指令的匹配。'),\n  nickname: Schema.union([\n    Schema.array(String),\n    Schema.transform(String, (nickname) => [nickname]),\n  ] as const).description('机器人昵称构成的数组。将被用于指令的匹配。'),\n  autoAssign: Schema.union([Boolean, Function]).default(true).description('当获取不到频道数据时，是否使用接受者作为代理者。'),\n  autoAuthorize: Schema.union([Schema.natural(), Function]).default(1).description('当获取不到用户数据时默认使用的权限等级。'),\n  minSimilarity: Schema.percent().default(0.64).description('用于模糊匹配的相似系数，应该是一个 0 到 1 之间的数值。数值越高，模糊匹配越严格。设置为 1 可以完全禁用模糊匹配。'),\n}).description('基础设置'))\n\ndefineProperty(Context.Config, 'Message', Schema.object({\n  delay: Schema.object({\n    character: Schema.natural().role('ms').default(0).description('调用 `session.sendQueued()` 时消息间发送的最小延迟，按前一条消息的字数计算。'),\n    message: Schema.natural().role('ms').default(0.1 * Time.second).description('调用 `session.sendQueued()` 时消息间发送的最小延迟，按固定值计算。'),\n    cancel: Schema.natural().role('ms').default(0).description('调用 `session.cancelQueued()` 时默认的延迟。'),\n    broadcast: Schema.natural().role('ms').default(0.5 * Time.second).description('调用 `bot.broadcast()` 时默认的延迟。'),\n    prompt: Schema.natural().role('ms').default(Time.minute).description('调用 `session.prompt()` 时默认的等待时间。'),\n  }),\n}).description('消息设置'))\n\ndefineProperty(Context.Config, 'Advanced', Schema.object({\n  maxListeners: Schema.natural().default(64).description('每种监听器的最大数量。如果超过这个数量，Koishi 会认定为发生了内存泄漏，将产生一个警告。'),\n}).description('高级设置'))\n\nContext.Config.list.push(Context.Config.Basic, Context.Config.Message, Context.Config.Advanced)\n\n// for backward compatibility\nexport { Context as App }\n\nexport function defineConfig(config: Context.Config) {\n  return config\n}\n", "import * as utils from '@koishijs/utils'\nimport { defineProperty, Dict, MaybeArray } from 'cosmokit'\nimport { Database, Driver, Update } from '@minatojs/core'\nimport { Context, Fragment } from '@satorijs/core'\nimport { Plugin } from './context'\n\ndeclare module '@satorijs/core' {\n  interface Events {\n    'model'(name: keyof Tables): void\n  }\n\n  interface Context {\n    database: DatabaseService\n    model: DatabaseService\n    getSelfIds(type?: string, assignees?: string[]): Dict<string[]>\n    broadcast(content: Fragment, forced?: boolean): Promise<string[]>\n    broadcast(channels: readonly string[], content: Fragment, forced?: boolean): Promise<string[]>\n  }\n}\n\nexport interface User {\n  id: number\n  flag: number\n  authority: number\n  name: string\n  locale: string\n}\n\nexport namespace User {\n  export enum Flag {\n    ignore = 1,\n  }\n\n  export type Field = keyof User\n  export const fields: Field[] = []\n  export type Observed<K extends Field = Field> = utils.Observed<Pick<User, K>, Promise<void>>\n}\n\nexport interface Channel {\n  id: string\n  platform: string\n  flag: number\n  assignee: string\n  guildId: string\n  locale: string\n}\n\nexport namespace Channel {\n  export enum Flag {\n    ignore = 1,\n    silent = 4,\n  }\n\n  export type Field = keyof Channel\n  export const fields: Field[] = []\n  export type Observed<K extends Field = Field> = utils.Observed<Pick<Channel, K>, Promise<void>>\n}\n\nexport interface Tables {\n  user: User\n  channel: Channel\n}\n\nexport class DatabaseService extends Database<Tables> {\n  static readonly methods = ['getSelfIds', 'broadcast']\n\n  constructor(protected app: Context) {\n    super()\n    defineProperty(this, Context.current, app)\n\n    this.extend('user', {\n      id: 'unsigned(20)',\n      name: { type: 'string', length: 63 },\n      flag: 'unsigned(20)',\n      authority: 'unsigned(4)',\n      locale: 'string(63)',\n    }, {\n      autoInc: true,\n    })\n\n    this.extend('channel', {\n      id: 'string(63)',\n      platform: 'string(63)',\n      flag: 'unsigned(20)',\n      assignee: 'string(63)',\n      guildId: 'string(63)',\n      locale: 'string(63)',\n    }, {\n      primary: ['id', 'platform'],\n    })\n\n    app.on('bot-added', (bot) => {\n      if (bot.platform in this.tables.user.fields) return\n      this.extend('user', {\n        [bot.platform]: { type: 'string', length: 63 },\n      }, {\n        unique: [bot.platform as never],\n      })\n    })\n  }\n\n  getUser<T extends string, K extends User.Field>(platform: T, id: string, modifier?: Driver.Cursor<K>): Promise<Pick<User, K> & Record<T, string>>\n  getUser<T extends string, K extends User.Field>(platform: T, ids: string[], modifier?: Driver.Cursor<K>): Promise<Pick<User, K>[]>\n  async getUser(platform: string, id: MaybeArray<string>, modifier?: Driver.Cursor<User.Field>) {\n    const data = await this.get('user', { [platform]: id }, modifier)\n    if (Array.isArray(id)) return data\n    if (data[0]) Object.assign(data[0], { [platform]: id })\n    return data[0] as any\n  }\n\n  setUser(platform: string, id: string, data: Update<User>) {\n    return this.set('user', { [platform]: id }, data)\n  }\n\n  createUser(platform: string, id: string, data: Partial<User>) {\n    return this.create('user', { [platform]: id, ...data })\n  }\n\n  getChannel<K extends Channel.Field>(platform: string, id: string, modifier?: Driver.Cursor<K>): Promise<Pick<Channel, K | 'id' | 'platform'>>\n  getChannel<K extends Channel.Field>(platform: string, ids: string[], modifier?: Driver.Cursor<K>): Promise<Pick<Channel, K>[]>\n  async getChannel(platform: string, id: MaybeArray<string>, modifier?: Driver.Cursor<Channel.Field>) {\n    const data = await this.get('channel', { platform, id }, modifier)\n    if (Array.isArray(id)) return data\n    if (data[0]) Object.assign(data[0], { platform, id })\n    return data[0]\n  }\n\n  getSelfIds(type?: string, assignees?: string[]): Dict<string[]> {\n    if (type) {\n      assignees ||= this.app.bots.filter(bot => bot.platform === type).map(bot => bot.selfId)\n      return { [type]: assignees }\n    }\n    const platforms: Dict<string[]> = {}\n    for (const bot of this.app.bots) {\n      (platforms[bot.platform] ||= []).push(bot.selfId)\n    }\n    return platforms\n  }\n\n  getAssignedChannels<K extends Channel.Field>(fields?: K[], assignMap?: Dict<string[]>): Promise<Pick<Channel, K>[]>\n  async getAssignedChannels(fields?: Channel.Field[], assignMap: Dict<string[]> = this.getSelfIds()) {\n    return this.get('channel', {\n      $or: Object.entries(assignMap).map(([platform, assignee]) => ({ platform, assignee })),\n    }, fields)\n  }\n\n  setChannel(platform: string, id: string, data: Update<Channel>) {\n    return this.set('channel', { platform, id }, data)\n  }\n\n  createChannel(platform: string, id: string, data: Partial<Channel>) {\n    return this.create('channel', { platform, id, ...data })\n  }\n\n  async broadcast(...args: [Fragment, boolean?] | [readonly string[], Fragment, boolean?]) {\n    let channels: string[]\n    if (Array.isArray(args[0])) channels = args.shift() as any\n    const [content, forced] = args as [Fragment, boolean]\n    if (!content) return []\n\n    const data = await this.getAssignedChannels(['id', 'assignee', 'flag', 'platform', 'guildId'])\n    const assignMap: Dict<Dict<[string, string][]>> = {}\n    for (const { id, assignee, flag, platform, guildId } of data) {\n      if (channels && !channels.includes(`${platform}:${id}`)) continue\n      if (!forced && (flag & Channel.Flag.silent)) continue\n      ((assignMap[platform] ||= {})[assignee] ||= []).push([id, guildId])\n    }\n\n    return (await Promise.all(Object.entries(assignMap).flatMap(([platform, map]) => {\n      return this.app.bots.map((bot) => {\n        if (bot.platform !== platform) return Promise.resolve([])\n        return bot.broadcast(map[bot.selfId] || [], content)\n      })\n    }))).flat(1)\n  }\n}\n\n// workaround typings\nDatabaseService.prototype.extend = function extend(this: DatabaseService, name, fields, config) {\n  Database.prototype.extend.call(this, name, fields, {\n    ...config,\n    // driver: this[Context.current].mapping.database,\n  })\n  this.app.emit('model', name)\n}\n\nContext.service('database')\nContext.service('model', DatabaseService)\n\nexport const defineDriver = <T>(constructor: Driver.Constructor<T>, schema?: utils.Schema, prepare?: Plugin.Function<T>): Plugin.Object<T> => ({\n  name: constructor.name,\n  reusable: true,\n  Config: schema,\n  apply(ctx, config) {\n    config = { ...config }\n    prepare?.(ctx, config)\n    const driver = new constructor(ctx.model, config)\n    const key = ctx.mapping.database || 'default'\n\n    ctx.on('ready', async () => {\n      await driver.start()\n      ctx.model.drivers[key] = driver\n      ctx.model.refresh()\n      const database = Object.create(ctx.model)\n      ctx.database = database\n    })\n\n    ctx.on('dispose', async () => {\n      ctx.database = null\n      delete ctx.model.drivers[key]\n      await driver.stop()\n    })\n  },\n})\n", "import { Random } from '@koishijs/utils'\nimport { distance } from 'fastest-levenshtein'\nimport { Dict, isNullable } from 'cosmokit'\nimport { Context, Logger, segment } from '@satorijs/core'\nimport zhCN from './locales/zh-CN.yml'\nimport enUS from './locales/en-US.yml'\nimport jaJP from './locales/ja-JP.yml'\nimport frFR from './locales/fr-FR.yml'\nimport zhTW from './locales/zh-TW.yml'\n\nconst logger = new Logger('i18n')\nconst kTemplate = Symbol('template')\n\ndeclare module '@satorijs/core' {\n  interface Context {\n    i18n: I18n\n  }\n\n  interface Events {\n    'internal/i18n'(): void\n  }\n}\n\nexport interface CompareOptions {\n  minSimilarity?: number\n}\n\nexport namespace I18n {\n  export type Node = string | Store\n\n  export interface Store {\n    [kTemplate]?: string\n    [K: string]: Node\n  }\n\n  export type Formatter = (value: any, args: string[], locale: string) => string\n  export type Renderer = (dict: Dict, params: any, locale: string) => string\n\n  export interface FindOptions extends CompareOptions {}\n\n  export interface FindResult {\n    locale: string\n    data: Dict\n    similarity: number\n  }\n}\n\nexport class I18n {\n  _data: Dict<I18n.Store> = {}\n  _presets: Dict<I18n.Renderer> = {}\n\n  constructor(public ctx: Context) {\n    this.define('', { '': '' })\n    this.define('zh', zhCN)\n    this.define('en', enUS)\n    this.define('ja', jaJP)\n    this.define('fr', frFR)\n    this.define('zh-TW', zhTW)\n    this.registerBuiltins()\n  }\n\n  compare(expect: string, actual: string, options: CompareOptions = {}) {\n    const value = 1 - distance(expect, actual) / expect.length\n    const threshold = options.minSimilarity ?? this.ctx.root.config.minSimilarity\n    return value >= threshold ? value : 0\n  }\n\n  private set(locale: string, prefix: string, value: I18n.Node) {\n    if (prefix.includes('@') || typeof value === 'string') {\n      const dict = this._data[locale]\n      const [path, preset] = prefix.slice(0, -1).split('@')\n      if (preset) {\n        value[kTemplate] = preset\n        logger.warn('preset is deprecated and will be removed in the future')\n      }\n      if (!isNullable(dict[path]) && !locale.startsWith('$')) {\n        logger.warn('override', locale, path)\n      }\n      dict[path] = value\n      this[Context.current]?.on('dispose', () => {\n        delete dict[path]\n      })\n    } else {\n      for (const key in value) {\n        this.set(locale, prefix + key + '.', value[key])\n      }\n    }\n  }\n\n  define(locale: string, dict: I18n.Store): void\n  define(locale: string, key: string, value: I18n.Node): void\n  define(locale: string, ...args: [I18n.Store] | [string, I18n.Node]) {\n    this._data[locale] ||= {}\n    if (typeof args[0] === 'string') {\n      this.set(locale, args[0] + '.', args[1])\n    } else {\n      this.set(locale, '', args[0])\n    }\n    this.ctx.emit('internal/i18n')\n  }\n\n  /** @deprecated */\n  formatter(name: string, callback: I18n.Formatter) {\n    logger.warn('formatter is deprecated and will be removed in the future')\n  }\n\n  /** @deprecated */\n  preset(name: string, callback: I18n.Renderer) {\n    this._presets[name] = callback\n  }\n\n  find(path: string, actual: string, options: I18n.FindOptions = {}): I18n.FindResult[] {\n    if (!actual) return []\n    const groups: string[] = []\n    path = path.replace(/\\(([^)]+)\\)/g, (_, name) => {\n      groups.push(name)\n      return '([^.]+)'\n    })\n    const pattern = new RegExp(`^${path}$`)\n    const results: I18n.FindResult[] = []\n    for (const locale in this._data) {\n      for (const path in this._data[locale]) {\n        const capture = pattern.exec(path)\n        if (!capture) continue\n        const expect = this._data[locale][path]\n        if (typeof expect !== 'string') continue\n        const similarity = this.compare(expect, actual, options)\n        if (!similarity) continue\n        const data = {}\n        for (let i = 0; i < groups.length; i++) {\n          data[groups[i]] = capture[i + 1]\n        }\n        results.push({ locale, data, similarity })\n      }\n    }\n    return results\n  }\n\n  render(value: I18n.Node, params: any, locale: string) {\n    if (value === undefined) return\n\n    if (typeof value !== 'string') {\n      const preset = value[kTemplate]\n      const render = this._presets[preset]\n      if (!render) throw new Error(`Preset \"${preset}\" not found`)\n      return render(value, params, locale)\n    }\n\n    return segment.parse(value, params).join('')\n  }\n\n  text(locales: Iterable<string>, paths: string[], params: object) {\n    // sort locales by priority\n    const queue = new Set<string>()\n    for (const locale of locales) {\n      if (!locale) continue\n      queue.add(locale)\n    }\n    for (const locale in this._data) {\n      if (locale.startsWith('$')) continue\n      queue.add(locale)\n    }\n\n    // try every locale\n    for (const path of paths) {\n      for (const locale of queue) {\n        for (const key of ['$' + locale, locale]) {\n          const value = this._data[key]?.[path]\n          if (value === undefined) continue\n          return this.render(value, params, locale)\n        }\n      }\n    }\n\n    // path not found\n    logger.warn('missing', paths[0])\n    return paths[0]\n  }\n\n  private registerBuiltins() {\n    this.preset('plural', (data: string[], params: { length: number }, locale) => {\n      const path = params.length in data ? params.length : data.length - 1\n      return this.render(data[path], params, locale)\n    })\n\n    this.preset('random', (data: string[], params, locale) => {\n      return this.render(Random.pick(data), params, locale)\n    })\n\n    this.preset('list', (data, params: any[], locale) => {\n      const list = Object.entries(params).map(([key, value]) => {\n        return this.render(data.item, { key, value }, locale)\n      })\n      list.unshift(this.render(data.header, params, locale))\n      list.push(this.render(data.footer, params, locale))\n      return list.join('\\n').trim()\n    })\n  }\n}\n\nContext.service('i18n', I18n)\n", "import { coerce, escapeRegExp, makeArray, Random } from '@koishijs/utils'\nimport { Awaitable, defineProperty, Dict, Time } from 'cosmokit'\nimport { Context, Fragment, Render, segment, Session } from '@satorijs/core'\nimport { Computed } from './session'\nimport { Channel, User } from './database'\n\ndeclare module '@satorijs/core' {\n  interface Context {\n    $internal: Internal\n    component(name: string, component: Component, options?: Component.Options): () => boolean\n    middleware(middleware: Middleware, prepend?: boolean): () => boolean\n    match(pattern: string | RegExp, response: Fragment, options?: Matcher.Options & { i18n?: false }): () => boolean\n    match(pattern: string, response: string, options: Matcher.Options & { i18n: true }): () => boolean\n  }\n\n  interface Events {\n    'before-attach-channel'(session: Session, fields: Set<Channel.Field>): void\n    'attach-channel'(session: Session): Awaitable<void | boolean>\n    'before-attach-user'(session: Session, fields: Set<User.Field>): void\n    'attach-user'(session: Session): Awaitable<void | boolean>\n    'before-attach'(session: Session): void\n    'attach'(session: Session): void\n    'middleware'(session: Session): void\n  }\n}\n\nexport type Component = Render<Awaitable<Fragment>, Session>\n\nexport namespace Component {\n  export interface Options {\n    passive?: boolean\n  }\n}\n\nexport class SessionError extends Error {\n  constructor(public path: string | string[], public param?: Dict) {\n    super(makeArray(path)[0])\n  }\n}\n\nfunction createLeadingRE(patterns: string[], prefix = '', suffix = '') {\n  return patterns.length ? new RegExp(`^${prefix}(${patterns.map(escapeRegExp).join('|')})${suffix}`) : /$^/\n}\n\nexport type Next = (next?: Next.Callback) => Promise<void | Fragment>\nexport type Middleware = (session: Session, next: Next) => Awaitable<void | Fragment>\n\nexport namespace Next {\n  export const MAX_DEPTH = 64\n\n  export type Queue = ((next?: Next) => Awaitable<void | Fragment>)[]\n  export type Callback = void | string | ((next?: Next) => Awaitable<void | Fragment>)\n\n  export async function compose(callback: Callback, next?: Next) {\n    return typeof callback === 'function' ? callback(next) : callback\n  }\n}\n\nexport interface Matcher extends Matcher.Options {\n  context: Context\n  pattern: string | RegExp\n  response: Matcher.Response\n}\n\nexport namespace Matcher {\n  export type Response = Fragment | ((session: Session, params: [string, ...string[]]) => Awaitable<Fragment>)\n\n  export interface Options {\n    i18n?: boolean\n    appel?: boolean\n    fuzzy?: boolean\n  }\n}\n\nexport namespace Internal {\n  export interface Config {\n    nickname?: string | string[]\n    prefix?: Computed<string | string[]>\n  }\n}\n\nexport class Internal {\n  static readonly methods = ['middleware', 'component', 'match']\n\n  _hooks: [Context, Middleware][] = []\n  _nameRE: RegExp\n  _sessions: Dict<Session> = Object.create(null)\n  _userCache = new SharedCache<User.Observed<any>>()\n  _channelCache = new SharedCache<Channel.Observed<any>>()\n  _components: Dict<Component> = Object.create(null)\n  _matchers = new Set<Matcher>()\n\n  constructor(private ctx: Context, private config: Internal.Config) {\n    defineProperty(this, Context.current, ctx)\n    this.prepare()\n\n    // bind built-in event listeners\n    this.middleware(this._process.bind(this), true)\n    ctx.on('message', this._handleMessage.bind(this))\n\n    ctx.before('attach-user', (session, fields) => {\n      session.collect('user', session.argv, fields)\n    })\n\n    ctx.before('attach-channel', (session, fields) => {\n      session.collect('channel', session.argv, fields)\n    })\n\n    this.component('execute', async (attrs, children, session) => {\n      return session.execute(children.join(''), true)\n    })\n\n    this.component('prompt', async (attrs, children, session) => {\n      await session.send(children)\n      return session.prompt()\n    })\n\n    this.component('i18n', async (attrs, children, session) => {\n      return session.text(attrs.path)\n    })\n\n    this.component('random', async (attrs, children, session) => {\n      return Random.pick(children)\n    })\n\n    this.component('plural', async (attrs, children, session) => {\n      const path = attrs.count in children ? attrs.count : children.length - 1\n      return children[path]\n    })\n\n    const units = ['day', 'hour', 'minute', 'second'] as const\n\n    this.component('i18n:time', (attrs, children, session) => {\n      let ms = +attrs.value\n      for (let index = 0; index < 3; index++) {\n        const major = Time[units[index]]\n        const minor = Time[units[index + 1]]\n        if (ms >= major - minor / 2) {\n          ms += minor / 2\n          let result = Math.floor(ms / major) + ' ' + session.text('general.' + units[index])\n          if (ms % major > minor) {\n            result += ` ${Math.floor(ms % major / minor)} ` + session.text('general.' + units[index + 1])\n          }\n          return result\n        }\n      }\n      return Math.round(ms / Time.second) + ' ' + session.text('general.second')\n    })\n\n    ctx.before('attach', (session) => {\n      if (session.parsed.prefix) return\n      for (const matcher of this._matchers) {\n        this._executeMatcher(session, matcher)\n        if (session.response) return\n      }\n    })\n  }\n\n  protected get caller() {\n    return this[Context.current] as Context\n  }\n\n  middleware(middleware: Middleware, prepend = false) {\n    return this.caller.lifecycle.register('middleware', this._hooks, middleware, prepend)\n  }\n\n  component(name: string, component: Component, options: Component.Options = {}) {\n    const render: Component = async (attrs, children, session) => {\n      if (!options.passive) {\n        children = await session.transform(children)\n      }\n      return component(attrs, children, session)\n    }\n    this._components[name] = render\n    return this.caller.collect('component', () => {\n      const shouldDelete = this._components[name] === render\n      if (shouldDelete) delete this._components[name]\n      return shouldDelete\n    })\n  }\n\n  match(pattern: string | RegExp, response: Matcher.Response, options: Matcher.Options) {\n    const matcher: Matcher = { ...options, context: this.caller, pattern, response }\n    this._matchers.add(matcher)\n    return this.caller.collect('shortcut', () => {\n      return this._matchers.delete(matcher)\n    })\n  }\n\n  private _executeMatcher(session: Session, matcher: Matcher) {\n    const { parsed, quote } = session\n    const { appel, context, i18n, fuzzy, pattern, response } = matcher\n    if (appel && !parsed.appel) return\n    if (!context.filter(session)) return\n    let content = parsed.content\n    if (quote) content += ' ' + quote.content\n\n    let params: [string, ...string[]] = null\n    const match = (pattern: any) => {\n      if (!pattern) return\n      if (typeof pattern === 'string') {\n        if (!fuzzy && content !== pattern || !content.startsWith(pattern)) return\n        params = [content.slice(pattern.length)]\n        if (fuzzy && !parsed.appel && params[0].match(/^\\S/)) {\n          params = null\n        }\n      } else {\n        params = pattern.exec(content)\n      }\n    }\n\n    if (!i18n) {\n      match(pattern)\n    } else {\n      for (const locale in this.ctx.i18n._data) {\n        const store = this.ctx.i18n._data[locale]\n        match(store[pattern as string])\n        if (!params) continue\n        session.locale = locale\n        break\n      }\n    }\n\n    if (!params) return\n    session.response = async () => {\n      const output = await session.resolveValue(response, params)\n      return segment.normalize(output, params.map(source => segment.parse(source)))\n    }\n  }\n\n  prepare() {\n    this._nameRE = createLeadingRE(makeArray(this.config.nickname), '@?', '([,，]\\\\s*|\\\\s+)')\n  }\n\n  private _resolvePrefixes(session: Session) {\n    const value = session.resolveValue(this.config.prefix)\n    const result = Array.isArray(value) ? value : [value || '']\n    return result.map(source => segment.escape(source))\n  }\n\n  private _stripNickname(content: string) {\n    if (content.startsWith('@')) content = content.slice(1)\n    for (const nickname of makeArray(this.config.nickname)) {\n      if (!content.startsWith(nickname)) continue\n      const rest = content.slice(nickname.length)\n      const capture = /^([,，]\\s*|\\s+)/.exec(rest)\n      if (!capture) continue\n      return rest.slice(capture[0].length)\n    }\n  }\n\n  private async _process(session: Session, next: Next) {\n    let atSelf = false, appel = false, prefix: string = null\n    let content = session.content.trim()\n    session.elements ??= segment.parse(content)\n\n    // strip mentions\n    let hasMention = false\n    const elements = session.elements.slice()\n    while (elements[0]?.type === 'at') {\n      const { attrs } = elements.shift()\n      if (attrs.id === session.selfId) {\n        atSelf = appel = true\n      }\n      hasMention = true\n      content = elements.join('').trimStart()\n      // @ts-ignore\n      if (elements[0]?.type === 'text' && !elements[0].attrs.content.trim()) {\n        elements.shift()\n      }\n    }\n\n    if (!hasMention || atSelf) {\n      // strip nickname\n      const result = this._stripNickname(content)\n      if (result) {\n        appel = true\n        content = result\n      }\n\n      // strip prefix\n      for (const _prefix of this._resolvePrefixes(session)) {\n        if (!content.startsWith(_prefix)) continue\n        prefix = _prefix\n        content = content.slice(_prefix.length)\n      }\n    }\n\n    // store parsed message\n    defineProperty(session, 'parsed', { content, appel, prefix })\n    this.ctx.emit(session, 'before-attach', session)\n\n    if (this.ctx.database) {\n      if (session.subtype === 'group') {\n        // attach group data\n        const channelFields = new Set<Channel.Field>(['flag', 'assignee', 'guildId', 'locale'])\n        this.ctx.emit('before-attach-channel', session, channelFields)\n        const channel = await session.observeChannel(channelFields)\n        // for backwards compatibility (TODO remove in v5)\n        channel.guildId = session.guildId\n\n        // emit attach event\n        if (await this.ctx.serial(session, 'attach-channel', session)) return\n\n        // ignore some group calls\n        if (channel.flag & Channel.Flag.ignore) return\n        if (channel.assignee !== session.selfId && !atSelf) return\n      }\n\n      // attach user data\n      // authority is for suggestion\n      const userFields = new Set<User.Field>(['flag', 'authority', 'locale'])\n      this.ctx.emit('before-attach-user', session, userFields)\n      const user = await session.observeUser(userFields)\n\n      // emit attach event\n      if (await this.ctx.serial(session, 'attach-user', session)) return\n\n      // ignore some user calls\n      if (user.flag & User.Flag.ignore) return\n    }\n\n    this.ctx.emit(session, 'attach', session)\n    if (session.response) return session.response()\n    return next()\n  }\n\n  private async _handleMessage(session: Session) {\n    // ignore self messages\n    if (session.selfId === session.userId) return\n\n    // preparation\n    this._sessions[session.id] = session\n    const queue: Next.Queue = this._hooks\n      .filter(([context]) => context.filter(session))\n      .map(([, middleware]) => middleware.bind(null, session))\n\n    // execute middlewares\n    let index = 0\n    const next: Next = async (callback) => {\n      try {\n        if (!this._sessions[session.id]) {\n          throw new Error('isolated next function detected')\n        }\n        if (callback !== undefined) {\n          queue.push(next => Next.compose(callback, next))\n          if (queue.length > Next.MAX_DEPTH) {\n            throw new Error(`middleware stack exceeded ${Next.MAX_DEPTH}`)\n          }\n        }\n        return await queue[index++]?.(next)\n      } catch (error) {\n        if (error instanceof SessionError) {\n          return session.text(error.path, error.param)\n        }\n        const stack = coerce(error)\n        this.ctx.logger('session').warn(`${session.content}\\n${stack}`)\n      }\n    }\n\n    try {\n      const result = await next()\n      if (result) await session.send(result)\n    } finally {\n      // update session map\n      delete this._sessions[session.id]\n      this._userCache.delete(session.id)\n      this._channelCache.delete(session.id)\n\n      // flush user & group data\n      await session.user?.$update()\n      await session.channel?.$update()\n      await session.guild?.$update()\n      this.ctx.emit(session, 'middleware', session)\n    }\n  }\n}\n\nContext.service('$internal', Internal)\n\nexport namespace SharedCache {\n  export interface Entry<T> {\n    value: T\n    key: string\n    refs: Set<string>\n  }\n}\n\nexport class SharedCache<T> {\n  #keyMap: Dict<SharedCache.Entry<T>> = Object.create(null)\n\n  get(ref: string, key: string) {\n    const entry = this.#keyMap[key]\n    if (!entry) return\n    entry.refs.add(ref)\n    return entry.value\n  }\n\n  set(ref: string, key: string, value: T) {\n    let entry = this.#keyMap[key]\n    if (entry) {\n      entry.value = value\n    } else {\n      entry = this.#keyMap[key] = { value, key, refs: new Set() }\n    }\n    entry.refs.add(ref)\n  }\n\n  delete(ref: string) {\n    for (const key in this.#keyMap) {\n      const { refs } = this.#keyMap[key]\n      refs.delete(ref)\n      if (!refs.size) {\n        delete this.#keyMap[key]\n      }\n    }\n  }\n}\n", "import { Promisify, remove } from 'cosmokit'\nimport { GetEvents, Parameters, ReturnType, ThisType } from 'cordis'\nimport { Context, Events, Logger } from '@satorijs/core'\nimport { extend } from '@koishijs/utils'\n\n/* eslint-disable max-len */\ndeclare module '@satorijs/core' {\n  interface Context {\n    /** @deprecated use `ctx.root` instead */\n    app: Context\n    /** @deprecated use `root.config` instead */\n    options: Context.Config\n    logger(name: string): Logger\n    waterfall<K extends keyof GetEvents<this>>(name: K, ...args: Parameters<GetEvents<this>[K]>): Promisify<ReturnType<GetEvents<this>[K]>>\n    waterfall<K extends keyof GetEvents<this>>(thisArg: ThisType<GetEvents<this>[K]>, name: K, ...args: Parameters<GetEvents<this>[K]>): Promisify<ReturnType<GetEvents<this>[K]>>\n    chain<K extends keyof GetEvents<this>>(name: K, ...args: Parameters<GetEvents<this>[K]>): ReturnType<GetEvents<this>[K]>\n    chain<K extends keyof GetEvents<this>>(thisArg: ThisType<GetEvents<this>[K]>, name: K, ...args: Parameters<GetEvents<this>[K]>): ReturnType<GetEvents<this>[K]>\n    before<K extends BeforeEventName>(name: K, listener: BeforeEventMap[K], append?: boolean): () => boolean\n    setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]): () => boolean\n    setInterval(callback: (...args: any[]) => void, ms: number, ...args: any[]): () => boolean\n  }\n\n  namespace Context {\n    interface Private extends Context {\n      createTimerDispose(timer: NodeJS.Timeout): () => boolean\n    }\n  }\n}\n/* eslint-enable max-len */\n\ntype OmitSubstring<S extends string, T extends string> = S extends `${infer L}${T}${infer R}` ? `${L}${R}` : never\ntype BeforeEventName = OmitSubstring<keyof Events & string, 'before-'>\n\nexport type BeforeEventMap = { [E in keyof Events & string as OmitSubstring<E, 'before-'>]: Events[E] }\n\nextend(Context.prototype as Context.Private, {\n  get app() {\n    return this.root\n  },\n\n  get options() {\n    return this.root.config\n  },\n\n  async waterfall(...args: [any, ...any[]]) {\n    const thisArg = typeof args[0] === 'object' ? args.shift() : null\n    const name = args.shift()\n    for (const callback of this.lifecycle.getHooks(name, thisArg)) {\n      const result = await callback.apply(thisArg, args)\n      args[0] = result\n    }\n    return args[0]\n  },\n\n  chain(...args: [any, ...any[]]) {\n    const thisArg = typeof args[0] === 'object' ? args.shift() : null\n    const name = args.shift()\n    for (const callback of this.lifecycle.getHooks(name, thisArg)) {\n      const result = callback.apply(thisArg, args)\n      args[0] = result\n    }\n    return args[0]\n  },\n\n  before<K extends BeforeEventName>(name: K, listener: BeforeEventMap[K], append = false) {\n    const seg = (name as string).split('/')\n    seg[seg.length - 1] = 'before-' + seg[seg.length - 1]\n    return this.on(seg.join('/') as keyof Events, listener, !append)\n  },\n\n  createTimerDispose(timer) {\n    const dispose = () => {\n      clearTimeout(timer)\n      if (!this.state) return\n      return remove(this.state.disposables, dispose)\n    }\n    this.state.disposables.push(dispose)\n    return dispose\n  },\n\n  setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]) {\n    const dispose = this.createTimerDispose(setTimeout(() => {\n      dispose()\n      callback()\n    }, ms, ...args))\n    return dispose\n  },\n\n  setInterval(callback: (...args: any[]) => void, ms: number, ...args: any[]) {\n    return this.createTimerDispose(setInterval(callback, ms, ...args))\n  },\n})\n", "import { extend, observe } from '@koishijs/utils'\nimport { Awaitable, defineProperty, isNullable, makeArray, Promisify } from 'cosmokit'\nimport { Fragment, Logger, segment, Session } from '@satorijs/core'\nimport { Argv, Command } from './command'\nimport { Channel, Tables, User } from './database'\nimport { Middleware, Next } from './internal'\nimport { CompareOptions } from './i18n'\n\nconst logger = new Logger('session')\n\ndeclare module '@satorijs/core' {\n  interface Session<U extends User.Field = never, G extends Channel.Field = never> {\n    locale?: string\n    argv?: Argv<U, G>\n    user?: User.Observed<U>\n    channel?: Channel.Observed<G>\n    guild?: Channel.Observed<G>\n    parsed?: Parsed\n    scope?: string\n    username?: string\n    send(content: Fragment, options?: SendOptions): Promise<string[]>\n    cancelQueued(delay?: number): void\n    sendQueued(content: Fragment, delay?: number): Promise<string[]>\n    resolveValue<T, R extends any[]>(source: T | ((session: Session, ...args: R) => T), ...args: R): T\n    getChannel<K extends Channel.Field = never>(id?: string, fields?: K[]): Promise<Channel>\n    observeChannel<T extends Channel.Field = never>(fields?: Iterable<T>): Promise<Channel.Observed<T | G>>\n    getUser<K extends User.Field = never>(id?: string, fields?: K[]): Promise<User>\n    observeUser<T extends User.Field = never>(fields?: Iterable<T>): Promise<User.Observed<T | U>>\n    withScope<T>(scope: string, callback: () => T): Promisify<T>\n    text(path: string | string[], params?: object): string\n    collect<T extends 'user' | 'channel'>(key: T, argv: Argv, fields?: Set<keyof Tables[T]>): Set<keyof Tables[T]>\n    inferCommand(argv: Argv): Command\n    resolve(argv: Argv): Command\n    execute(content: string, next?: true | Next): Promise<string>\n    execute(argv: Argv, next?: true | Next): Promise<string>\n    middleware(middleware: Middleware): () => boolean\n    prompt(timeout?: number): Promise<string>\n    prompt<T>(callback: (session: Session) => Awaitable<T>, options?: PromptOptions): Promise<T>\n    suggest(options: SuggestOptions): Promise<string>\n    transform(elements: segment[]): Promise<segment[]>\n    response?: () => Promise<Fragment>\n  }\n\n  namespace Session {\n    export interface Private extends Session {\n      _queuedTasks: Task[]\n      _queuedTimeout: NodeJS.Timeout\n      _next(): void\n      _observeChannelLike<T extends Channel.Field = never>(channelId: string, fields: Iterable<T>): Promise<any>\n    }\n  }\n}\n\nexport interface PromptOptions {\n  timeout?: number\n}\n\nexport interface SuggestOptions extends CompareOptions {\n  actual?: string\n  expect: readonly string[]\n  prefix?: string\n  suffix: string\n  timeout?: number\n}\n\nexport interface Parsed {\n  content: string\n  prefix: string\n  appel: boolean\n}\n\nexport type Computed<T> = T | ((session: Session) => T)\n\ninterface Task {\n  delay: number\n  content: Fragment\n  resolve(ids: string[]): void\n  reject(reason: any): void\n}\n\nconst { initialize } = Session.prototype\n\nextend(Session.prototype as Session.Private, {\n  initialize() {\n    initialize.call(this)\n    defineProperty(this, 'scope', null)\n    defineProperty(this, 'user', null)\n    defineProperty(this, 'channel', null)\n    defineProperty(this, 'guild', null)\n    defineProperty(this, '_queuedTasks', [])\n    defineProperty(this, '_queuedTimeout', null)\n  },\n\n  get username() {\n    const defaultName: string = this.user && this.user['name']\n      ? this.user['name']\n      : this.author\n        ? this.author.nickname || this.author.username\n        : this.userId\n    return this.app.chain('appellation', defaultName, this)\n  },\n\n  async send(fragment, options = {}) {\n    if (!fragment) return\n    options.session = this\n    const children = await this.transform(segment.normalize(fragment))\n    return this.bot.sendMessage(this.channelId, children, this.guildId, options).catch<string[]>((error) => {\n      logger.warn(error)\n      return []\n    })\n  },\n\n  cancelQueued(delay = this.app.config.delay.cancel) {\n    clearTimeout(this._queuedTimeout)\n    this._queuedTasks = []\n    this._queuedTimeout = setTimeout(() => this._next(), delay)\n  },\n\n  _next() {\n    const task = this._queuedTasks.shift()\n    if (!task) {\n      this._queuedTimeout = null\n      return\n    }\n    this.send(task.content).then(task.resolve, task.reject)\n    this._queuedTimeout = setTimeout(() => this._next(), task.delay)\n  },\n\n  async sendQueued(content, delay?: number) {\n    const text = segment.normalize(content).join('')\n    if (!text) return\n    if (isNullable(delay)) {\n      const { message, character } = this.app.config.delay\n      delay = Math.max(message, character * text.length)\n    }\n    return new Promise<string[]>((resolve, reject) => {\n      this._queuedTasks.push({ content, delay, resolve, reject })\n      if (!this._queuedTimeout) this._next()\n    })\n  },\n\n  resolveValue(source) {\n    return typeof source === 'function' ? Reflect.apply(source, null, [this]) : source\n  },\n\n  async getChannel(id = this.channelId, fields = []) {\n    const { app, platform, guildId } = this\n    if (!fields.length) return { platform, id, guildId }\n    const channel = await app.database.getChannel(platform, id, fields)\n    if (channel) return channel\n    const assignee = await this.resolveValue(app.config.autoAssign) ? this.selfId : ''\n    if (assignee) {\n      return app.database.createChannel(platform, id, { assignee, guildId })\n    } else {\n      const channel = app.model.tables.channel.create()\n      Object.assign(channel, { platform, id, guildId, $detached: true })\n      return channel\n    }\n  },\n\n  /** 在当前会话上绑定一个可观测频道实例 */\n  async _observeChannelLike(channelId, fields = []) {\n    const fieldSet = new Set<Channel.Field>(fields)\n    const { platform } = this\n    const key = `${platform}:${channelId}`\n\n    // 如果存在满足可用的缓存数据，使用缓存代替数据获取\n    let cache = this.app.$internal._channelCache.get(this.id, key)\n    if (cache) {\n      for (const key in cache) {\n        fieldSet.delete(key as any)\n      }\n      if (!fieldSet.size) return cache\n    }\n\n    // 绑定一个新的可观测频道实例\n    const data = await this.getChannel(channelId, [...fieldSet])\n    cache = this.app.$internal._channelCache.get(this.id, key)\n    if (cache) {\n      cache.$merge(data)\n    } else {\n      cache = observe(data, diff => this.app.database.setChannel(platform, channelId, diff as any), `channel ${key}`)\n      this.app.$internal._channelCache.set(this.id, key, cache)\n    }\n    return cache\n  },\n\n  async observeChannel(fields = []) {\n    const tasks = [this._observeChannelLike(this.channelId, fields)]\n    if (this.channelId !== this.guildId) {\n      tasks.push(this._observeChannelLike(this.guildId, fields))\n    }\n    const [channel, guild = channel] = await Promise.all(tasks)\n    this.guild = guild\n    this.channel = channel\n    return channel\n  },\n\n  async getUser(id = this.userId, fields = []) {\n    const { app, platform } = this\n    if (!fields.length) return { [platform]: id }\n    const user = await app.database.getUser(platform, id, fields)\n    if (user) return user\n    const authority = await this.resolveValue(app.config.autoAuthorize)\n    if (authority) {\n      return app.database.createUser(platform, id, { authority })\n    } else {\n      const user = app.model.tables.user.create()\n      Object.assign(user, { [platform]: id, authority, $detached: true })\n      return user\n    }\n  },\n\n  /** 在当前会话上绑定一个可观测用户实例 */\n  async observeUser(fields = []) {\n    const fieldSet = new Set<User.Field>(fields)\n    const { userId, platform } = this\n\n    // 如果存在满足可用的缓存数据，使用缓存代替数据获取\n    let cache = this.app.$internal._userCache.get(this.id, this.uid)\n    if (cache) {\n      for (const key in cache) {\n        fieldSet.delete(key as any)\n      }\n      if (!fieldSet.size) return this.user = cache\n    }\n\n    // 匿名消息不会写回数据库\n    if (this.author?.anonymous) {\n      const fallback = this.app.model.tables.user.create()\n      fallback[platform] = userId\n      fallback.authority = await this.resolveValue(this.app.config.autoAuthorize)\n      const user = observe(fallback, () => Promise.resolve())\n      return this.user = user\n    }\n\n    // 绑定一个新的可观测用户实例\n    const data = await this.getUser(userId, [...fieldSet])\n    cache = this.app.$internal._userCache.get(this.id, this.uid)\n    if (cache) {\n      cache.$merge(data)\n    } else {\n      cache = observe(data, diff => this.app.database.setUser(this.platform, userId, diff as any), `user ${this.uid}`)\n      this.app.$internal._userCache.set(this.id, this.uid, cache)\n    }\n    return this.user = cache\n  },\n\n  async withScope(scope, callback: () => any) {\n    const oldScope = this.scope\n    try {\n      this.scope = scope\n      return await callback()\n    } finally {\n      this.scope = oldScope\n    }\n  },\n\n  text(path, params = {}) {\n    const locales = [this.app.config.locale]\n    locales.unshift(this.user?.['locale'])\n    if (this.subtype === 'group') {\n      locales.unshift(this.guild?.['locale'])\n      locales.unshift(this.channel?.['locale'])\n    }\n    locales.unshift(this.locale)\n    const paths = makeArray(path).map((path) => {\n      if (!path.startsWith('.')) return path\n      if (!this.scope) {\n        this.app.logger('i18n').warn(new Error('missing scope'))\n        return ''\n      }\n      return this.scope + path\n    })\n    return this.app.i18n.text(locales, paths, params)\n  },\n\n  collect(key: 'user' | 'channel', argv: Argv, fields = new Set()) {\n    const collect = (argv: Argv) => {\n      argv.session = this\n      if (argv.tokens) {\n        for (const { inters } of argv.tokens) {\n          inters.forEach(collect)\n        }\n      }\n      if (!this.resolve(argv)) return\n      this.app.emit(argv.session, `command/before-attach-${key}` as any, argv, fields)\n      collectFields(argv, Command[`_${key}Fields`] as any, fields)\n      collectFields(argv, argv.command[`_${key}Fields`] as any, fields)\n    }\n    collect(argv)\n    return fields\n  },\n\n  inferCommand(argv) {\n    if (argv.command) return argv.command\n    if (argv.name) return argv.command = this.app.$commander.resolve(argv.name)\n\n    const { parsed, subtype } = this\n    // guild message should have prefix or appel to be interpreted as a command call\n    if (argv.root && subtype !== 'private' && parsed.prefix === null && !parsed.appel) return\n    const segments: string[] = []\n    while (argv.tokens.length) {\n      const { content } = argv.tokens[0]\n      segments.push(content)\n      const command = this.app.$commander.resolve(segments.join('.'))\n      if (!command) break\n      argv.tokens.shift()\n      argv.command = command\n      if (command['_actions'].length) break\n    }\n    return argv.command\n  },\n\n  resolve(argv) {\n    if (!this.inferCommand(argv)) return\n    if (argv.tokens?.every(token => !token.inters.length)) {\n      const { options, args, error } = argv.command.parse(argv)\n      argv.options = { ...argv.options, ...options }\n      argv.args = [...argv.args || [], ...args]\n      argv.error = error\n    }\n    return argv.command\n  },\n\n  async execute(argv, next) {\n    if (typeof argv === 'string') argv = Argv.parse(argv)\n\n    argv.session = this\n    if (argv.tokens) {\n      for (const arg of argv.tokens) {\n        const { inters } = arg\n        const output: string[] = []\n        for (let i = 0; i < inters.length; ++i) {\n          output.push(await this.execute(inters[i], true))\n        }\n        for (let i = inters.length - 1; i >= 0; --i) {\n          const { pos } = inters[i]\n          arg.content = arg.content.slice(0, pos) + output[i] + arg.content.slice(pos)\n        }\n        arg.inters = []\n      }\n      if (!this.resolve(argv)) return ''\n    } else {\n      argv.command ||= this.app.$commander.getCommand(argv.name)\n      if (!argv.command) {\n        logger.warn(new Error(`cannot find command ${argv.name}`))\n        return ''\n      }\n    }\n\n    const { command } = argv\n    if (!command.ctx.filter(this)) return ''\n\n    if (this.app.database) {\n      if (this.subtype === 'group') {\n        await this.observeChannel(this.collect('channel', argv))\n      }\n      await this.observeUser(this.collect('user', argv))\n    }\n\n    let shouldEmit = true\n    if (next === true) {\n      shouldEmit = false\n      next = undefined as Next\n    }\n\n    return this.withScope(`commands.${command.name}.messages`, async () => {\n      const result = await command.execute(argv as Argv, next as Next)\n      if (!shouldEmit) {\n        if (typeof result === 'string') return result\n        return segment(null, result).toString()\n      }\n      await this.send(result)\n      return ''\n    })\n  },\n\n  middleware(middleware) {\n    const id = getNarrowContextId(this)\n    return this.app.middleware(async (session, next) => {\n      if (id && getNarrowContextId(session) !== id) return next()\n      return middleware(session, next)\n    }, true)\n  },\n\n  prompt(...args: any[]) {\n    const callback: (session: Session) => any = typeof args[0] === 'function'\n      ? args.shift()\n      : session => session.content\n    const options: PromptOptions = typeof args[0] === 'number'\n      ? { timeout: args[0] }\n      : args[0] ?? {}\n    return new Promise<string>((resolve) => {\n      const dispose = this.middleware(async (session, next) => {\n        clearTimeout(timer)\n        dispose()\n        const value = await callback(session)\n        resolve(value)\n        if (isNullable(value)) return next()\n      })\n      const timer = setTimeout(() => {\n        dispose()\n        resolve(undefined)\n      }, options.timeout ?? this.app.config.delay.prompt)\n    })\n  },\n\n  async suggest(options: SuggestOptions) {\n    let { expect, prefix = '' } = options\n    if (options.actual) {\n      expect = expect.filter((name) => {\n        return name && this.app.i18n.compare(name, options.actual, options)\n      })\n    }\n    if (!expect.length) {\n      await this.send(prefix)\n      return\n    }\n\n    prefix += this.text('internal.suggest-hint', [expect.map(text => {\n      return this.text('general.quote', [text])\n    }).join(this.text('general.or'))])\n    if (expect.length > 1) {\n      await this.send(prefix)\n      return\n    }\n\n    await this.send(prefix + options.suffix)\n    return this.prompt((session) => {\n      const content = session.content.trim()\n      if (!content || content === '.' || content === '。') {\n        return expect[0]\n      }\n    }, options)\n  },\n\n  async transform(elements: segment[]) {\n    return await segment.transformAsync(elements, this.app.$internal._components, this)\n  },\n})\n\nfunction getNarrowContextId(session: Session) {\n  return '' + session.userId + session.channelId\n}\n\nexport type FieldCollector<T extends keyof Tables, K = keyof Tables[T], A extends any[] = any[], O = {}> =\n  | Iterable<K>\n  | ((argv: Argv<never, never, A, O>, fields: Set<keyof Tables[T]>) => void)\n\nfunction collectFields<T extends keyof Tables>(argv: Argv, collectors: FieldCollector<T>[], fields: Set<keyof Tables[T]>) {\n  for (const collector of collectors) {\n    if (typeof collector === 'function') {\n      collector(argv, fields)\n      continue\n    }\n    for (const field of collector) {\n      fields.add(field)\n    }\n  }\n  return fields\n}\n", "import { Awaitable, defineProperty } from 'cosmokit'\nimport { Context, Session } from '@satorijs/core'\nimport { Command } from './command'\nimport { Argv } from './parser'\nimport validate from './validate'\nimport { Channel, User } from '../database'\n\nexport * from './command'\nexport * from './parser'\nexport * from './validate'\n\ninterface CommandMap extends Map<string, Command> {\n  resolve(key: string): Command\n}\n\ndeclare module '@satorijs/core' {\n  interface Context {\n    $commander: Commander\n    command<D extends string>(def: D, config?: Command.Config): Command<never, never, Argv.ArgumentType<D>>\n    command<D extends string>(def: D, desc: string, config?: Command.Config): Command<never, never, Argv.ArgumentType<D>>\n  }\n\n  interface Events {\n    'before-parse'(content: string, session: Session): Argv\n    'command-added'(command: Command): void\n    'command-removed'(command: Command): void\n    'command-error'(argv: Argv, error: any): void\n    'command/before-execute'(argv: Argv): Awaitable<void | string>\n    'command/before-attach-channel'(argv: Argv, fields: Set<Channel.Field>): void\n    'command/before-attach-user'(argv: Argv, fields: Set<User.Field>): void\n  }\n}\n\nexport namespace Commander {\n  export interface Config {}\n}\n\nexport class Commander {\n  static readonly key = '$commander'\n  static readonly methods = ['command']\n\n  _commandList: Command[] = []\n  _commands = new Map<string, Command>() as CommandMap\n  _shortcuts: Command.Shortcut[] = []\n\n  constructor(private ctx: Context, private config: Commander.Config = {}) {\n    defineProperty(this, Context.current, ctx)\n    ctx.plugin(validate)\n\n    ctx.before('parse', (content, session) => {\n      const argv = Argv.parse(content)\n      if (session.quote) {\n        argv.tokens.push({\n          content: session.quote.content,\n          quoted: true,\n          inters: [],\n          terminator: '',\n        })\n      }\n      return argv\n    })\n\n    ctx.before('attach', (session) => {\n      defineProperty(session, 'argv', ctx.bail('before-parse', session.parsed.content, session))\n      session.argv.root = true\n      session.argv.session = session\n    })\n\n    ctx.middleware((session, next) => {\n      // execute command\n      if (!session.resolve(session.argv)) return next()\n      return session.execute(session.argv, next)\n    })\n\n    ctx.middleware((session, next) => {\n      // use `!prefix` instead of `prefix === null` to prevent from blocking other middlewares\n      // we need to make sure that the user truly has the intension to call a command\n      const { argv, quote, subtype, parsed: { content, prefix, appel } } = session\n      if (argv.command || subtype !== 'private' && !prefix && !appel) return next()\n      const actual = content.split(/\\s/, 1)[0].toLowerCase()\n      if (!actual) return next()\n\n      return next(async (next) => {\n        const name = await session.suggest({\n          actual,\n          expect: this.available(session),\n          suffix: session.text('internal.suggest-command'),\n        })\n        if (!name) return next()\n        const message = name + content.slice(actual.length) + (quote ? ' ' + quote.content : '')\n        return session.execute(message, next)\n      })\n    })\n  }\n\n  available(session: Session) {\n    return this._commandList\n      .filter(cmd => cmd.match(session))\n      .flatMap(cmd => cmd._aliases)\n  }\n\n  protected get caller() {\n    return this[Context.current]\n  }\n\n  resolve(key: string) {\n    if (!key) return\n    const segments = key.split('.')\n    let i = 1, name = segments[0], cmd: Command\n    while ((cmd = this.getCommand(name)) && i < segments.length) {\n      name = cmd.name + '.' + segments[i++]\n    }\n    return cmd\n  }\n\n  getCommand(name: string) {\n    return this._commands.get(name)\n  }\n\n  command(def: string, ...args: [Command.Config?] | [string, Command.Config?]) {\n    const desc = typeof args[0] === 'string' ? args.shift() as string : ''\n    const config = args[0] as Command.Config\n    const path = def.split(' ', 1)[0].toLowerCase()\n    const decl = def.slice(path.length)\n    const segments = path.split(/(?=[./])/g)\n\n    let parent: Command, root: Command\n    const list: Command[] = []\n    segments.forEach((segment, index) => {\n      const code = segment.charCodeAt(0)\n      const name = code === 46 ? parent.name + segment : code === 47 ? segment.slice(1) : segment\n      let command = this.getCommand(name)\n      if (command) {\n        if (parent) {\n          if (command === parent) {\n            throw new Error(`cannot set a command (${command.name}) as its own subcommand`)\n          }\n          if (command.parent) {\n            if (command.parent !== parent) {\n              throw new Error(`cannot create subcommand ${path}: ${command.parent.name}/${command.name} already exists`)\n            }\n          } else {\n            command.parent = parent\n            parent.children.push(command)\n          }\n        }\n        return parent = command\n      }\n      command = new Command(name, decl, this.caller)\n      list.push(command)\n      if (!root) root = command\n      if (parent) {\n        command.parent = parent\n        command.config.authority = parent.config.authority\n        parent.children.push(command)\n      }\n      parent = command\n    })\n\n    if (desc) this.caller.i18n.define('', `commands.${parent.name}.description`, desc)\n    Object.assign(parent.config, config)\n    list.forEach(command => this.caller.emit('command-added', command))\n    if (!config?.patch) {\n      if (root) this.caller.state.disposables.unshift(() => root.dispose())\n      return parent\n    }\n\n    if (root) root.dispose()\n    const command = Object.create(parent)\n    command._disposables = this.caller.state.disposables\n    return command\n  }\n}\n\nContext.service(Commander.key, Commander)\n", "import { Awaitable, camelize, Dict, isNullable, remove } from 'cosmokit'\nimport { coerce } from '@koishijs/utils'\nimport { Context, Fragment, Logger, Schema, Session } from '@satorijs/core'\nimport { Disposable } from 'cordis'\nimport { Argv } from './parser'\nimport { Next, SessionError } from '../internal'\nimport { Channel, User } from '../database'\nimport { Computed, FieldCollector } from '../session'\n\nconst logger = new Logger('command')\n\nexport type Extend<O extends {}, K extends string, T> = {\n  [P in K | keyof O]?: (P extends keyof O ? O[P] : unknown) & (P extends K ? T : unknown)\n}\n\nexport namespace Command {\n  export interface Shortcut {\n    i18n?: boolean\n    name?: string | RegExp\n    command?: Command\n    prefix?: boolean\n    fuzzy?: boolean\n    args?: string[]\n    options?: Dict\n  }\n\n  export type Action<U extends User.Field = never, G extends Channel.Field = never, A extends any[] = any[], O extends {} = {}>\n    = (argv: Argv<U, G, A, O>, ...args: A) => Awaitable<void | Fragment>\n\n  export type Usage<U extends User.Field = never, G extends Channel.Field = never>\n    = string | ((session: Session<U, G>) => Awaitable<string>)\n}\n\nexport class Command<U extends User.Field = never, G extends Channel.Field = never, A extends any[] = any[], O extends {} = {}> extends Argv.CommandBase {\n  config: Command.Config\n  children: Command[] = []\n  parent: Command = null\n\n  _aliases: string[] = []\n  _examples: string[] = []\n  _usage?: Command.Usage\n  _disposed?: boolean\n  _disposables?: Disposable[]\n  _disposables2: Disposable[] = []\n\n  private _userFields: FieldCollector<'user'>[] = [['locale']]\n  private _channelFields: FieldCollector<'channel'>[] = [['locale']]\n  private _actions: Command.Action[] = []\n  private _checkers: Command.Action[] = [async (argv) => {\n    return this.ctx.serial(argv.session, 'command/before-execute', argv)\n  }]\n\n  static defaultConfig: Command.Config = {\n    authority: 1,\n    showWarning: true,\n  }\n\n  static defaultOptionConfig: Argv.OptionConfig = {\n    authority: 0,\n  }\n\n  private static _userFields: FieldCollector<'user'>[] = []\n  private static _channelFields: FieldCollector<'channel'>[] = []\n\n  /** @deprecated use `command-added` event instead */\n  static userFields(fields: FieldCollector<'user'>) {\n    this._userFields.push(fields)\n    return this\n  }\n\n  /** @deprecated use `command-added` event instead */\n  static channelFields(fields: FieldCollector<'channel'>) {\n    this._channelFields.push(fields)\n    return this\n  }\n\n  constructor(name: string, decl: string, ctx: Context) {\n    super(name, decl, ctx)\n    this.config = { ...Command.defaultConfig }\n    this._registerAlias(name)\n    ctx.$commander._commandList.push(this)\n  }\n\n  get displayName() {\n    return this._aliases[0]\n  }\n\n  set displayName(name) {\n    this._registerAlias(name, true)\n  }\n\n  private _registerAlias(name: string, prepend = false) {\n    name = name.toLowerCase()\n\n    // add to list\n    const done = this._aliases.includes(name)\n    if (done) {\n      if (prepend) {\n        remove(this._aliases, name)\n        this._aliases.unshift(name)\n      }\n      return\n    } else if (prepend) {\n      this._aliases.unshift(name)\n    } else {\n      this._aliases.push(name)\n    }\n\n    // register global\n    const previous = this.ctx.$commander.getCommand(name)\n    if (!previous) {\n      this.ctx.$commander._commands.set(name, this)\n    } else if (previous !== this) {\n      throw new Error(`duplicate command names: \"${name}\"`)\n    }\n\n    // add disposable\n    this._disposables?.push(() => {\n      remove(this._aliases, name)\n      this.ctx.$commander._commands.delete(name)\n    })\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return `Command <${this.name}>`\n  }\n\n  userFields<T extends User.Field = never>(fields: FieldCollector<'user', T, A, O>): Command<U | T, G, A, O> {\n    this._userFields.push(fields)\n    return this as any\n  }\n\n  channelFields<T extends Channel.Field = never>(fields: FieldCollector<'channel', T, A, O>): Command<U, G | T, A, O> {\n    this._channelFields.push(fields)\n    return this as any\n  }\n\n  alias(...names: string[]) {\n    if (this._disposed) return this\n    for (const name of names) {\n      this._registerAlias(name)\n    }\n    return this\n  }\n\n  _escape(source: any) {\n    if (typeof source !== 'string') return source\n    return source\n      .replace(/\\$\\$/g, '@@__PLACEHOLDER__@@')\n      .replace(/\\$\\d/g, s => `{${s[1]}}`)\n      .replace(/@@__PLACEHOLDER__@@/g, '$')\n  }\n\n  shortcut(pattern: string | RegExp, config?: Command.Shortcut & { i18n?: false }): this\n  shortcut(pattern: string, config: Command.Shortcut & { i18n: true }): this\n  shortcut(pattern: string | RegExp, config: Command.Shortcut = {}) {\n    if (this._disposed) return this\n    let content = this.displayName\n    for (const arg of config.args || []) {\n      content += ' ' + this._escape(arg)\n    }\n    for (const key in config.options || {}) {\n      content += ` --${camelize(key)}`\n      const value = config.options[key]\n      if (value !== true) {\n        content += ' ' + this._escape(value)\n      }\n    }\n    if (config.fuzzy) content += ' {0}'\n    if (typeof pattern === 'string') {\n      if (config.i18n) {\n        pattern = `commands.${this.name}.shortcuts.${pattern}`\n      } else {\n        config.i18n = true\n        const key = `commands.${this.name}.shortcuts._${Math.random().toString(36).slice(2)}`\n        this.ctx.i18n.define('', key, pattern)\n        pattern = key\n      }\n    }\n    const dispose = this.ctx.match(pattern, `<execute>${content}</execute>`, {\n      appel: config.prefix,\n      fuzzy: config.fuzzy,\n      i18n: config.i18n as never,\n    })\n    this._disposables2.push(dispose)\n    return this\n  }\n\n  subcommand<D extends string>(def: D, config?: Command.Config): Command<never, never, Argv.ArgumentType<D>>\n  subcommand<D extends string>(def: D, desc: string, config?: Command.Config): Command<never, never, Argv.ArgumentType<D>>\n  subcommand(def: string, ...args: any[]) {\n    def = this.name + (def.charCodeAt(0) === 46 ? '' : '/') + def\n    const desc = typeof args[0] === 'string' ? args.shift() as string : ''\n    const config = args[0] as Command.Config || {}\n    if (this._disposed) config.patch = true\n    return this.ctx.command(def, desc, config)\n  }\n\n  usage(text: Command.Usage<U, G>) {\n    this._usage = text\n    return this\n  }\n\n  example(example: string) {\n    this._examples.push(example)\n    return this\n  }\n\n  option<K extends string>(name: K, desc: string, config: Argv.TypedOptionConfig<RegExp>): Command<U, G, A, Extend<O, K, string>>\n  option<K extends string, R>(name: K, desc: string, config: Argv.TypedOptionConfig<(source: string) => R>): Command<U, G, A, Extend<O, K, R>>\n  option<K extends string, R extends string>(name: K, desc: string, config: Argv.TypedOptionConfig<R[]>): Command<U, G, A, Extend<O, K, R>>\n  option<K extends string, D extends string>(name: K, desc: D, config?: Argv.OptionConfig): Command<U, G, A, Extend<O, K, Argv.OptionType<D>>>\n  option(name: string, ...args: [Argv.OptionConfig?] | [string, Argv.OptionConfig?]) {\n    let desc = ''\n    if (typeof args[0] === 'string') {\n      desc = args.shift() as string\n    }\n    const config = args[0] as Argv.OptionConfig\n    this._createOption(name, desc, config || {})\n    this._disposables?.push(() => this.removeOption(name))\n    return this\n  }\n\n  match(session: Session) {\n    const { authority = Infinity } = (session.user || {}) as User\n    return this.ctx.filter(session) && this.config.authority <= authority\n  }\n\n  getConfig<K extends keyof Command.Config>(key: K, session: Session): Exclude<Command.Config[K], (session: Session) => any> {\n    const value = this.config[key] as any\n    return typeof value === 'function' ? value(session) : value\n  }\n\n  check(callback: Command.Action<U, G, A, O>, append = false) {\n    return this.before(callback, append)\n  }\n\n  before(callback: Command.Action<U, G, A, O>, append = false) {\n    if (append) {\n      this._checkers.push(callback)\n    } else {\n      this._checkers.unshift(callback)\n    }\n    this._disposables?.push(() => remove(this._checkers, callback))\n    return this\n  }\n\n  action(callback: Command.Action<U, G, A, O>, prepend = false) {\n    if (prepend) {\n      this._actions.unshift(callback)\n    } else {\n      this._actions.push(callback)\n    }\n    this._disposables?.push(() => remove(this._actions, callback))\n    return this\n  }\n\n  use<T extends Command, R extends any[]>(callback: (command: this, ...args: R) => T, ...args: R): T {\n    return callback(this, ...args)\n  }\n\n  async execute(argv: Argv<U, G, A, O>, fallback: Next = Next.compose): Promise<Fragment> {\n    argv.command ??= this\n    argv.args ??= [] as any\n    argv.options ??= {} as any\n\n    const { args, options, error } = argv\n    if (error) return error\n    if (logger.level >= 3) logger.debug(argv.source ||= this.stringify(args, options))\n\n    // before hooks\n    for (const validator of this._checkers) {\n      const result = await validator.call(this, argv, ...args)\n      if (typeof result === 'string') return result\n    }\n\n    // FIXME empty actions will cause infinite loop\n    if (!this._actions.length) return ''\n\n    let index = 0\n    const queue: Next.Queue = this._actions.map(action => async () => {\n      return await action.call(this, argv, ...args)\n    })\n\n    queue.push(fallback)\n    const length = queue.length\n    argv.next = async (callback) => {\n      if (callback !== undefined) {\n        queue.push(next => Next.compose(callback, next))\n        if (queue.length > Next.MAX_DEPTH) {\n          throw new Error(`middleware stack exceeded ${Next.MAX_DEPTH}`)\n        }\n      }\n      return queue[index++]?.(argv.next)\n    }\n\n    try {\n      const result = await argv.next()\n      if (!isNullable(result)) return result\n    } catch (error) {\n      if (index === length) throw error\n      if (error instanceof SessionError) {\n        return argv.session.text(error.path, error.param)\n      }\n      const stack = coerce(error)\n      logger.warn(`${argv.source ||= this.stringify(args, options)}\\n${stack}`)\n      this.ctx.emit(argv.session, 'command-error', argv, error)\n    }\n\n    return ''\n  }\n\n  dispose() {\n    this._disposed = true\n    this._disposables2.forEach(dispose => dispose())\n    this.ctx.emit('command-removed', this)\n    for (const cmd of this.children.slice()) {\n      cmd.dispose()\n    }\n    this._aliases.forEach(name => this.ctx.$commander._commands.delete(name))\n    remove(this.ctx.$commander._commandList, this)\n    if (this.parent) {\n      remove(this.parent.children, this)\n    }\n  }\n}\n\nexport namespace Command {\n  export interface Config {\n    /** min authority */\n    authority?: Computed<number>\n    /** disallow unknown options */\n    checkUnknown?: boolean\n    /** check argument count */\n    checkArgCount?: boolean\n    /** show command warnings */\n    showWarning?: boolean\n    /** depend on existing commands */\n    patch?: boolean\n  }\n\n  export const Config: Schema<Config> = Schema.object({\n    authority: Schema.union([\n      Schema.natural(),\n      Schema.function(),\n    ]).default(1),\n    hidden: Schema.boolean().default(false),\n    checkArgCount: Schema.boolean().default(false),\n    checkUnknown: Schema.boolean().default(false),\n  })\n}\n", "import { camelCase, Dict, paramCase, Time } from 'cosmokit'\nimport { escapeRegExp } from '@koishijs/utils'\nimport { Context, segment, Session } from '@satorijs/core'\nimport { Command } from './command'\nimport { Channel, User } from '../database'\nimport { Next } from '../internal'\n\nexport interface Token {\n  rest?: string\n  content: string\n  quoted: boolean\n  terminator: string\n  inters: Argv[]\n}\n\nexport interface Argv<U extends User.Field = never, G extends Channel.Field = never, A extends any[] = any[], O extends {} = {}> {\n  args?: A\n  options?: O\n  error?: string\n  source?: string\n  initiator?: string\n  terminator?: string\n  session?: Session<U, G>\n  command?: Command<U, G, A, O>\n  rest?: string\n  pos?: number\n  root?: boolean\n  tokens?: Token[]\n  name?: string\n  next?: Next\n}\n\nconst leftQuotes = `\"'“‘`\nconst rightQuotes = `\"'”’`\n\nexport namespace Argv {\n  export interface Interpolation {\n    terminator?: string\n    parse?(source: string): Argv\n  }\n\n  const bracs: Dict<Interpolation> = {}\n\n  export function interpolate(initiator: string, terminator: string, parse?: (source: string) => Argv) {\n    bracs[initiator] = { terminator, parse }\n  }\n\n  interpolate('$(', ')')\n\n  export namespace whitespace {\n    export const unescape = (source: string) => source\n      .replace(/@__KOISHI_SPACE__@/g, ' ')\n      .replace(/@__KOISHI_NEWLINE__@/g, '\\n')\n      .replace(/@__KOISHI_RETURN__@/g, '\\r')\n      .replace(/@__KOISHI_TAB__@/g, '\\t')\n\n    export const escape = (source: string) => source\n      .replace(/ /g, '@__KOISHI_SPACE__@')\n      .replace(/\\n/g, '@__KOISHI_NEWLINE__@')\n      .replace(/\\r/g, '@__KOISHI_RETURN__@')\n      .replace(/\\t/g, '@__KOISHI_TAB__@')\n  }\n\n  export class Tokenizer {\n    private bracs: Dict<Interpolation>\n\n    constructor() {\n      this.bracs = Object.create(bracs)\n    }\n\n    interpolate(initiator: string, terminator: string, parse?: (source: string) => Argv) {\n      this.bracs[initiator] = { terminator, parse }\n    }\n\n    parseToken(source: string, stopReg = '$'): Token {\n      const parent = { inters: [] } as Token\n      const index = leftQuotes.indexOf(source[0])\n      const quote = rightQuotes[index]\n      let content = ''\n      if (quote) {\n        source = source.slice(1)\n        stopReg = `${quote}(?=${stopReg})|$`\n      }\n      stopReg += `|${Object.keys({ ...this.bracs, ...bracs }).map(escapeRegExp).join('|')}`\n      const regExp = new RegExp(stopReg)\n      while (true) {\n        const capture = regExp.exec(source)\n        content += whitespace.unescape(source.slice(0, capture.index))\n        if (capture[0] in this.bracs) {\n          source = source.slice(capture.index + capture[0].length).trimStart()\n          const { parse, terminator } = this.bracs[capture[0]]\n          const argv = parse?.(source) || this.parse(source, terminator)\n          source = argv.rest\n          parent.inters.push({ ...argv, pos: content.length, initiator: capture[0] })\n        } else {\n          const quoted = capture[0] === quote\n          const rest = source.slice(capture.index + +quoted)\n          parent.rest = rest.trimStart()\n          parent.quoted = quoted\n          parent.terminator = capture[0]\n          if (quoted) {\n            parent.terminator += rest.slice(0, -parent.rest.length)\n          } else if (quote) {\n            content = leftQuotes[index] + content\n            parent.inters.forEach(inter => inter.pos += 1)\n          }\n          parent.content = content\n          if (quote === \"'\") Argv.revert(parent)\n          return parent\n        }\n      }\n    }\n\n    parse(source: string, terminator = ''): Argv {\n      const tokens: Token[] = []\n      source = segment.parse(source).map((el) => {\n        return el.type === 'text' ? el.toString() : whitespace.escape(el.toString())\n      }).join('')\n      let rest = source, term = ''\n      const stopReg = `\\\\s+|[${escapeRegExp(terminator)}]|$`\n      // eslint-disable-next-line no-unmodified-loop-condition\n      while (rest && !(terminator && rest.startsWith(terminator))) {\n        const token = this.parseToken(rest, stopReg)\n        tokens.push(token)\n        rest = token.rest\n        term = token.terminator\n        delete token.rest\n      }\n      if (rest.startsWith(terminator)) rest = rest.slice(1)\n      source = source.slice(0, -(rest + term).length)\n      rest = whitespace.unescape(rest)\n      source = whitespace.unescape(source)\n      return { tokens, rest, source }\n    }\n\n    stringify(argv: Argv) {\n      const output = argv.tokens.reduce((prev, token) => {\n        if (token.quoted) prev += leftQuotes[rightQuotes.indexOf(token.terminator[0])] || ''\n        return prev + token.content + token.terminator\n      }, '')\n      if (argv.rest && !rightQuotes.includes(output[output.length - 1]) || argv.initiator) {\n        return output.slice(0, -1)\n      }\n      return output\n    }\n  }\n\n  const defaultTokenizer = new Tokenizer()\n\n  export function parse(source: string, terminator = '') {\n    return defaultTokenizer.parse(source, terminator)\n  }\n\n  export function stringify(argv: Argv) {\n    return defaultTokenizer.stringify(argv)\n  }\n\n  export function revert(token: Token) {\n    while (token.inters.length) {\n      const { pos, source, initiator } = token.inters.pop()\n      token.content = token.content.slice(0, pos)\n        + initiator + source + bracs[initiator].terminator\n        + token.content.slice(pos)\n    }\n  }\n\n  // builtin domains\n  export interface Domain {\n    string: string\n    number: number\n    boolean: boolean\n    text: string\n    rawtext: string\n    user: string\n    channel: string\n    integer: number\n    posint: number\n    natural: number\n    date: Date\n  }\n\n  type DomainType = keyof Domain\n\n  type ParamType<S extends string, F>\n    = S extends `${any}:${infer T}` ? T extends DomainType ? Domain[T] : F : F\n\n  type Replace<S extends string, X extends string, Y extends string>\n    = S extends `${infer L}${X}${infer R}` ? `${L}${Y}${Replace<R, X, Y>}` : S\n\n  type ExtractAll<S extends string, F>\n    = S extends `${infer L}]${infer R}` ? [ParamType<L, F>, ...ExtractAll<R, F>] : []\n\n  type ExtractFirst<S extends string, F>\n    = S extends `${infer L}]${any}` ? ParamType<L, F> : boolean\n\n  type ExtractSpread<S extends string> = S extends `${infer L}...${infer R}`\n    ? [...ExtractAll<L, string>, ...ExtractFirst<R, string>[]]\n    : [...ExtractAll<S, string>, ...string[]]\n\n  export type ArgumentType<S extends string> = ExtractSpread<Replace<S, '>', ']'>>\n\n  export type OptionType<S extends string> = ExtractFirst<Replace<S, '>', ']'>, any>\n\n  export type Type = DomainType | RegExp | readonly string[] | Transform<any>\n\n  export interface Declaration {\n    name?: string\n    type?: Type\n    fallback?: any\n    variadic?: boolean\n    required?: boolean\n  }\n\n  export type Transform<T> = (source: string, session: Session) => T\n\n  export interface DomainConfig<T> {\n    transform?: Transform<T>\n    greedy?: boolean\n  }\n\n  function resolveConfig(type: Type) {\n    return typeof type === 'string' ? builtin[type] || {} : {}\n  }\n\n  // https://github.com/microsoft/TypeScript/issues/17002\n  // it never got fixed so we have to do this\n  const isArray = Array.isArray as (arg: any) => arg is readonly any[]\n\n  function resolveType(type: Type) {\n    if (typeof type === 'function') {\n      return type\n    } else if (type instanceof RegExp) {\n      return (source: string) => {\n        if (type.test(source)) return source\n        throw new Error()\n      }\n    } else if (isArray(type)) {\n      return (source: string) => {\n        if (type.includes(source)) return source\n        throw new Error()\n      }\n    }\n    return builtin[type]?.transform\n  }\n\n  const builtin: Dict<DomainConfig<any>> = {}\n\n  export function createDomain<K extends keyof Domain>(name: K, transform: Transform<Domain[K]>, options?: DomainConfig<Domain[K]>) {\n    builtin[name] = { ...options, transform }\n  }\n\n  createDomain('string', source => source)\n  createDomain('text', source => source, { greedy: true })\n  createDomain('rawtext', source => segment.unescape(source), { greedy: true })\n  createDomain('boolean', () => true)\n\n  createDomain('number', (source, session) => {\n    const value = +source\n    if (Number.isFinite(value)) return value\n    throw new Error('internal.invalid-number')\n  })\n\n  createDomain('integer', (source, session) => {\n    const value = +source\n    if (value * 0 === 0 && Math.floor(value) === value) return value\n    throw new Error('internal.invalid-integer')\n  })\n\n  createDomain('posint', (source, session) => {\n    const value = +source\n    if (value * 0 === 0 && Math.floor(value) === value && value > 0) return value\n    throw new Error('internal.invalid-posint')\n  })\n\n  createDomain('natural', (source, session) => {\n    const value = +source\n    if (value * 0 === 0 && Math.floor(value) === value && value >= 0) return value\n    throw new Error('internal.invalid-natural')\n  })\n\n  createDomain('date', (source, session) => {\n    const timestamp = Time.parseDate(source)\n    if (+timestamp) return timestamp\n    throw new Error('internal.invalid-date')\n  })\n\n  createDomain('user', (source, session) => {\n    if (source.startsWith('@')) {\n      source = source.slice(1)\n      if (source.includes(':')) return source\n      return `${session.platform}:${source}`\n    }\n    const code = segment.from(source)\n    if (code && code.type === 'at') {\n      return `${session.platform}:${code.data.id}`\n    }\n    throw new Error('internal.invalid-user')\n  })\n\n  createDomain('channel', (source, session) => {\n    if (source.startsWith('#')) {\n      source = source.slice(1)\n      if (source.includes(':')) return source\n      return `${session.platform}:${source}`\n    }\n    const code = segment.from(source)\n    if (code && code.type === 'sharp') {\n      return `${session.platform}:${code.data.id}`\n    }\n    throw new Error('internal.invalid-channel')\n  })\n\n  const BRACKET_REGEXP = /<[^>]+>|\\[[^\\]]+\\]/g\n\n  interface DeclarationList extends Array<Declaration> {\n    stripped: string\n  }\n\n  function parseDecl(source: string) {\n    let cap: RegExpExecArray\n    const result = [] as DeclarationList\n    // eslint-disable-next-line no-cond-assign\n    while (cap = BRACKET_REGEXP.exec(source)) {\n      let rawName = cap[0].slice(1, -1)\n      let variadic = false\n      if (rawName.startsWith('...')) {\n        rawName = rawName.slice(3)\n        variadic = true\n      }\n      const [name, rawType] = rawName.split(':')\n      const type = rawType ? rawType.trim() as DomainType : undefined\n      result.push({\n        name,\n        variadic,\n        type,\n        required: cap[0][0] === '<',\n      })\n    }\n    result.stripped = source.replace(/:[\\w-]+[>\\]]/g, str => str.slice(-1)).trimEnd()\n    return result\n  }\n\n  export function parseValue(source: string, quoted: boolean, kind: string, argv: Argv, decl: Declaration = {}) {\n    const { name, type } = decl\n\n    // apply domain callback\n    const transform = resolveType(type)\n    if (transform) {\n      try {\n        return transform(source, argv.session)\n      } catch (err) {\n        if (!argv.session) {\n          argv.error = `internal.invalid-${kind}`\n        } else {\n          const message = argv.session.text(err['message'] || 'internal.check-syntax')\n          argv.error = argv.session.text(`internal.invalid-${kind}`, [name, message])\n        }\n        return\n      }\n    }\n\n    // no explicit parameter\n    if (source === '' && !quoted) return true\n\n    // default behavior\n    if (quoted) return source\n    const n = +source\n    return n * 0 === 0 ? n : source\n  }\n\n  export interface OptionConfig<T extends Type = Type> {\n    value?: any\n    fallback?: any\n    type?: T\n    authority?: number\n    descPath?: string\n  }\n\n  export interface TypedOptionConfig<T extends Type> extends OptionConfig<T> {\n    type: T\n  }\n\n  export interface OptionVariant extends OptionConfig {\n    syntax: string\n  }\n\n  export interface OptionDeclaration extends Declaration, OptionVariant {\n    values: Dict<any>\n    /** @deprecated */\n    valuesSyntax: Dict<string>\n    variants: Dict<OptionVariant>\n  }\n\n  type OptionDeclarationMap = Dict<OptionDeclaration>\n\n  export class CommandBase {\n    public declaration: string\n\n    public _arguments: Declaration[]\n    public _options: OptionDeclarationMap = {}\n\n    private _namedOptions: OptionDeclarationMap = {}\n    private _symbolicOptions: OptionDeclarationMap = {}\n\n    constructor(public readonly name: string, declaration: string, public ctx: Context) {\n      if (!name) throw new Error('expect a command name')\n      const decl = this._arguments = parseDecl(declaration)\n      this.declaration = decl.stripped\n    }\n\n    _createOption(name: string, def: string, config: OptionConfig) {\n      // do not use lookbehind assertion for Safari compatibility\n      const cap = /^((?:-[\\w-]*|[^,\\s\\w\\x80-\\uffff]+)(?:,\\s*(?:-[\\w-]*|[^,\\s\\w\\x80-\\uffff]+))*(?=\\s|$))?((?:\\s*\\[[^\\]]+?\\]|\\s*<[^>]+?>)*)(.*)$/.exec(def)\n      const param = paramCase(name)\n      let syntax = cap[1] || '--' + param\n      const bracket = cap[2] || ''\n      const desc = cap[3].trim()\n\n      const names: string[] = []\n      const symbols: string[] = []\n      for (let param of syntax.trim().split(',')) {\n        param = param.trimStart()\n        const name = param.replace(/^-+/, '')\n        if (!name || !param.startsWith('-')) {\n          symbols.push(segment.escape(param))\n        } else {\n          names.push(name)\n        }\n      }\n\n      if (!('value' in config) && !names.includes(param)) {\n        syntax += ', --' + param\n      }\n\n      const declList = parseDecl(bracket.trimStart())\n      if (declList.stripped) syntax += ' ' + declList.stripped\n      const option = this._options[name] ||= {\n        ...Command.defaultOptionConfig,\n        ...declList[0],\n        ...config,\n        name,\n        values: {},\n        valuesSyntax: {},\n        variants: {},\n        syntax,\n      }\n\n      let path = `commands.${this.name}.options.${name}`\n      const fallbackType = typeof option.fallback\n      if ('value' in config) {\n        path += '.' + config.value\n        option.variants[config.value] = { ...config, syntax }\n        option.valuesSyntax[config.value] = syntax\n        names.forEach(name => option.values[name] = config.value)\n      } else if (!bracket.trim()) {\n        option.type = 'boolean'\n      } else if (!option.type && (fallbackType === 'string' || fallbackType === 'number')) {\n        option.type = fallbackType\n      }\n\n      if (desc) {\n        this.ctx.i18n.define('', path, desc)\n      }\n\n      this._assignOption(option, names, this._namedOptions)\n      this._assignOption(option, symbols, this._symbolicOptions)\n      if (!this._namedOptions[param]) {\n        this._namedOptions[param] = option\n      }\n    }\n\n    private _assignOption(option: OptionDeclaration, names: readonly string[], optionMap: OptionDeclarationMap) {\n      for (const name of names) {\n        if (name in optionMap) {\n          throw new Error(`duplicate option name \"${name}\" for command \"${this.name}\"`)\n        }\n        optionMap[name] = option\n      }\n    }\n\n    removeOption<K extends string>(name: K) {\n      if (!this._options[name]) return false\n      const option = this._options[name]\n      delete this._options[name]\n      for (const key in this._namedOptions) {\n        if (this._namedOptions[key] === option) {\n          delete this._namedOptions[key]\n        }\n      }\n      for (const key in this._symbolicOptions) {\n        if (this._symbolicOptions[key] === option) {\n          delete this._symbolicOptions[key]\n        }\n      }\n      return true\n    }\n\n    parse(argv: string | Argv, terminator?: string, args: any[] = [], options: Dict<any> = {}): Argv {\n      if (typeof argv === 'string') argv = Argv.parse(argv, terminator)\n\n      if (!argv.source && argv.tokens) {\n        argv.source = this.name + ' ' + Argv.stringify(argv)\n      }\n\n      while (!argv.error && argv.tokens?.length) {\n        const token = argv.tokens[0]\n        let { content, quoted } = token\n\n        // greedy argument\n        const argDecl = this._arguments[args.length]\n        if (content[0] !== '-' && resolveConfig(argDecl?.type).greedy) {\n          args.push(Argv.parseValue(Argv.stringify(argv), true, 'argument', argv, argDecl))\n          break\n        }\n\n        // parse token\n        argv.tokens.shift()\n        let option: OptionDeclaration\n        let names: string | string[]\n        let param: string\n        // symbolic option\n        if (!quoted && (option = this._symbolicOptions[content])) {\n          names = [paramCase(option.name)]\n        } else {\n          // normal argument\n          if (content[0] !== '-' || quoted) {\n            args.push(Argv.parseValue(content, quoted, 'argument', argv, argDecl || { type: 'string' }))\n            continue\n          }\n\n          // find -\n          let i = 0\n          let name: string\n          for (; i < content.length; ++i) {\n            if (content.charCodeAt(i) !== 45) break\n          }\n          if (content.slice(i, i + 3) === 'no-' && !this._namedOptions[content.slice(i)]) {\n            name = content.slice(i + 3)\n            options[camelCase(name)] = false\n            continue\n          }\n\n          // find =\n          let j = i + 1\n          for (; j < content.length; j++) {\n            if (content.charCodeAt(j) === 61) break\n          }\n          name = content.slice(i, j)\n          names = i > 1 ? [name] : name\n          param = content.slice(++j)\n          option = this._namedOptions[names[names.length - 1]]\n        }\n\n        // get parameter from next token\n        quoted = false\n        if (!param) {\n          const { type } = option || {}\n          if (resolveConfig(type).greedy) {\n            param = Argv.stringify(argv)\n            quoted = true\n            argv.tokens = []\n          } else if (type !== 'boolean' && argv.tokens.length && (type || argv.tokens[0]?.content !== '-')) {\n            const token = argv.tokens.shift()\n            param = token.content\n            quoted = token.quoted\n          }\n        }\n\n        // handle each name\n        for (let j = 0; j < names.length; j++) {\n          const name = names[j]\n          const optDecl = this._namedOptions[name]\n          const key = optDecl ? optDecl.name : camelCase(name)\n          if (optDecl && name in optDecl.values) {\n            options[key] = optDecl.values[name]\n          } else {\n            const source = j + 1 < names.length ? '' : param\n            options[key] = Argv.parseValue(source, quoted, 'option', argv, optDecl)\n          }\n          if (argv.error) break\n        }\n      }\n\n      // assign default values\n      for (const { name, fallback } of Object.values(this._options)) {\n        if (fallback !== undefined && !(name in options)) {\n          options[name] = fallback\n        }\n      }\n\n      delete argv.tokens\n      return { ...argv, options, args, error: argv.error || '', command: this as any }\n    }\n\n    private stringifyArg(value: any) {\n      value = '' + value\n      return value.includes(' ') ? `\"${value}\"` : value\n    }\n\n    stringify(args: readonly string[], options: any) {\n      let output = this.name\n      for (const key in options) {\n        const value = options[key]\n        if (value === true) {\n          output += ` --${key}`\n        } else if (value === false) {\n          output += ` --no-${key}`\n        } else {\n          output += ` --${key} ${this.stringifyArg(value)}`\n        }\n      }\n      for (const arg of args) {\n        output += ' ' + this.stringifyArg(arg)\n      }\n      return output\n    }\n  }\n}\n", "import { Context } from '@satorijs/core'\nimport { Argv } from './parser'\n\nexport default function validate(ctx: Context) {\n  // add user fields\n  ctx.on('command-added', (cmd) => {\n    cmd.userFields(({ tokens, command, options = {} }, fields) => {\n      if (!command) return\n      const { authority } = command.config\n      let shouldFetchAuthority = authority > 0\n      for (const { name, authority } of Object.values(command._options)) {\n        if (name in options) {\n          if (authority > 0) shouldFetchAuthority = true\n        } else if (tokens) {\n          if (authority > 0) shouldFetchAuthority = true\n        }\n      }\n      if (shouldFetchAuthority) fields.add('authority')\n    })\n  })\n\n  // check user\n  ctx.before('command/execute', (argv: Argv<'authority'>) => {\n    const { session, options, command } = argv\n    if (!session.user) return\n\n    function sendHint(message: string, ...param: any[]) {\n      return command.config.showWarning ? session.text(message, param) : ''\n    }\n\n    // check authority\n    if (typeof session.user.authority === 'number') {\n      const authority = command.getConfig('authority', session)\n      if (authority > session.user.authority) {\n        return sendHint('internal.low-authority')\n      }\n    }\n    for (const option of Object.values(command._options)) {\n      if (option.name in options) {\n        if (option.authority > session.user.authority) {\n          return sendHint('internal.low-authority')\n        }\n      }\n    }\n  }, true)\n\n  // check argv\n  ctx.before('command/execute', (argv: Argv) => {\n    const { args, options, command, session } = argv\n    function sendHint(message: string, ...param: any[]) {\n      return command.config.showWarning ? session.text(message, param) : ''\n    }\n\n    // check argument count\n    if (command.config.checkArgCount) {\n      const nextArg = command._arguments[args.length] || {}\n      if (nextArg.required) {\n        return sendHint('internal.insufficient-arguments')\n      }\n      const finalArg = command._arguments[command._arguments.length - 1] || {}\n      if (args.length > command._arguments.length && finalArg.type !== 'text' && !finalArg.variadic) {\n        return sendHint('internal.redunant-arguments')\n      }\n    }\n\n    // check unknown options\n    if (command.config.checkUnknown) {\n      const unknown = Object.keys(options).filter(key => !command._options[key])\n      if (unknown.length) {\n        return sendHint('internal.unknown-option', unknown.join(', '))\n      }\n    }\n  }, true)\n}\n"],
  "mappings": "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",
  "names": ["Service", "import_core", "Service", "import_cosmokit", "import_core", "User", "Flag", "Channel", "import_utils", "import_cosmokit", "import_core", "path", "import_utils", "import_cosmokit", "import_core", "Next", "pattern", "_a", "next", "import_cosmokit", "import_core", "import_utils", "import_utils", "import_cosmokit", "import_core", "import_cosmokit", "import_core", "import_cosmokit", "import_utils", "import_core", "import_cosmokit", "import_utils", "import_core", "Argv", "parse", "whitespace", "resolveConfig", "param", "name", "token", "logger", "_a", "error", "Command", "authority", "next", "segment", "command", "logger", "channel", "key", "user", "path", "argv", "_a"]
}
