/// <reference types="node" />
import * as utils from '@koishijs/utils';
import * as cordis from 'cordis';
import { Dict, Awaitable, Promisify } from 'cosmokit';
import { Fragment, Context, Render, Session, Schema, segment, Events, Logger } from '@satorijs/core';
import { Database, Driver, Update } from '@minatojs/core';
import { Disposable, GetEvents, Parameters, ReturnType, ThisType } from 'cordis';
import { version } from '../package.json';
declare module '@satorijs/core' {
    interface Bot {
        getGuildMemberMap(guildId: string): Promise<Dict<string>>;
        broadcast(channels: (string | [string, string])[], content: Fragment, delay?: number): Promise<string[]>;
    }
    interface Events {
        'appellation'(name: string, session: Session): string;
    }
}
export * from '@satorijs/core';
declare module '@satorijs/core' {
    interface Events {
        'model'(name: keyof Tables): void;
    }
    interface Context {
        database: DatabaseService;
        model: DatabaseService;
        getSelfIds(type?: string, assignees?: string[]): Dict<string[]>;
        broadcast(content: Fragment, forced?: boolean): Promise<string[]>;
        broadcast(channels: readonly string[], content: Fragment, forced?: boolean): Promise<string[]>;
    }
}
export interface User {
    id: number;
    flag: number;
    authority: number;
    name: string;
    locale: string;
}
export namespace User {
    enum Flag {
        ignore = 1
    }
    type Field = keyof User;
    const fields: Field[];
    type Observed<K extends Field = Field> = utils.Observed<Pick<User, K>, Promise<void>>;
}
export interface Channel {
    id: string;
    platform: string;
    flag: number;
    assignee: string;
    guildId: string;
    locale: string;
}
export namespace Channel {
    enum Flag {
        ignore = 1,
        silent = 4
    }
    type Field = keyof Channel;
    const fields: Field[];
    type Observed<K extends Field = Field> = utils.Observed<Pick<Channel, K>, Promise<void>>;
}
export interface Tables {
    user: User;
    channel: Channel;
}
export class DatabaseService extends Database<Tables> {
    protected app: Context;
    static readonly methods: string[];
    constructor(app: Context);
    getUser<T extends string, K extends User.Field>(platform: T, id: string, modifier?: Driver.Cursor<K>): Promise<Pick<User, K> & Record<T, string>>;
    getUser<T extends string, K extends User.Field>(platform: T, ids: string[], modifier?: Driver.Cursor<K>): Promise<Pick<User, K>[]>;
    setUser(platform: string, id: string, data: Update<User>): Promise<void>;
    createUser(platform: string, id: string, data: Partial<User>): Promise<User>;
    getChannel<K extends Channel.Field>(platform: string, id: string, modifier?: Driver.Cursor<K>): Promise<Pick<Channel, K | 'id' | 'platform'>>;
    getChannel<K extends Channel.Field>(platform: string, ids: string[], modifier?: Driver.Cursor<K>): Promise<Pick<Channel, K>[]>;
    getSelfIds(type?: string, assignees?: string[]): Dict<string[]>;
    getAssignedChannels<K extends Channel.Field>(fields?: K[], assignMap?: Dict<string[]>): Promise<Pick<Channel, K>[]>;
    setChannel(platform: string, id: string, data: Update<Channel>): Promise<void>;
    createChannel(platform: string, id: string, data: Partial<Channel>): Promise<Channel>;
    broadcast(...args: [Fragment, boolean?] | [readonly string[], Fragment, boolean?]): Promise<any[]>;
}
export const defineDriver: <T>(constructor: Driver.Constructor<T>, schema?: utils.Schema, prepare?: Plugin.Function<T>) => Plugin.Object<T, any>;
declare module '@satorijs/core' {
    interface Context {
        $internal: Internal;
        component(name: string, component: Component, options?: Component.Options): () => boolean;
        middleware(middleware: Middleware, prepend?: boolean): () => boolean;
        match(pattern: string | RegExp, response: Fragment, options?: Matcher.Options & {
            i18n?: false;
        }): () => boolean;
        match(pattern: string, response: string, options: Matcher.Options & {
            i18n: true;
        }): () => boolean;
    }
    interface Events {
        'before-attach-channel'(session: Session, fields: Set<Channel.Field>): void;
        'attach-channel'(session: Session): Awaitable<void | boolean>;
        'before-attach-user'(session: Session, fields: Set<User.Field>): void;
        'attach-user'(session: Session): Awaitable<void | boolean>;
        'before-attach'(session: Session): void;
        'attach'(session: Session): void;
        'middleware'(session: Session): void;
    }
}
export type Component = Render<Awaitable<Fragment>, Session>;
export namespace Component {
    interface Options {
        passive?: boolean;
    }
}
export class SessionError extends Error {
    path: string | string[];
    param?: Dict;
    constructor(path: string | string[], param?: Dict);
}
export type Next = (next?: Next.Callback) => Promise<void | Fragment>;
export type Middleware = (session: Session, next: Next) => Awaitable<void | Fragment>;
export namespace Next {
    const MAX_DEPTH = 64;
    type Queue = ((next?: Next) => Awaitable<void | Fragment>)[];
    type Callback = void | string | ((next?: Next) => Awaitable<void | Fragment>);
    function compose(callback: Callback, next?: Next): Promise<void | Fragment>;
}
export interface Matcher extends Matcher.Options {
    context: Context;
    pattern: string | RegExp;
    response: Matcher.Response;
}
export namespace Matcher {
    type Response = Fragment | ((session: Session, params: [string, ...string[]]) => Awaitable<Fragment>);
    interface Options {
        i18n?: boolean;
        appel?: boolean;
        fuzzy?: boolean;
    }
}
export namespace Internal {
    interface Config {
        nickname?: string | string[];
        prefix?: Computed<string | string[]>;
    }
}
export class Internal {
    private ctx;
    private config;
    static readonly methods: string[];
    _hooks: [Context, Middleware][];
    _nameRE: RegExp;
    _sessions: Dict<Session>;
    _userCache: SharedCache<User.Observed<any>>;
    _channelCache: SharedCache<Channel.Observed<any>>;
    _components: Dict<Component>;
    _matchers: Set<Matcher>;
    constructor(ctx: Context, config: Internal.Config);
    protected get caller(): Context;
    middleware(middleware: Middleware, prepend?: boolean): any;
    component(name: string, component: Component, options?: Component.Options): () => boolean;
    match(pattern: string | RegExp, response: Matcher.Response, options: Matcher.Options): () => boolean;
    private _executeMatcher;
    prepare(): void;
    private _resolvePrefixes;
    private _stripNickname;
    private _process;
    private _handleMessage;
}
export namespace SharedCache {
    interface Entry<T> {
        value: T;
        key: string;
        refs: Set<string>;
    }
}
export class SharedCache<T> {
    #private;
    get(ref: string, key: string): T;
    set(ref: string, key: string, value: T): void;
    delete(ref: string): void;
}
export interface Token {
    rest?: string;
    content: string;
    quoted: boolean;
    terminator: string;
    inters: Argv[];
}
export interface Argv<U extends User.Field = never, G extends Channel.Field = never, A extends any[] = any[], O extends {} = {}> {
    args?: A;
    options?: O;
    error?: string;
    source?: string;
    initiator?: string;
    terminator?: string;
    session?: Session<U, G>;
    command?: Command<U, G, A, O>;
    rest?: string;
    pos?: number;
    root?: boolean;
    tokens?: Token[];
    name?: string;
    next?: Next;
}
export namespace Argv {
    export interface Interpolation {
        terminator?: string;
        parse?(source: string): Argv;
    }
    export function interpolate(initiator: string, terminator: string, parse?: (source: string) => Argv): void;
    export namespace whitespace {
        const unescape: (source: string) => string;
        const escape: (source: string) => string;
    }
    export class Tokenizer {
        private bracs;
        constructor();
        interpolate(initiator: string, terminator: string, parse?: (source: string) => Argv): void;
        parseToken(source: string, stopReg?: string): Token;
        parse(source: string, terminator?: string): Argv;
        stringify(argv: Argv): string;
    }
    export function parse(source: string, terminator?: string): Argv<never, never, any[], {}>;
    export function stringify(argv: Argv): string;
    export function revert(token: Token): void;
    export interface Domain {
        string: string;
        number: number;
        boolean: boolean;
        text: string;
        rawtext: string;
        user: string;
        channel: string;
        integer: number;
        posint: number;
        natural: number;
        date: Date;
    }
    type DomainType = keyof Domain;
    type ParamType<S extends string, F> = S extends `${any}:${infer T}` ? T extends DomainType ? Domain[T] : F : F;
    type Replace<S extends string, X extends string, Y extends string> = S extends `${infer L}${X}${infer R}` ? `${L}${Y}${Replace<R, X, Y>}` : S;
    type ExtractAll<S extends string, F> = S extends `${infer L}]${infer R}` ? [ParamType<L, F>, ...ExtractAll<R, F>] : [];
    type ExtractFirst<S extends string, F> = S extends `${infer L}]${any}` ? ParamType<L, F> : boolean;
    type ExtractSpread<S extends string> = S extends `${infer L}...${infer R}` ? [...ExtractAll<L, string>, ...ExtractFirst<R, string>[]] : [...ExtractAll<S, string>, ...string[]];
    export type ArgumentType<S extends string> = ExtractSpread<Replace<S, '>', ']'>>;
    export type OptionType<S extends string> = ExtractFirst<Replace<S, '>', ']'>, any>;
    export type Type = DomainType | RegExp | readonly string[] | Transform<any>;
    export interface Declaration {
        name?: string;
        type?: Type;
        fallback?: any;
        variadic?: boolean;
        required?: boolean;
    }
    export type Transform<T> = (source: string, session: Session) => T;
    export interface DomainConfig<T> {
        transform?: Transform<T>;
        greedy?: boolean;
    }
    export function createDomain<K extends keyof Domain>(name: K, transform: Transform<Domain[K]>, options?: DomainConfig<Domain[K]>): void;
    export function parseValue(source: string, quoted: boolean, kind: string, argv: Argv, decl?: Declaration): any;
    export interface OptionConfig<T extends Type = Type> {
        value?: any;
        fallback?: any;
        type?: T;
        authority?: number;
        descPath?: string;
    }
    export interface TypedOptionConfig<T extends Type> extends OptionConfig<T> {
        type: T;
    }
    export interface OptionVariant extends OptionConfig {
        syntax: string;
    }
    export interface OptionDeclaration extends Declaration, OptionVariant {
        values: Dict<any>;
        /** @deprecated */
        valuesSyntax: Dict<string>;
        variants: Dict<OptionVariant>;
    }
    type OptionDeclarationMap = Dict<OptionDeclaration>;
    export class CommandBase {
        readonly name: string;
        ctx: Context;
        declaration: string;
        _arguments: Declaration[];
        _options: OptionDeclarationMap;
        private _namedOptions;
        private _symbolicOptions;
        constructor(name: string, declaration: string, ctx: Context);
        _createOption(name: string, def: string, config: OptionConfig): void;
        private _assignOption;
        removeOption<K extends string>(name: K): boolean;
        parse(argv: string | Argv, terminator?: string, args?: any[], options?: Dict<any>): Argv;
        private stringifyArg;
        stringify(args: readonly string[], options: any): string;
    }
}
export type Extend<O extends {}, K extends string, T> = {
    [P in K | keyof O]?: (P extends keyof O ? O[P] : unknown) & (P extends K ? T : unknown);
};
export namespace Command {
    interface Shortcut {
        i18n?: boolean;
        name?: string | RegExp;
        command?: Command;
        prefix?: boolean;
        fuzzy?: boolean;
        args?: string[];
        options?: Dict;
    }
    type Action<U extends User.Field = never, G extends Channel.Field = never, A extends any[] = any[], O extends {} = {}> = (argv: Argv<U, G, A, O>, ...args: A) => Awaitable<void | Fragment>;
    type Usage<U extends User.Field = never, G extends Channel.Field = never> = string | ((session: Session<U, G>) => Awaitable<string>);
}
export class Command<U extends User.Field = never, G extends Channel.Field = never, A extends any[] = any[], O extends {} = {}> extends Argv.CommandBase {
    config: Command.Config;
    children: Command[];
    parent: Command;
    _aliases: string[];
    _examples: string[];
    _usage?: Command.Usage;
    _disposed?: boolean;
    _disposables?: Disposable[];
    _disposables2: Disposable[];
    private _userFields;
    private _channelFields;
    private _actions;
    private _checkers;
    static defaultConfig: Command.Config;
    static defaultOptionConfig: Argv.OptionConfig;
    private static _userFields;
    private static _channelFields;
    /** @deprecated use `command-added` event instead */
    static userFields(fields: FieldCollector<'user'>): typeof Command;
    /** @deprecated use `command-added` event instead */
    static channelFields(fields: FieldCollector<'channel'>): typeof Command;
    constructor(name: string, decl: string, ctx: Context);
    get displayName(): string;
    set displayName(name: string);
    private _registerAlias;
    userFields<T extends User.Field = never>(fields: FieldCollector<'user', T, A, O>): Command<U | T, G, A, O>;
    channelFields<T extends Channel.Field = never>(fields: FieldCollector<'channel', T, A, O>): Command<U, G | T, A, O>;
    alias(...names: string[]): this;
    _escape(source: any): any;
    shortcut(pattern: string | RegExp, config?: Command.Shortcut & {
        i18n?: false;
    }): this;
    shortcut(pattern: string, config: Command.Shortcut & {
        i18n: true;
    }): this;
    subcommand<D extends string>(def: D, config?: Command.Config): Command<never, never, Argv.ArgumentType<D>>;
    subcommand<D extends string>(def: D, desc: string, config?: Command.Config): Command<never, never, Argv.ArgumentType<D>>;
    usage(text: Command.Usage<U, G>): this;
    example(example: string): this;
    option<K extends string>(name: K, desc: string, config: Argv.TypedOptionConfig<RegExp>): Command<U, G, A, Extend<O, K, string>>;
    option<K extends string, R>(name: K, desc: string, config: Argv.TypedOptionConfig<(source: string) => R>): Command<U, G, A, Extend<O, K, R>>;
    option<K extends string, R extends string>(name: K, desc: string, config: Argv.TypedOptionConfig<R[]>): Command<U, G, A, Extend<O, K, R>>;
    option<K extends string, D extends string>(name: K, desc: D, config?: Argv.OptionConfig): Command<U, G, A, Extend<O, K, Argv.OptionType<D>>>;
    match(session: Session): boolean;
    getConfig<K extends keyof Command.Config>(key: K, session: Session): Exclude<Command.Config[K], (session: Session) => any>;
    check(callback: Command.Action<U, G, A, O>, append?: boolean): this;
    before(callback: Command.Action<U, G, A, O>, append?: boolean): this;
    action(callback: Command.Action<U, G, A, O>, prepend?: boolean): this;
    use<T extends Command, R extends any[]>(callback: (command: this, ...args: R) => T, ...args: R): T;
    execute(argv: Argv<U, G, A, O>, fallback?: Next): Promise<Fragment>;
    dispose(): void;
}
export namespace Command {
    interface Config {
        /** min authority */
        authority?: Computed<number>;
        /** disallow unknown options */
        checkUnknown?: boolean;
        /** check argument count */
        checkArgCount?: boolean;
        /** show command warnings */
        showWarning?: boolean;
        /** depend on existing commands */
        patch?: boolean;
    }
    const Config: Schema<Config>;
}
export interface CommandMap extends Map<string, Command> {
    resolve(key: string): Command;
}
declare module '@satorijs/core' {
    interface Context {
        $commander: Commander;
        command<D extends string>(def: D, config?: Command.Config): Command<never, never, Argv.ArgumentType<D>>;
        command<D extends string>(def: D, desc: string, config?: Command.Config): Command<never, never, Argv.ArgumentType<D>>;
    }
    interface Events {
        'before-parse'(content: string, session: Session): Argv;
        'command-added'(command: Command): void;
        'command-removed'(command: Command): void;
        'command-error'(argv: Argv, error: any): void;
        'command/before-execute'(argv: Argv): Awaitable<void | string>;
        'command/before-attach-channel'(argv: Argv, fields: Set<Channel.Field>): void;
        'command/before-attach-user'(argv: Argv, fields: Set<User.Field>): void;
    }
}
export namespace Commander {
    interface Config {
    }
}
export class Commander {
    private ctx;
    private config;
    static readonly key = "$commander";
    static readonly methods: string[];
    _commandList: Command[];
    _commands: CommandMap;
    _shortcuts: Command.Shortcut[];
    constructor(ctx: Context, config?: Commander.Config);
    available(session: Session): string[];
    protected get caller(): any;
    resolve(key: string): Command<never, never, any[], {}>;
    getCommand(name: string): Command<never, never, any[], {}>;
    command(def: string, ...args: [Command.Config?] | [string, Command.Config?]): any;
}
declare const kTemplate: unique symbol;
declare module '@satorijs/core' {
    interface Context {
        i18n: I18n;
    }
    interface Events {
        'internal/i18n'(): void;
    }
}
export interface CompareOptions {
    minSimilarity?: number;
}
export namespace I18n {
    type Node = string | Store;
    interface Store {
        [kTemplate]?: string;
        [K: string]: Node;
    }
    type Formatter = (value: any, args: string[], locale: string) => string;
    type Renderer = (dict: Dict, params: any, locale: string) => string;
    interface FindOptions extends CompareOptions {
    }
    interface FindResult {
        locale: string;
        data: Dict;
        similarity: number;
    }
}
export class I18n {
    ctx: Context;
    _data: Dict<I18n.Store>;
    _presets: Dict<I18n.Renderer>;
    constructor(ctx: Context);
    compare(expect: string, actual: string, options?: CompareOptions): number;
    private set;
    define(locale: string, dict: I18n.Store): void;
    define(locale: string, key: string, value: I18n.Node): void;
    /** @deprecated */
    formatter(name: string, callback: I18n.Formatter): void;
    /** @deprecated */
    preset(name: string, callback: I18n.Renderer): void;
    find(path: string, actual: string, options?: I18n.FindOptions): I18n.FindResult[];
    render(value: I18n.Node, params: any, locale: string): string;
    text(locales: Iterable<string>, paths: string[], params: object): string;
    private registerBuiltins;
}
declare module '@satorijs/core' {
    interface Session<U extends User.Field = never, G extends Channel.Field = never> {
        locale?: string;
        argv?: Argv<U, G>;
        user?: User.Observed<U>;
        channel?: Channel.Observed<G>;
        guild?: Channel.Observed<G>;
        parsed?: Parsed;
        scope?: string;
        username?: string;
        send(content: Fragment, options?: SendOptions): Promise<string[]>;
        cancelQueued(delay?: number): void;
        sendQueued(content: Fragment, delay?: number): Promise<string[]>;
        resolveValue<T, R extends any[]>(source: T | ((session: Session, ...args: R) => T), ...args: R): T;
        getChannel<K extends Channel.Field = never>(id?: string, fields?: K[]): Promise<Channel>;
        observeChannel<T extends Channel.Field = never>(fields?: Iterable<T>): Promise<Channel.Observed<T | G>>;
        getUser<K extends User.Field = never>(id?: string, fields?: K[]): Promise<User>;
        observeUser<T extends User.Field = never>(fields?: Iterable<T>): Promise<User.Observed<T | U>>;
        withScope<T>(scope: string, callback: () => T): Promisify<T>;
        text(path: string | string[], params?: object): string;
        collect<T extends 'user' | 'channel'>(key: T, argv: Argv, fields?: Set<keyof Tables[T]>): Set<keyof Tables[T]>;
        inferCommand(argv: Argv): Command;
        resolve(argv: Argv): Command;
        execute(content: string, next?: true | Next): Promise<string>;
        execute(argv: Argv, next?: true | Next): Promise<string>;
        middleware(middleware: Middleware): () => boolean;
        prompt(timeout?: number): Promise<string>;
        prompt<T>(callback: (session: Session) => Awaitable<T>, options?: PromptOptions): Promise<T>;
        suggest(options: SuggestOptions): Promise<string>;
        transform(elements: segment[]): Promise<segment[]>;
        response?: () => Promise<Fragment>;
    }
    namespace Session {
        interface Private extends Session {
            _queuedTasks: Task[];
            _queuedTimeout: NodeJS.Timeout;
            _next(): void;
            _observeChannelLike<T extends Channel.Field = never>(channelId: string, fields: Iterable<T>): Promise<any>;
        }
    }
}
export interface PromptOptions {
    timeout?: number;
}
export interface SuggestOptions extends CompareOptions {
    actual?: string;
    expect: readonly string[];
    prefix?: string;
    suffix: string;
    timeout?: number;
}
export interface Parsed {
    content: string;
    prefix: string;
    appel: boolean;
}
export type Computed<T> = T | ((session: Session) => T);
export interface Task {
    delay: number;
    content: Fragment;
    resolve(ids: string[]): void;
    reject(reason: any): void;
}
export type FieldCollector<T extends keyof Tables, K = keyof Tables[T], A extends any[] = any[], O = {}> = Iterable<K> | ((argv: Argv<never, never, A, O>, fields: Set<keyof Tables[T]>) => void);
export type Plugin = cordis.Plugin<Context>;
export namespace Plugin {
    type Function<T = any> = cordis.Plugin.Function<T, Context>;
    type Constructor<T = any> = cordis.Plugin.Constructor<T, Context>;
    type Object<S = any, T = any> = cordis.Plugin.Object<S, T, Context>;
}
export type EffectScope = cordis.EffectScope<Context>;
export type ForkScope = cordis.ForkScope<Context>;
export type MainScope = cordis.MainScope<Context>;
export type Service = cordis.Service<Context>;
export const Service: {
    new (ctx: Context, name: string, immediate?: boolean): cordis.Service<Context>;
};
export { resolveConfig } from 'cordis';
export type { Disposable } from 'cordis';
declare module '@satorijs/core' {
    interface Context {
    }
    namespace Context {
        interface Config extends Config.Basic, Config.Message, Config.Advanced {
        }
        namespace Config {
            interface Basic {
                locale?: string;
                prefix?: Computed<string | string[]>;
                nickname?: string | string[];
                autoAssign?: Computed<Awaitable<boolean>>;
                autoAuthorize?: Computed<Awaitable<number>>;
                minSimilarity?: number;
            }
            interface Message {
                delay?: DelayConfig;
            }
            interface DelayConfig {
                character?: number;
                message?: number;
                cancel?: number;
                broadcast?: number;
                prompt?: number;
            }
            interface Advanced {
                maxListeners?: number;
            }
            interface Static extends Schema<Config> {
                Basic: Schema<Basic>;
                Message: Schema<Message>;
                Advanced: Schema<Advanced>;
            }
        }
    }
}
export { Context as App };
export function defineConfig(config: Context.Config): Context.Config;
declare module '@satorijs/core' {
    interface Context {
        /** @deprecated use `ctx.root` instead */
        app: Context;
        /** @deprecated use `root.config` instead */
        options: Context.Config;
        logger(name: string): Logger;
        waterfall<K extends keyof GetEvents<this>>(name: K, ...args: Parameters<GetEvents<this>[K]>): Promisify<ReturnType<GetEvents<this>[K]>>;
        waterfall<K extends keyof GetEvents<this>>(thisArg: ThisType<GetEvents<this>[K]>, name: K, ...args: Parameters<GetEvents<this>[K]>): Promisify<ReturnType<GetEvents<this>[K]>>;
        chain<K extends keyof GetEvents<this>>(name: K, ...args: Parameters<GetEvents<this>[K]>): ReturnType<GetEvents<this>[K]>;
        chain<K extends keyof GetEvents<this>>(thisArg: ThisType<GetEvents<this>[K]>, name: K, ...args: Parameters<GetEvents<this>[K]>): ReturnType<GetEvents<this>[K]>;
        before<K extends BeforeEventName>(name: K, listener: BeforeEventMap[K], append?: boolean): () => boolean;
        setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]): () => boolean;
        setInterval(callback: (...args: any[]) => void, ms: number, ...args: any[]): () => boolean;
    }
    namespace Context {
        interface Private extends Context {
            createTimerDispose(timer: NodeJS.Timeout): () => boolean;
        }
    }
}
type OmitSubstring<S extends string, T extends string> = S extends `${infer L}${T}${infer R}` ? `${L}${R}` : never;
type BeforeEventName = OmitSubstring<keyof Events & string, 'before-'>;
export type BeforeEventMap = {
    [E in keyof Events & string as OmitSubstring<E, 'before-'>]: Events[E];
};
export * from '@koishijs/utils';
export * from '@minatojs/core';
export { version };
